# 1. 基本结构

堆是一棵二叉树

- 小根堆
  - 根节点值小于等于左右子节点
- 大根堆
  - 根节点大于等于左右子节点

# 2. 存储方式

**利用一维数组进行存储**，为了方便，下标从 `1` 开始

- 对于第`x`个元素`(x ~ [1,n])` `nums[x]`
  - 左儿子`nums[2x]`
  - 右儿子为`nums[2x + 1]`

# 3. 操作方式

- `down()`：将元素下移至合适位置

  - 先判断根节点是不是根 左 右 三个元素中的最小值
  - 与左右最小值进行交换
  - 交换后继续以上判断

- ```c++
  void down(int u)
  {
      int t = u;
      //左儿子
      if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
      //右儿子
      if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
      //如果根节点不是最小值
      if (u != t)
      {
          //交换根节点与最小值
          heap_swap(u, t);
          //递归交换
          down(t);
      }
  }
  ```

  

- `up()`：将元素上移至合适位置

  - 比较当前元素与父节点

- ```c++
  void up(int u)
  {
      while (u / 2 && h[u] < h[u / 2])
      {
          heap_swap(u, u / 2);
          u >>= 1;
      }
  }
  ```

  

插入以及删除操作时间复杂度为`O(logn)`

## 3.1 建堆

将元素一个一个进行插入操作，时间复杂度为`O(nlogn)`,插入操作时间复杂度为`O(logn)`，`n`个元素进行插入即`O(nlogn)`

我们可以从数组中间进行`down()`操作，即

```c++
for(int i = n / 2; i >= 1; i--) down(i)
```

这样操作的事件复杂度为`O(n)`

## 3.1 插入一个数

在数组尾部添加，然后不断上移`up()`

## 3.2 求集合最小值

对于小根堆来说，堆顶元素即数组头部元素即为最小值

## 3.3 删除最小值

将尾部节点交换至数组头部，然后不断下移`down()`

## 3.4 删除任意一个元素

将尾部节点交换至指定位置，然后上/下移

## 3.5 修改任意一个元素

修改后进行上/下移动



# 4. 代码模板

```c++
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);

```

