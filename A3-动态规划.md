# 1.01背包问题

[AcWing 2. 01背包问题 - AcWing](https://www.acwing.com/activity/content/problem/content/997/)

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤10000<N,V≤1000
0<vi,wi≤10000<vi,wi≤1000

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```
8
```

##  1）二维数组dp

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;
int n, m;
int v[N],w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >>v[i] >> w[i];
    
    
    for(int i = 1; i <= n; i++){
        for(int j = 0 ; j <= m; j++){
            f[i][j] = f[i-1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j],f[i-1][j-v[i]] + w[i]);
        }
    }
    
    cout << f[n][m];
    return 0;
}
```

## 2）一维数组dp

对于01背包一维优化的一点理解：
二维转化为一维：
删掉了第一维：在前i个物品中取。
f[j]表示：拿了总体积不超过j的物品，最大总价值。

为何能转化为一维？
二维时的更新方式：

```c++
f[i][j]=max(f[i - 1][j] ,f[i - 1][j - v[i]] + w[i]);
```

1.我们发现，对于每次循环的下一组i，只会用到i-1来更新当前值，不会用到i-2及之前值。于是可以在这次更新的时候，将原来的更新掉，反正以后也用不到。
所以对于i的更新，只需用一个数组，直接覆盖就行了。
2.我们发现，对于每次j的更新，只需用到之前i-1时的j或者j-v[i]，不会用到后面的值。
所以为了防止串着改，我们采取从后往前更新的方式，用原来i-1的数组来更新i。
（如果从前往后更新的话，前面的更新过之后，会接着更新后面的值，这样就不能保证是用原来i-1的数组来更新i的了）

如何转化为一维呢？
只用一个数组，每次都覆盖前面的数组。

1.如果当前位置的东西不拿的话，和前一位置的信息（原来i-1数组的这个位置上的值）是相同的，所以不用改变。
2.如果当前位置的东西拿了的话，需要和前一位置的信息（原来i-1数组的这个位置上值）取max。
所以，更新方式就为：f[j]=max(f[j],f[j-v[i]]+w[i]);

整个更新方式就相当于：

每次i++，就从后往前覆盖一遍f数组，看每个位置上的值是否更新。

**作者：yxc**
**链接：https://www.acwing.com/video/34/**
**来源：AcWing**
**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**

## 3）分割等和子集

[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

### 二维数组

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x : nums)  sum += x;
        if(sum % 2 == 1) return false;
        int con = sum / 2;

        vector<vector<int>> dp(n+1,vector<int>(con+1,0));

        for(int i = nums[0]; i <= con; i++){
            dp[0][i] = nums[0];
        }
    
        for(int i = 1; i < n; i++){
            for(int j = 0; j <= con; j++){  
                if( j >= nums[i] )
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i]);
                else
                    dp[i][j] = dp[i-1][j];  
            }
        }
        if(dp[n-1][con] == con) return true;
        return false;
    }
};
```

### 一维数组

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x : nums)  sum += x;
        if(sum % 2 == 1) return false;
        int con = sum / 2;

        vector<int> dp(con+1,0);

        for(int i = 0; i < n; i++){
            for(int j = con; j >= nums[i]; j--){  
                dp[j] = max(dp[j],dp[j-nums[i]] + nums[i]);
            }
        }
        if(dp[con] == con) return true;
        return false;
    }
};
```

## 4）最后一块石头的重量

### 二维数组

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int n = stones.size();
        int sum = 0;
        for(auto x : stones) sum += x;
        int target = sum / 2;
        vector<vector<int>> dp(n+1,vector<int>(target+1,0));
        for(int i = stones[0]; i <= target; i++) dp[0][i] = stones[0];
        for(int i = 1; i < n; i++){
            for(int j = 0; j <= target; j++){
                dp[i][j] = dp[i-1][j];
                if(j >= stones[i])
                    dp[i][j] = max(dp[i][j],dp[i-1][j-stones[i]] + stones[i]);
            }  
        }
        return sum - dp[n-1][target] - dp[n-1][target];
    }
};
```

### 一维数组

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int n = stones.size();
        int sum = 0;
        for(auto x : stones) sum += x;
        vector<int> dp(sum+1,0);
        int target = sum / 2;
        for(int i = 0; i < n; i++){
            for(int j = target; j >= stones[i]; j--)
                dp[j] = max(dp[j],dp[j-stones[i]] + stones[i]);
        }

        return sum - dp[target] - dp[target];
    }
};
```

## 5）目标和

[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

### 思路：

**目标和为target, 所有元素之和为sum，假设加法对应的总和为x，则减法对应的总和为 sum - x,**

**则有x - (sum - x) = target， 即 x = (target + sum) / 2, 因此只要给定数组中有相加之和为x 的一组元素，则代表有一组解**

### 暴力解法（回溯）

```c++
class Solution {
public:
    int res;
    void backTracking(vector<int>& nums, int target,int sum, int startIndex)
    {
        if(sum == target){
            res++;
        }
        for(int i = startIndex; i < nums.size() && sum + nums[i] <= target; i++){
            sum += nums[i];
            backTracking(nums,target,sum,i+1);
            sum -= nums[i];
        }
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int sum = 0;
        for(auto x : nums) sum += x;
        if(target > sum ) return 0;
        if((target + sum) % 2 == 1) return 0;
        int x = (target + sum) / 2;
        

        backTracking(nums,x,0,0);
        return res;
    }
};
```

**在判断终止条件处要注意，满足条件时并未return，而是继续递归，因为当给定数组中有重复0时，继续相加的结果不变，但元素个数增加了一个，因此也算一种答案**

```c++
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
0
```



### 动态规划

**考虑转化为01背包问题**

- 背包容量为 x = (target + sum) / 2
- 物品体积以及价值均为num[i]
- 物品数量为nums.size()

- dp[i]表示填满容量为i的背包有dp[i]种方法
- 递归公式：

```
因为填满容量为j-nums[i]的背包有dp[j-nums[i]]种方法
所以遍历到nums[i]时，填满容量为j的背包的方法就有dp[j-nums[i]]种方法，
即在填满容量为j-nums[i]的背包的每一种方法上在加上一个nums[i]

因此 dp[j] += dp[j-nums[i]];

```

**该公式在利用背包解决排列组合问题时经常会用到**

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(S) > sum) return 0; // 此时没有方案
        if ((S + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (S + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```

## 6）一和零

[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

```c++
class Solution {
public:
/*
    dp[i][j]————最多有i个0和j个1的strs的最大子集的大小
    对于当前字符串，其有a个0，b个1，则
        dp[i][j] = dp[i-a][j-b] + 1;
    每次取dp[i][j]的最大值，即
        dp[i][j] = max(dp[i][j], dp[i][j] = dp[i-a][j-b] + 1)
*/
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1,0));
        //遍历物品
        for(auto str : strs){
            int a = 0, b = 0;
            for(auto s : str){
                if(s == '0') a++;
                else b++;
            }
            //滚动数组倒序遍历背包容量
            for(int i = m; i >= a; i--)
                for(int j = n; j >= b; j--)
                    dp[i][j] = max(dp[i][j], dp[i-a][j-b] + 1);
        }
        return dp[m][n];
    }
};
```

### 注意事项：

**该题看起来用的是二维数组，但是这个二维的意思与之前的题目不用，因为该题的m和n都可以看作是背包的容积，只不过这个容积是二维的，而物品的体积和价值就是每个字符串中0和1的个数，也是一个二维的量，所以该题看似用的二维数组，其实还是用的滚动数组，因此在遍历时，要注意是倒序遍历**

# 2. 完全背包问题

[3. 完全背包问题 - AcWing题库](https://www.acwing.com/problem/content/3/)

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤10000<N,V≤1000
0<vi,wi≤10000<vi,wi≤1000

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```
10
```

## 1）二维数组dp

### 朴素解法：

由于物品数量无限，因此在遍历物品时，要增加一维遍历，用来遍历物品数量

```c++
//此层循环用于遍历第i个物品的数量
for(int k = 0; k * v[i] <= j; k++){
    //之所以是dp[i][j] 而不是 dp[i-1][j]， 是因为当 k = 0时，第二个式子就是dp[i-1][j]
	dp[i][j] = max(dp[i][j], dp[i-1][j - k * v[i]] + k * w[i]);
}
```

因此完整解法为：

```c++
#include<iostream>

using namespace std;

const int N = 1010;
int m, n;
int v[N],w[N];
int dp[N][N];

int main()
{
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >>v[i] >> w[i];
    
    for(int i = 1; i <= m; i++){
        for(int j = 0; j <= n; j++){
           for(int k = 0; k * v[i] <= j; k++)
               //之所以是dp[i][j] 而不是 dp[i-1][j]， 是因为当 k = 0时，第二个式子就是dp[i-1][j]
               	dp[i][j] = max(dp[i][j],dp[i-1][j - k * v[i]] + k * w[i]);
        }
    }
    cout << dp[m][n];
    
    return 0;
}
```

**最坏时间复杂度为 n * v^2 = 10 ^ 9，会超时**

### 优化解法：

观察状态转移方程：

```c++
dp[i][j] = dp[i-1][j - k * v[i]] + k * w[i])
    //对状态进行枚举
    dp[i][j] = Max(dp[i-1][j], dp[i-1][j-v]+w, dp[i-1][j-2v]+2w, dp[i-1][j-3v]+3w,.....)
    dp[i][j-v]= Max( 		   dp[i-1][j-v],   dp[i-1][j-2v]+w,  dp[i-1][j-3v]+2w,.....)
```

**因此可以发现，**

```c++
dp[i][j] = Max(dp[i-1][j],dp[i][j-v] + w)
```

该式子和01背包问题的状态转移方程**非常相似**，由此可以写出如下代码：

```c++
#include<iostream>

using namespace std;

const int N = 1010;
int m, n;
int v[N],w[N];
int dp[N][N];

int main()
{
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >>v[i] >> w[i];
    
    for(int i = 1; i <= m; i++){
        for(int j = 0; j <= n; j++){
            dp[i][j] = dp[i-1][j];
            if(j >= v[i])
       //01背包：dp[i][j] = max(dp[i][j],dp[i-1][j - v[i]] + w[i])
                dp[i][j] = max(dp[i][j],dp[i][j - v[i]] + w[i]);
        
        }
    }
    cout << dp[m][n];
    
    return 0;
}
```

## 2）一维数组dp

**与01背包相比，就是多了一项每个物品的数量无限，因此在遍历物品时，正序遍历就可以了，因为在01背包问题中，遍历背包容量时之所以倒序遍历，就是为了防止重复拿取物品**

```cpp
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
// 先遍历背包，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}

```

## 3）零钱兑换Ⅱ

[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

### 解法：

**该题和纯背包问题不同，纯完全背包是能否凑成总金额，而本题是要求凑成总金额的个数**

并且题目描述中是凑成总金额的硬币**组合数**，**而非排列数**，排列和组合的区别在学习回溯算法的时候已经区别过了

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1,0);
        dp[0] = 1;
        for(int i = 0; i < coins.size(); i++){
            for(int j = coins[i]; j <= amount; j++){
                dp[j] += dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
};
```

### 特别注意：

**该题对于遍历顺序有特殊要求，他只能遍历物品在外，遍历容积在内**

因为纯完全背包求得是否凑成总和，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！

而本题要求凑成总和的组合数，元素之间要求没有顺序。

所以纯完全背包是能凑成总和就行，不用管怎么凑的。

本题是求凑出来的方案个数，且每个方案个数是为组合数。

那么本题，两个for循环的先后顺序可就有说法了。

我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。

代码如下：

```cpp
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```

假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。

**所以这种遍历顺序中dp[j]里计算的是组合数！**

如果把两个for交换顺序，代码如下：

```c++
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。

**此时dp[j]里算出来的就是排列数！**

**例如，1 和 3 都在数组nums 中，计算 dp[4] 的时候，排列的最后一个元素可以是 1 也可以是 3，因此 dp[1] 和 dp[3] 都会被考虑到，即不同的顺序都会被考虑到。**

## 4）组合总和Ⅳ

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

**该题就是典型的排列问题，而不是组合问题，在上一题中明确讲过，组合问题和排列问题的两层for循环的位置是不相同的，组合问题是必须先遍历背包，然后遍历容量，这样保证遍历过程中不会重复计算{1，3}和{3，1}，而排列问题必须先遍历容量，在遍历背包，这样才能保证将{1，3}和{3，1}都计算进去**

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 0; i <= target; i++) { // 遍历背包
            for (int j = 0; j < nums.size(); j++) { // 遍历物品
                if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};

```

该题还要注意一个整数溢出的问题。

## 5）爬楼梯进阶版

### 原题：

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数

### 改版：

**一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？**

1阶，2阶，.... m阶就是物品，楼顶就是背包。

每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。

问跳到楼顶有几种方法其实就是问装满背包有几种方法。

### 解法：

那么现在该题就与[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)一样，成为了一道完全背包问题

- 1，2，3，.... , m是物品

- 楼顶是背包容量

```c++
class Solution {
public:
    int climbStairs(int n， int m) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // 遍历背包
            for (int j = 1; j <= m; j++) { // 遍历物品
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
```



## 6）零钱兑换

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

该题与[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)类似，但是该题是返回可以**凑成总金额所需的 最少的硬币个数**，而[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)是返回**可以凑成总金额的硬币组合数**

- **dp[j]: 凑成总金额j所需的 最少的硬币个数**
- **dp[j] = dp[j - coins[i] + 1**
- **dp[j] = min(dp[j - coins[i]] + 1, dp[j]);**

**对于dp数组的初始化要格外注意：**

1. 首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;
2. 考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。所以下标非0的元素都是应该是最大值。

```c++
vector<int> dp(amount + 1, INT_MAX);
dp[0] = 0;
```

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```



## 7）完全平方数

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

- dp[j]: 和为 j 的完全平方数的最少数量为dp[j]
- dp[j] = dp[j-i*i] + 1
- 因为要取最小值，所以dp[j] = min(dp[j],dp[j-i*i] + 1)

```c++
class Solution {
public:
    int numSquares(int n) {
        /*
            dp[j]: 和为 j 的完全平方数的最少数量为dp[j]
            dp[j] = dp[j-1]+1 dp[j-4] + 1....
        */
        vector<int> dp(n+1,INT_MAX);
        int nums = sqrt(n);
        dp[0] = 0;
        for(int i = 0; i <= nums; i++)
        {
            for(int j = i * i; j <= n; j++)
            {
                //若dp[j - i*i] = INT_MAX，则dp[j] = dp[j],可以直接跳过，同时还避免了INT_MAX+1造成溢出
                if(dp[j - i*i] != INT_MAX)
                    dp[j] = min(dp[j],dp[j-i*i] + 1);
            }
        }
        return dp[n];
    }
};
```



## 8）单词拆分

[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

**回溯解法：**

使用memory数组保存每次计算的以startIndex起始的计算结果，如果memory[startIndex]里已经被赋值了，直接用memory[startIndex]的结果。

```c++
class Solution {
private:
    bool backtracking (const string& s,
            const unordered_set<string>& wordSet,
            vector<int>& memory,
            int startIndex) {
        if (startIndex >= s.size()) {
            return true;
        }
        // 如果memory[startIndex]不是初始值了，直接使用memory[startIndex]的结果
        if (memory[startIndex] != -1) return memory[startIndex];
        for (int i = startIndex; i < s.size(); i++) {
            string word = s.substr(startIndex, i - startIndex + 1);
            if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet, memory, i + 1)) {
                memory[startIndex] = 1; // 记录以startIndex开始的子串是可以被拆分的
                return true;
            }
        }
        memory[startIndex] = 0; // 记录以startIndex开始的子串是不可以被拆分的
        return false;
    }
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<int> memory(s.size(), -1); // -1 表示初始化状态
        return backtracking(s, wordSet, memory, 0);
    }
};
```

**动规：**

如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。

所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> hash(wordDict.begin(), wordDict.end());
        //dp[i]:字符串s前 i 个字符是否可以利用字典中出现的单词拼接出
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        //状态方程：
        
        for(int i = 1; i <= s.size(); i++)   //遍历背包
        {
            for(int j = 0; j <= i; j++)     //遍历物品
            {
                string word = s.substr(j, i - j);
                if(hash.find(word) != hash.end() && dp[j])
                    dp[i] = true;
            }
        }  
        return dp[s.size()];
    }
};
```



# 3. 多重背包问题Ⅰ

[ACWing 多重背包问题](https://www.acwing.com/problem/content/4/)

有 N 种物品和一个容量是 V 的背包。

第 ii种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，N，，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤1000<N,V≤100
0<vi,wi,si≤1000<vi,wi,si≤100

**输入样例**

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```
10
```

## 1）朴素解法：

​	与完全背包问题的朴素解法思想一致，对物品数量进行分组，从0至Si遍历

```c++
#include<iostream>

using namespace std;

const int N = 1010;
int m, n;
int v[N],w[N],s[N];
int dp[N][N];

int main()
{
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >>v[i] >> w[i] >> s[i];
    
    for(int i = 1; i <= m; i++){
        for(int j = 0; j <= n; j++){
            //注意 k 值的限定条件
            for(int k = 0; k <= s[i] && k * v[i] <= j; k++){
               //之所以是dp[i][j] 而不是 dp[i-1][j]， 是因为当 k = 0时，第二个式子就是dp[i-1][j]
                dp[i][j] = max(dp[i][j],dp[i-1][j - k * v[i]] + k * w[i]);
            }
        }
    }
    cout << dp[m][n];
    
    return 0;
}
```



# 4. 多重背包问题Ⅱ

[5. 多重背包问题 II - AcWing题库](https://www.acwing.com/problem/content/5/)

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 NN 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N≤10000<N≤1000
0<V≤20000<V≤2000
0<vi,wi,si≤20000<vi,wi,si≤2000

**提示：**

本题考查多重背包的二进制优化方法。

**输入样例**

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```
10
```

该题与上一题比起来，每个物品的数量上升了一个数量级，利用与上一题相同的朴素解法会超时。

因此该题需要优化一下，首先，考虑与完全背包问题一样的优化思路

```c++
dp[i][j] = dp[i-1][j - k * v[i]] + k * w[i])
    //对状态进行枚举
dp[i][j] = Max(dp[i-1][j], dp[i-1][j-v]+w,dp[i-1][j-2v]+2w,..,dp[i-1][j-sv]+sw)
dp[i][j-v]= Max( 		   dp[i-1][j-v],  dp[i-1][j-2v]+w,...,dp[i-1][j-sv]+(s-1)w， dp[i-1][j-(s+1)v]+sw)
  
    /*
    	可以看出dp[i][j-v]多了一项dp[i-1][j-(s+1)v]+sw)，而我们无法求出除了最后一个数以外的最大值，因此无法用完全背包的优化方式来优化多重背包问题
    */
```

## 1）优化方式——二进制优化

```
假设第 i 个物品的最大数量Si = 1023
我们可以对该物品进行打包,打包数量按二进制方式划分，即
每一组的数量分别为
	1，2，4，8，...，512
一共分成了10组
	1+2+..+512 = 1023
根据二进制与十进制的转换规律，1，2，4,...,512(2^9),这些数可以表示1~2^10-1 即1 ~ 1023之间的任何数
因此我们可以根据这10组数量，拼凑出物品i所有的数量，因此将枚举数量从1023次降低到了10次。

优化之前时间复杂度为N*V*S
优化之后时间复杂度为N*V*logS
```

**优化之前时间复杂度为NVS**
**优化之后时间复杂度为NVlogS**

## 2）完整代码

上述优化方式代码实现：

```
第 i 个物品的最大数量为Si
	进行二进制划分：
		1，2，4，... ,2^k,c
	2^k要保证等比数列之和小于Si, c为 Si 减去等比数列之和的剩下的部分，c < 2^(k+1)
```



```c++
#include<iostream>

using namespace std;

const int N = 25000, M = 2010;
int n,m;
int v[N],w[N];
int f[N];

int main()
{
    cin >>n>>m;
    int cnt = 0;
    for(int i = 1; i <= n; i++){
        int a, b ,s;    //体积 价值 数量
        cin >> a >> b >> s;
        int k = 1;
        while(k <= s){
            cnt++;
            v[cnt] = k * a;
            w[cnt] = k * b;
            s -= k;
            k *= 2;
        }
        if(s > 0){
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    
    n = cnt;
    
    for(int i = 1;i <= n; i++)
        for(int j = m; j >= v[i]; j--)
            f[j] = max(f[j],f[j-v[i]] + w[i]);
            
    cout << f[m] << endl;
    
    return 0;
            
}
```



# 5. 分组背包问题

[9. 分组背包问题 - AcWing题库](https://www.acwing.com/problem/content/9/)

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

**输入格式**

第一行有两个整数 N，，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 NN 组数据：

- 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
- 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤1000<N,V≤100
0<Si≤1000<Si≤100
0<vij,wij≤1000<vij,wij≤100

**输入样例**

```
3 5
2
1 2
2 4
1
3 4
1
4 5
```

**输出样例：**

```
8
```

## 1）二维数组

```c++
#include<iostream>

using namespace std;

const int N = 1010;
//组数，容量
int n , m;
int v[N][N], w[N][N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    
    for(int i = 1; i <= n;i++){
        cin >> s[i];
        for(int j = 0; j < s[i]; j++)
            cin >> v[i][j] >> w[i][j];
    }
    
    for(int i = 1; i <= n; i++){
        for(int j = 0; j <= m; j++){
            f[i][j] = f[i-1][j];
            for(int k = 0; k < s[i]; k++){
                if(j >= v[i][k])
                    f[i][j] = max(f[i][j],f[i-1][j-v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[n][m]<<endl;
    return 0;
}

```

## 2）一维数组

```c++
#include<iostream>

using namespace std;

const int N = 1010;
//组数，容量
int n , m;
int v[N][N], w[N][N], s[N];
int f[N];

int main()
{
    cin >> n >> m;
    
    for(int i = 1; i <= n;i++){
        cin >> s[i];
        for(int j = 0; j < s[i]; j++)
            cin >> v[i][j] >> w[i][j];
    }
    
    for(int i = 1; i <= n; i++){
        for(int j = m; j >= 0; j--){
            for(int k = 0; k < s[i]; k++){
                if(j >= v[i][k])
                    f[j] = max(f[j],f[j-v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m]<<endl;
    return 0;
}
```



# 6. 打家劫舍

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```c++
class Solution {
public:
    /*
        dp[j]:偷窃前j个房屋能获得的最高金额
        dp[j] = dp[j-2] + nums[i];
    */
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n+1,0);
        if(n == 1) return nums[0];
        if(n == 2) return max(nums[0],nums[1]);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++){
            dp[i] = max( dp[i-2] + nums[i],dp[i-1]);
        }

        return dp[nums.size()-1];
    }
};

```

## 错解：

**一时手滑，在初始化DP数组时，直接令dp[1] = nums[1]，导致错误**

# 7. 打家劫舍Ⅱ

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

**该题因为首尾元素算为相邻，因此，得分情况讨论**

1. 考虑首元素而不考虑尾部元素
2. 考虑尾部元素而不考虑首元素

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况一
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况二
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
};
```



# 8. 打家劫舍Ⅲ

[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

```c++
class Solution {
public:
    unordered_map <TreeNode*, int> f, g;

    void dfs(TreeNode* node) {
        if (!node) {
            return;
        }
        dfs(node->left);
        dfs(node->right);
        f[node] = node->val + g[node->left] + g[node->right];
        g[node] = max(f[node->left], g[node->left]) + max(f[node->right], g[node->right]);
    }

    int rob(TreeNode* root) {
        dfs(root);
        return max(f[root], g[root]);
    }
};

```

```c++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```



# 9.买卖股票的最佳时机

 [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**整个阶段只允许一次买卖**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        /*
            dp[i][j]: i表示第i天，j = 0 或 1，
            dp[i][0]表示第 i 天持有股票
            dp[i][1]表示第 i 天不持有股票
        */
        int n = prices.size();
        vector<vector<int>> dp(n,vector<int>(2,0));

        dp[0][0] -= prices[0];
        dp[0][1] = 0;

        for(int i = 1; i < n; i++)
        {
            dp[i][0] = max(dp[i-1][0],-prices[i]);
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i]);
        }
        //不持有股票的状态一定比持有状态现金多
        return dp[n-1][1];
    }
};
```

## 优化：

**dp[i]只依赖于dp[i-1]，因此可以使用滚动数组**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
```

## 二刷疑惑：

对于状态转移方程中，**第`i`天买入股票的情况：**

- 我的理解是在第`i-1`天不持有股票的情况下，减去第`i`天的股票价格

  - ```c++
    dp[i][1] = dp[i-1][0] - prices[i]
    ```

- 但是实际上应该是直接减去第`i`天的股票价格

  - ```c++
    dp[i][1] = -prices[i]
    ```

**经过思考，由于该题全程只允许一次买入，若使用第一种计算方式，就会存在多次买入的情况，因为第`i-1`天不持有股票的情况中包含了第`i-1`天卖出股票的情况**

# 10. 买卖股票的最佳时机Ⅱ

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

**尽可能完成更多的交易（多次买卖一支股票）**

- 在上一题中，因为只允许一次买卖，所以更新第i天的持有股票状态时，若要在第 i 天买入股票，此时手中现金肯定为0，因此

```c++
dp[i][0] = -prices[i];
```

- 而在该题中，因为允许多次买卖，更新第i天的持有股票状态时，在前 i -1天中可能已经买卖了一次股票，因此此时手中已经有了现金

```c++
// 注意这里是和 买卖股票的最佳时机 唯一不同的地方。
dp[i][0] = dp[i - 1][1] - prices[i];
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            // 注意这里是和 买卖股票的最佳时机 唯一不同的地方。
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); 
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```

## 优化：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
```



# 11. 买卖股票的最佳时机Ⅲ

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

**至多买卖两次，意味着可以买卖一次，也可以买卖两次**

一天一共就有五个状态， 

0. 没有操作

1. 第一次买入
2. 第一次卖出
3. 第二次买入
4. 第二次卖出

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 1) return 0;
        /*
            0 没有操作
            1 第一次买入
            2 第一次卖出
            3 第二次买入
            4 第二次卖出
        */
        vector<vector<int>> dp(n,vector<int>(5,0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for(int i = 1; i < n; i++)
        { 
            dp[i][0] = dp[i-1][0];
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i]);
            dp[i][2] = max(dp[i-1][2],dp[i-1][1] + prices[i]);
            dp[i][3] = max(dp[i-1][3],dp[i-1][2] - prices[i]);
            dp[i][4] = max(dp[i-1][4],dp[i-1][3] + prices[i]);
        } 
        return max(dp[n-1][2],dp[n-1][4]);

    }
};
```

## 优化：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<int> dp(5, 0);
        dp[1] = -prices[0];
        dp[3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
};
```



# 12. 买卖股票的最佳时机Ⅳ

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

**最多可以完成K笔交易**

参考上一题，每天对应的状态就有 2*k + 1 种，即

	0. 无状态
	0. 第一次买入
	0. 第一次卖出
	0. 第二次买入
	4. 第二次卖出
	0. .........
	0. 第 2k 次买入
	0. 第 2k  次卖出

**可以发现， 奇数时均为买入，偶数时均为卖出**

初始化dp数组时，第 0 天的奇数下标全初始化为 -prices[0]

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

# 13. 最佳买卖股票时机含冷冻期

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

## **分为4个状态**

- 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
- 卖出股票状态，这里就有两种卖出股票状态
  - 状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
  - 状态三：今天卖出了股票
- 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

## **状态一：买入股票状态：**

- 保持前一天买入股票状态

```c++
dp[i][0] = dp[i-1][0];
```

- 前一天处于状态二，则可在今天买入

```c++
dp[i][0] = dp[i-1][1] - prices[i];
```

- 前一天为冷冻期，则可在今天买入

```c++
dp[i][0] = dp[i-1][3] - prices[i];
```

**综上，取最大值**

```c++
dp[i][0] = max(dp[i-1][0]],max(dp[i-1][3]-prices[i],dp[i-1][1]-prices[i]));
```

## 状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态

- 保持前一天卖出状态

```c++
dp[i][1] = dp[i-1][1];
```

- 前一天是冷冻期

```c++
dp[i][1] = dp[i-1][3];
```

**综上，取最大值**

```c++
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
```

## 状态三：今天卖出了股票

- 昨天买入了股票

```c++
dp[i][2] = dp[i - 1][0] + prices[i];
```

## 状态四：今天为冷冻期状态

- 前一天卖出股票

```c++
dp[i][3] = dp[i-1][2];
```



**递推方程如下：**

```c++
//状态一：买入股票状态
dp[i][0] = max(dp[i-1][0]],max(dp[i-1][3]-prices[i],dp[i-1][1]-prices[i]));
//状态二：保持卖出股票状态
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
//状态三：今天卖出了股票
dp[i][2] = dp[i - 1][0] + prices[i];
//状态四：今天为冷冻期状态
dp[i][3] = dp[i - 1][2];
```



## 解法：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3],max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```



## 分为3个状态：

**`dp[i]:`第 i 天结束之后的累计最大收益**

- 状态一：第 i 天结束之后持有一支股票
  - 前一天就持有，`dp[i][0] = dp[i-1][0]`
  - 今天买入，则前一天不能处于冷冻期，`dp[i][0] = dp[i-1][2] - prices[i]`
  - `dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])`
- 目前不持有股票：
  - 状态二：第` i` 天结束之后处于冷冻期
    - 即在第` i `天卖出了股票，则第 `i - 1`天必须持有股票`dp[i][1] = dp[i-1][0] + prices[i]`
  - 状态三：第 i 天结束之后不处于冷冻期
    - 即第 `i - 1`天不持有股票
      - 第 `i - 1`天处于冷冻期，`dp[i][2] = dp[i-1][1]`
      - 第 `i - 1`天不处于冷冻期，`dp[i][2] = dp[i-1][2]`
      - `dp[i][2] = max(dp[i-1][1], dp[i-1][2])`
- **综上：`res = max(dp[n-1][0], dp[n-1][1], dp[n-1][2])`**

**代码：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }

        int n = prices.size();
        // f[i][0]: 手上持有股票的最大收益
        // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
        // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
        vector<vector<int>> dp(n, vector<int>(3));
        dp[0][0] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
            dp[i][1] = dp[i - 1][0] + prices[i];
            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]);
        }
        return max(dp[n - 1][1], f[n - 1][2]);
    }
};
```



****

# 14. 买卖股票得最佳时机含手续费

在[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)中多了一个减去手续费的操作

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```



# 15. 最长递增子序列

[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

- dp[j]: **以nums[j]为结尾**的最长递增子序列
  - 对于每个dp[j]遍历前 j - 1个数字, 0 < i < j
    - 若nums[j] > nums[i]  则表示 nums[i] 可加入dp[i]所代表的子序列，则 dp[j] = dp[i] + 1;
    - 否则，直接跳过

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result) result = dp[i]; // 取长的子序列
        }
        return result;
    }
};
```



# 16. 最长连续递增序列

[674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        vector<int> dp(nums.size(),1);
        int res = 1;
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] > nums[i-1]) dp[i] = dp[i-1] + 1;
            res = max(res,dp[i]);
        }
        return res;
    }
};
```



# 17. 最长重复子数组

[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

- ```c++
  dp[i][j]: 以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]
  ```

- 状态转移方程：

  - ```c++
    if(nums1[i] == nums2[j]) dp[i][j] = dp[i-1][j-1] + 1
    ```

    


```c++
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        vector<vector<int>> dp (A.size() + 1, vector<int>(B.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= A.size(); i++) {
            for (int j = 1; j <= B.size(); j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    }
};
```

**二刷时，我对动规数组的定义换成如下：**

- ```c++
  dp[i][j]: 以下标i 为结尾的A，和以下标j 为结尾的B，最长重复子数组长度为dp[i][j]
  ```

- 换成以上定义后，对动规数组就要进行提前处理

  - 首先对`dp[0][i]`进行处理，并实时记录最大结果

    - ```c++
      for(int  i = 1; i < n2; i++){
          if(nums1[0] == nums2[i]) dp[0][i] = 1;
          res = max(res, dp[0][i]);
      }
      ```

  - 然后对`dp[i][0]`进行处理，并实时记录最大结果

    - ```c++
      for(int  i = 1; i < n1; i++){
          if(nums2[0] == nums1[i]) dp[i][0] = 1;
          res = max(res, dp[i][0]);
      }
      ```

  - 状态转移方程与第一种方法一致，完整代码如下：

  - ```c++
    class Solution {
    public:
        int findLength(vector<int>& nums1, vector<int>& nums2) {
            int n1 = nums1.size();
            int n2 = nums2.size();
            int res = 0;
            vector<vector<int>> dp(n1, vector<int>(n2,0));
            if(nums1[0] == nums2[0]) dp[0][0] = 1;
            for(int  i = 1; i < n1; i++){
                if(nums2[0] == nums1[i]) dp[i][0] = 1;
                res = max(res, dp[i][0]);
            }
            for(int  i = 1; i < n2; i++){
                if(nums1[0] == nums2[i]) dp[0][i] = 1;
                res = max(res, dp[0][i]);
            }
    
            for(int i = 1; i < n1; i++){
                for(int j = 1; j < n2; j++){
                    if(nums1[i] == nums2[j]) dp[i][j] = dp[i-1][j-1] + 1;
                    res = max(res, dp[i][j]);
                }
            }
            return res;
        }
    };
    ```

    **难怪Carl哥说这样麻烦，确实麻烦**

# 18. 最长公共子序列

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

- ```c++
  dp[i][j]:以下标 i-1 为结尾的字符串中 与 以下标 j-1 结尾的字符串中的最长公共子序列长度
  ```

- ```c++
  状态转移：
  	若 A[i-1] == B[j-1] ,则 dp[i][j] = dp[i-1][j-1] + 1;
  		即等于以下标 i-2 为结尾的字符串中 与 以下标 j-2 结尾的字符串中的最长公共子序列长度加 1
  	否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
  ```

  

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```



# 19. 不相交的线

[1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)

**直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交，因此该题与[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)是一样的题**

```c++
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();
        int res = 0;
        vector<vector<int>> dp(n1 + 1,vector<int>(n2 + 1,0));

        for(int i = 1; i <= n1; i++)
        {
            for(int j = 1; j <= n2; j++)
            {
                if(nums1[i-1] == nums2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[n1][n2];
    }
};
```



# 20. 最大子序和

[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

![image-20211118223017342](C:\Users\Sakura\AppData\Roaming\Typora\typora-user-images\image-20211118223017342.png)

## 错解：

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        int res = nums[0];
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] + dp[i-1] < 0) dp[i] = nums[i];
            else
                dp[i] = max(dp[i-1] + nums[i],dp[i]);

            res = max(res,dp[i]);
        }
        return res;
    }
};
```

## 正解：

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        int res = nums[0];
        for(int i = 1; i < nums.size(); i++)
        {
            dp[i] = max(dp[i-1] + nums[i],nums[i]);
            if (dp[i] > res) res = dp[i];
        }
        return res;
    }
};
```



# 21. 判断子序列

[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

```c++
dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]
```

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = dp[i][j - 1];
            }
        }
        if (dp[s.size()][t.size()] == s.size()) return true;
        return false;
    }
};
```



# 22. 不同的子序列

[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

- ```c++
  dp[i][j]:以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。
  ```

- 这一类问题，基本是要分析两种情况

  - s[i - 1] 与 t[j - 1]相等
  - s[i - 1] 与 t[j - 1] 不相等

```c++
当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。

一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。

一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。
例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。

当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。
    
所以当s[i - 1] 与 t[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];

当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1][j]

所以递推公式为：dp[i][j] = dp[i - 1][j];
```

**该题还要注意整型溢出的问题，使用长整型**

```c++
  vector<vector<uint64_t>> dp(ns + 1,vector<uint64_t>(nt + 1,0));
```





```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        int ns = s.size();
        int nt = t.size();
        vector<vector<uint64_t>> dp(ns + 1,vector<uint64_t>(nt + 1,0));
        for(int i = 0; i <= ns; i++) dp[i][0] = 1;
        for(int i = 1; i <= nt; i++) dp[0][i] = 0;

        for(int i = 1; i <= ns; i++){
            for(int j = 1; j <= nt; j++){
                if(s[i-1] == t[j-1])
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[ns][nt];
    }
};
```



# 23. 两个字符串的删除操作

[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

1. ```c++
   dp[i][j]:以i-1为结尾的s子序列变成以j-1为结尾的t的所需删除的最少次数为dp[i][j]。
   ```

2. 转移方程：

   - ```c++
     若 word1[i-1] = word2[j-1]
     	dp[i][j] = dp[i-1][j-1]
     否则
     	分为三种情况：
         情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1
     
     	情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1
     
     	情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2
     ```

3. 初始化DP 数组

   - ```c++
     dp[i][0] = i 即删除全部字符以匹配空格
     dp[0][j] = j 即删除全部字符以匹配空格
     ```

**解法：**

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};

```



# 24. 编辑距离

[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

参考[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)，定义dp数组，但要注意的是，该题只能对二者之一进行操作。

```c++
dp[i][j]:以i-1为结尾的s子序列变成以j-1为结尾的t的所需删除的最少次数为dp[i][j]。
```

状态转移方程：

- ```c++
  若 word1[i-1] = word2[j-1]
  	dp[i][j] = dp[i-1][j-1]
  否则
  	分为三种情况：
      情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1
  
  	情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1，word2添加一个元素，相当于word1删除一个元素
  
  	情况三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。
      dp[i][j] = dp[i - 1][j - 1] + 1
  ```



```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size();
        int n2 = word2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
        for(int i = 0; i <= n1; i++) dp[i][0] = i;
        for(int i = 0; i <= n2; i++) dp[0][i] = i;
        for(int i = 1; i <= n1; i++){
            for(int j = 1; j <= n2; j++){
                if(word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = min(dp[i-1][j] + 1,min(dp[i][j-1] + 1, dp[i-1][j-1] + 1));
            }
        }
        return dp[n1][n2];
    }
};
```



# 25. 回文子串

[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size();
        int res = 0;
        //dp[i][j]:s[i~j]所构成的子字符串是否为回文串
        vector<vector<bool>> dp(n,vector<bool>(n,false));
        /*
            s[i] == s[j]
                i == j : dp[i][j] = true;
                i - j == 1 : dp[i][j] = true;
                else dp[i][j] = dp[i+1][j-1]
            s[i] != s[j]
                dp[i][j] = false;
        */
        for(int i = n - 1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j]){
                    if(j - i <= 1 ){
                        res++;
                        dp[i][j] = true;
                    }
                    else if(dp[i+1][j-1]){
                        res++;
                        dp[i][j] = true;
                    }
                        
                }
            }
        }
        return res;
    }
};
```



# 26. 最长回文子序列

[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

`dp[i][j]`:s[i~j]子字符串中的最长回文子序列

- 初始化：`dp[i][i] = 1`

- 状态转移(分两种情况讨论)：

  - ```c++
    s[i] == s[j]
    	j - i == 1 : dp[i][j] = 2
    	else dp[i][j] = dp[i+1][j-1] + 2;
    s[i] != s[j]
    	dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
    ```

    

  

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        int res = 0;
        //dp[i][j]:s[i~j]子字符串中的最长回文子序列
        vector<vector<int>> dp(n,vector<int>(n,0));
        /*
            初始化：dp[i][i] = 1;
            s[i] == s[j]
                j - i == 1 : dp[i][j] = 2
                else dp[i][j] = dp[i+1][j-1] + 2;
            s[i] != s[j]
                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
        */
        for(int i = 0; i < n; i++) dp[i][i] = 1;

        for(int i = n - 1; i >= 0; i--){
            for(int j = i + 1; j < n; j++){
                if(s[i] == s[j]){
                    if(j - i == 1) dp[i][j] = 2;
                    else dp[i][j] = dp[i+1][j-1] + 2;
                }else{
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
};
```

# 27. 最长回文子串

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

- ```c++
  dp[i][j]：以s[i]为起始，s[j]为末尾的回文子串的长度，若不是回文串，则dp[i][j] = 0;
  ```

- 状态转移方程：

  - 主要考虑s[i]与s[j]是否相等

  - 若不相等，则

    ```c++
    dp[i][j] = 0;
    ```

  - 若相等，则要分为三种情况

    - i == j，表示一个字符，当然是回文，则 dp = 1;

    - i - j == 1,表示两个相同字符，例如 aa , bb ，则dp = 2;

    - 当 i - j > 1时，则要考虑

      ```c++
      dp[i+1][j-1] 是否是回文，如果是，则dp[i][j] = dp[i+1][j-1] + 2
      ```

## 解法：

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2) return s;
        string res = "";
        vector<vector<int>> dp(n,vector<int>(n,0));

        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j])
                {
                    if(i == j) dp[i][j] = 1;
                    else if(j - i == 1){
                        dp[i][j] = 2;
                    }
                    else if(dp[i + 1][j - 1]){
                        dp[i][j] = dp[i+1][j-1] + 2;
                    }
                }
                else{
                    dp[i][j] = 0;
                }

                if(dp[i][j] &&( res.size() < j - i + 1)){
                    res.clear();
                    res = s.substr(i,j - i + 1);
                }
            }
        }
        return res;
    }
};
```

## 二刷记忆：

**注意遍历顺序，首层循环必须从后往前遍历，即`for(int i = n-1; i >= 0; i--)`,因为在状态转移过程中，`dp[i][j]会利用到dp[i+1][j-1]`，所以必须先遍历`dp[i+1]`,然后遍历`dp[i]`**

# 28. 分割回文串

[131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

**该题可以利用回溯暴力解决，在回溯过程中，每次递归都需要判断当前串是否是回文串，对这一步骤我们可以利用动规数组进行记忆化**

- 预处理字符串
- `dp[i][j]:`给定字符串中，`s[i]~s[j]`的子串是否为回文串
- 具体实现与[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)相同

```c++
class Solution {
public:
    vector<vector<bool>> dp;
    vector<vector<string>> res;
    vector<string> path;

    void backTracking(string s, int startIndex,vector<vector<bool>> dp)
    {
        if(startIndex >= s.size()){
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i < s.size(); i++)
        {
            if(dp[startIndex][i]){
                string cur = s.substr(startIndex,i-startIndex+1);
                path.push_back(cur);
                backTracking(s,i+1,dp);
                path.pop_back();
            }
        }
    }
    vector<vector<string>> partition(string s) {
        int n = s.size();
        dp.assign(n, vector<bool>(n, false));
        dp[0][0] = true;
        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j]){
                    if( j - i <= 1) dp[i][j] = true;
                    else{
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
            }
        }
        
        backTracking(s,0,dp);
        return res;
    }
};
```

# 29. 分割回文串 II

[132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii)

`dp[i]:`给定字符串中前`0~i`个字符组成的子字符串分割成回文子串的最小分割数

- 对于`dp[i]`,寻找一个最小的`dp[j]`，其中`0 <= j < i`,则`dp[i] = dp[j] + 1`
  - `s[j+1,...,i]`为回文串
- `s[0~i]`可能本身就是一个回文串，此时`dp[i] = 0`
- 借助[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)，记录下任意子字符串是否为回文串

```c++
class Solution {
public:
    int minCut(string s) {
        int n = s.size();
        vector<vector<bool>> dp(n,vector<bool>(n,false));
        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j]){
                    if( j - i <= 1) dp[i][j] = true;
                    else{
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
            }
        }

        vector<int> f(n,INT_MAX);
        for(int i = 0; i < n; i++){
            //如果本身是回文串
            if(dp[0][i]){
                f[i] = 0;
            }else{
                //如果本身不是回文串，则去寻找最小f[j]
                for(int j = 0; j < i; j++)
                    if(dp[j + 1][i])
                        f[i] = min(f[i], f[j] + 1);
            }
        }
        return f[n-1];
    }
};
```



# 30. 分割回文串 III

[1278. 分割回文串 III](https://leetcode.cn/problems/palindrome-partitioning-iii)

`dp[i][j]:`对于字符串 `S` 的前 `i` 个字符，将它分割成 `j` 个非空且不相交的回文串，最少需要修改的字符数

**状态转移：**

- 枚举第 `j` 个回文串的起始位置`i0`
- `dp[i][j] = dp[i0][j-1] + cost[i0+1][i]`
- ` cost[i][j]`:将s[i~j]变为回文串所需的修改次数

**特别注意：**

- 将前`i`个字符分为`j`个回文串，当且仅当`i >= j`时才有效，至少得保证字符串有`j`个字符，才能生成`j`个回文串，因此循环中`j <= min(k,i)`
- 第`j`个字符串的起始位置至少为`j-1`
  - `j-1`个字符串最小长度为`s[0~j-2]`共`j-1`个字符，因此第`j`个字符串的起始位置应从`s[j-1]`开始枚举

```c++
class Solution {
public:
    int palindromePartition(string& s, int k) {
        int n = s.size();
        //将s[i~j]变为回文串所需的修改次数
        vector<vector<int>> cost(n, vector<int>(n,0));
        for(int i = n - 1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j])
                    if(j - i <= 1) cost[i][j] = 0;
                    else cost[i][j] = cost[i+1][j-1];
                else
                    cost[i][j] = cost[i+1][j-1] + 1;
            }
        }

        vector<vector<int>> f(n + 1, vector<int>(k + 1, INT_MAX));
        f[0][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= min(k, i); ++j) {
                if (j == 1) {
                    f[i][j] = cost[0][i - 1];
                }
                else {
                    for (int i0 = j - 1; i0 < i; ++i0) {
                        f[i][j] = min(f[i][j], f[i0][j - 1] + cost[i0][i - 1]);
                    }
                }
            }
        }
        
        return f[n][k];
    }
};
```

# 31. 回文串分割 IV

[1745. 回文串分割 IV](https://leetcode.cn/problems/palindrome-partitioning-iv)

法一：将[1278. 分割回文串 III](https://leetcode.cn/problems/palindrome-partitioning-iii)中的`k`固定为3

**法二：**

预处理：求出`s`中任意区间范围内子字符串是否为回文串

然后枚举两个分界点，判断3个字符串是否均为回文串

```c++
class Solution {
public:
    bool checkPartitioning(string s) {
        int n = s.size();
        vector<vector<bool>> dp(n,vector<bool>(n,false));
        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j]){
                    if( j - i <= 1) dp[i][j] = true;
                    else{
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
            }
        }
        for(int s = 0; s <= n - 2; s++)
            for(int e = s + 1; e <= n - 2; e++)
                if(dp[0][s]&&dp[s+1][e]&&dp[e+1][n-1])
                    return true;
        return false;
    }
};
```





# 32.正则表达式匹配

[10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

[剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

## 自己的解法（错误）：

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int n1 = s.size();
        int n2 = p.size();
        //dp[i][j] 字符串s前 i 个字符(下标为i-1) 能否与 字符串p前j个字符（下标为J-1）匹配
        /*
            若s[i-1] == p[j-1] dp[i][j] = dp[i-1][j-1];
            否则
                if(p[j-1] == '.') dp[i][j] = true;
                if(p[j-1] == '*')
                {
                    if(s[i-1] != p[j-2]) dp[i][j] = dp[i][j-2];
                    else
                        dp[i][j] = dp[i-1][j]
                }
        */ 
        vector<vector<bool>> dp(n1+1,vector<bool>(n2+1,false));
        dp[0][0] = true;
        for(int i = 1; i <= n1; i++) dp[i][0] = false;
        for(int i = 1; i <= n1; i++){
            for(int j = 1; j <= n2; j++)
            {
                if(s[i-1] == p[j-1])    dp[i][j] = dp[i-1][j-1];
                else{
                    if(p[j-1] == '.') dp[i][j] = true;
                    if(p[j-1] == '*')
                    {
                        if(s[i-1] != p[j-2]) dp[i][j] = dp[i][j-2];
                        else
                        dp[i][j] = dp[i-1][j];
                    }
                }
            }
        }
        return dp[n1][n2];
    }
};
```

**分析：**

对于空串和非空正则的情况考虑不充分，比如s =  '' '' , p = a∗b∗c∗

## 正解：

- 如果 p 的第j个字符是一个小写字母，那么

  ```c++
  if(s[i] == p[j]) dp[i][j] = dp[i-1][j-1];
  else
      dp[i][j] = false;
  ```

- 如果 p 的第j个字符是 * ，即`p[j-1] == '*'`

  - 不考虑*号，及令星号匹配0个第j-1个字符（删除星号以及p[j-2]）
  - 考虑星号，让字符p[j-2]多出现一次，能否匹配

  ```c++
  //不考虑
  	dp[i][j] = dp[i][j-2]
  //考虑
      dp[i][j] = dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')
  ```

- 如果 p 的第j个字符是  .  即`p[j-1] == '.'`，那么p[j-1]可以匹配任意小写字符

  ```c++
  dp[i][j] = dp[i-1][j-1]
  ```

**综上：**

```c++
当p[j - 1] == '*'时
    dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))
    
当p[j - 1] != '*'时
    if(s[i-1] == p[j-1] || p[j-1] == '.')
        dp[i][j] = dp[i-1][j-1];
	else
        dp[i][j] = false;
```

**初始化：**

```c++
dp[0][0] = true： 代表两个空字符串能够匹配。
dp[0][j] = dp[0][j - 2] 且 p[j - 1] = '*'： 首行 s 为空字符串，因此当 p 的偶数位为 * 时才能够匹配（即让 p 的奇数位出现 0 次，保持 p 是空字符串）。因此，循环遍历字符串 p ，步长为 2（即只看偶数位）。
```

## 代码：

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size() + 1, n = p.size() + 1;
        vector<vector<bool>> dp(m, vector<bool>(n, false));
        dp[0][0] = true;
        for(int j = 2; j < n; j += 2)
            dp[0][j] = dp[0][j - 2] && p[j - 1] == '*';
        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j++) {
                if(p[j-1] == '*')
                    dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'));
                else{
                    if(s[i-1] == p[j-1] || p[j-1] == '.')
                        dp[i][j] = dp[i-1][j-1];
                    else
                        dp[i][j] = false;
                }
            }
        }
        return dp[m - 1][n - 1];
    }
};

```

## 二刷疑惑：

让字符 `p[j - 1]` 多出现一次时，为什么是转移方程是`dp[i][j] = dp[i-1][j] && s[i-1] == p[j-2]`

手动写出DP数组后发现，若`dp[i-1][j] == true`,此时在s串末尾再加上一个s[i-1]，由于s[i-1] == p[j-2]，让p[j - 1]多出现一次即可匹配上

## 手写推导过程：

![QQ图片20211203191357](F:\A3-git_repos\数据结构与算法_notes\图片\QQ图片20211203191357.jpg)



# 33. 最长有效括号

[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

- `dp[i]:以s[i]为结尾的字符串中的最长有效子字符串的长度`

- 状态转移：

  - `s[i] == '('`

    - 此时无法与之前元素组成括号对，因此`dp[i] = 0;`

  - `s[i] == ')'`

    - 若`s[i-1] == '('`

      - 此时`s[i]与s[i-1]`组成一对有效括号，故`dp[i] = dp[i-2]+2`

    - 若`s[i-1] == ')'`

      - 若前面有和`s[i]`组成括号对的字符，即形如`((...))`,则`s[i-1]`必为有效括号对，以`s[i-1]`为结尾的有效括号对长度为`dp[i-1]`，该括号对的首括号下标为`i - 1 - dp[i-1] + 1 = i - dp[i-1]`，则与`s[i]`配对的括号下标为`i - dp[i-1] - 1`，即当`s[i - dp[i-1] - 1] == '('`时,

        `dp[i] = dp[i-1] + 2`

      - **但要注意的是，括号对形式可能为`(..)((..))`，即`s[i - dp[i-1] - 1]`之前可能还存在有效的括号对**，因此

        `dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`



```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        if(n == 0) return 0;
        vector<int> dp(n+1,0);
        int res = 0;
        for(int i = 1; i < n; i++)
        {
            if(s[i] == '(') dp[i] = 0;
            if(s[i] == ')')
            {
                if(s[i-1] == '('){
                    dp[i] = 2;
                    if(i >= 2) dp[i] += dp[i-2];
                }
                else if(s[i - 1] == ')')
                {
                    if(dp[i-1] > 0 && i - dp[i-1] - 1 >= 0 && s[i - dp[i-1] - 1] == '(')
                    {
                        dp[i] = dp[i-1] + 2;
                        if(i - dp[i-1] - 1 > 0)
                            dp[i] += dp[i - dp[i-1] -2];
                    }
                } 
            }
            res = max(res,dp[i]);
        }
        return res;
    }
};
```



# 34. 最大正方形

[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

**动态规划**

- `动规数组定义：`以`matrix[i][j]`为正方形右下角可以构成的最大正方形的边长
- 状态转移:
  - `dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1`

**一下是自己第一次写的代码，将数组初始化时候忘记统计此时的最大边长数**

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        int res = 0;
        for(int i = 0; i < m ; i++) dp[i][0] = matrix[i][0] == '1' ? 1 : 0;
        for(int j = 0; j < n ; j++) dp[0][j] = matrix[0][j] == '1' ? 1 : 0;

        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                if(matrix[i][j] == '0') dp[i][j] = 0;
                else
                    dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;
                
                res = max(res,dp[i][j]);
            }
        }
        return res * res;
    }
};
```

**正确代码：**

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        int res = 0;

        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(matrix[i][j] == '1'){
                    if(i == 0 || j == 0) dp[i][j] = 1;
                    else
                        dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;
                }   
                
                res = max(res,dp[i][j]);
            }
        }
        return res * res;
    }
};
```



# 35. 统计全为1的正方形子矩阵

**与上一题类型相似**

```c++
class Solution {
public:
    int countSquares(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        int res = 0;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(i == 0 || j == 0) dp[i][j] = matrix[i][j];
                else if(matrix[i][j] == 0) dp[i][j] = 0;
                else
                    dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;

                res += dp[i][j];
            }
        }
        return res;
    }
};
```

# 36. 不同的二叉搜索树

[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

- `G(n)`:长度为`n`的序列能构成的不同二叉搜索树的个数

- `F(i,n)`:长度为`n`的序列，以`i`为根节点时能构成的不同二叉搜索树的个数，`1 <= i <= n`

- 对于给定序列`1 ~ n`,可以构成的不同二叉搜索树的个数就是累加 **以各个值为根节点时可以构成的二叉搜索树的个数**

  - 即`G(n) = F(1,n) + F(2,n) + ... + F(n,n)`
  - `F(1,n)`为长度为`n`的序列，以`1`为根节点时能构成的不同二叉搜索树的个数
    - 以 1 为根节点时，其左子树为空，右子树节点数为`n-1`
    - 因此其右子树共有`G(n-1)`种排列方法
    - 即`F(1,n) = 1 *　G(n-1)`
  - `F(2,n)`为长度为`n`的序列，以`2`为根节点时能构成的不同二叉搜索树的个数
    - 以 2 为根节点时，其左子树只有一个节点`1`，右子树节点数为`n-2`
    - 因此其左子树共有`G(1)`种排列方法，右子树共有`G(n-2)`种排列方法
    - 即`F(2,n) = G(1) *　G(n-2)`
  - `F(i,n)`为长度为`n`的序列，以`i`为根节点时能构成的不同二叉搜索树的个数
    - 以 i 为根节点时，其左子树有`i-1`个节点，右子树节点数为`n-i`
    - 因此其左子树共有`G(i-1)`种排列方法， 右子树共有`G(n-i)`种排列方法
    - 即`F(2,n) = G(1) *　G(n-2)`
  - 综上:`F(i,n) = G(i-1) * G(n-i)`
  - 因此：`G(n) = G(0) * G(n-1) + G(1) * G(n-2) + .. + G(n-1) * G(0)`

  **递推公式如上，代码也就是手到擒来的事情了**

  ```c++
  class Solution {
  public:
      int numTrees(int n) {
          vector<int> G(n + 1, 0);
          G[0] = 1;
          G[1] = 1;
          for (int i = 2; i <= n; ++i) {
              for (int j = 1; j <= i; ++j) {
                  G[i] += G[j - 1] * G[i - j];
              }
          }
          return G[n];
      }
  };
  ```


# 37. 统计打字方案数

[6058. 统计打字方案数](https://leetcode.cn/problems/count-number-of-texts/)

解题思路
提示一
当字符为7或9时，可以变化的字母为4个。

提示二
`dp[i]`定义：以`pressKey[i-1]`结尾的方案个数
初始化：

`dp[0] = 1`(解释：如果只有一个字符时，仅有一种方案，以“2”为例子：只能为“a”)

**动规方程，分类讨论：**

- 当`chs[i]`与`chs[i-1]`不同时，`dp[i] = dp[i-1]`;
- 当`chs[i]`与`chs[i-1]`相同时，`dp[i] = dp[i-1] + dp[i-2]`;
- 当`chs[i]`与`chs[i-1]`、`chs[i-2]`都相同时，`dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`；
- 当`chs[i]`为`7`或`9`，且与`chs[i-1]、chs[i-2]、chs[i-3]`都相同时，`dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]`。
- 当上面的`dp[i-2]、dp[i-3]、dp[i-4]`无意义(i的值大小不满足时）时，应将相加的值更改为1，即

```c++
dp[i] = dp[i-1] + 1;
dp[i] = dp[i-1] + dp[i-2] + 1;
dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + 1;
```

```c++
class Solution {
public:
    int countTexts(string pressedKeys) {
        int mod = (int) 1e9 + 7;
        // 分两种情况，当前i与i-1的字符相同，不相同
        // 不相同：dp[i] += dp[i - 1]
        // 相同：与i-1相同 dp[i] += dp[i-1] + dp[i-2]
        // 与i-2也相同：dp[i] += dp[i-3]
        int n = pressedKeys.size();
        // dp[i]表示以pressKey[i-1]结尾的方案个数
        vector<long> dp(n,0);
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = dp[i - 1];
            if (pressedKeys[i] == pressedKeys[i - 1]) {
                dp[i] += i >= 2 ? dp[i - 2] : 1;
                if (i >= 2 && pressedKeys[i] == pressedKeys[i - 2]) {
                    dp[i] += i >= 3 ? dp[i - 3] : 1;
                    if ((pressedKeys[i] == '7' || pressedKeys[i] == '9') && i >= 3 && pressedKeys[i] == pressedKeys[i - 3]) {
                        dp[i] += i >= 4 ? dp[i - 4] : 1;
                    }
                }
            }
            dp[i] %= mod;
        }
        return (int) dp[n - 1];
    }
};
```



# 38. 检查是否有合法括号字符串路径

[2267. 检查是否有合法括号字符串路径](https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/)

```c++
class Solution {
public:
    bool hasValidPath(vector<vector<char>>& grid) {
        /*
        前置知识:括号匹配问题可以在遍历过程维护一个变量k:当遇到'(',k++;当遇到')',k--
        只要遍历过程中k始终>=0且最后k=0说明括号可以匹配
        dp五部曲:
        1.状态定义:dp[i][j][k]表示格子grid[i][j]是否存在括号状态为k的情形,有则为true
        2.状态转移:由于只能向右走或者向下走,因此只有两种转移途径
            2.1 从上边转移:dp[i][j][k] = dp[i-1][j][k-c]
            2.2 从左边转移:dp[i][j][k] = dp[i][j-1][k-c]
            其中c为grid[i][j]的括号状态:c=grid[i][j]=='('?1:-1
        3.初始化:初始化dp[0][0][1]=true,因为grid[0][0]必须为左括号
        4.遍历顺序:i与j正均为序遍历,而k也是正序遍历(都可)
        5.返回形式:只需要返回dp[m-1][n-1][0]即可
         */
        if (grid[0][0] == ')') return false;
        int m = grid.size(), n = grid[0].size();
        // k的范围为有限值,为[0,pathLen],其中pathLen=m+n-1,pathLen始终为非负值
        int pathLen = m + n + 1;
        vector<vector<vector<bool>>> dp(m,vector<vector<bool>>(n,vector<bool>(pathLen+1,false)));
        // 初始化
        dp[0][0][1] = true;
        // i∈[0,m-1]
        for (int i = 0; i < m; i++) {
            // j∈[0,j-1]
            for (int j = 0; j < n; j++) {
                // 排除一下[0,0]
                if (i != 0 || j != 0) {
                    // 当前括号对于k的增益
                    int c = grid[i][j] == '(' ? 1 : -1;
                    // k∈[0,pathLen]
                    for (int k = 0; k <= pathLen; k++) {
                        // 保证索引k-c索引合法
                        if (k - c < 0 || k - c > pathLen) continue;
                        // 保证i与j索引合法->只要有其中一条转移路径成立即可,因此用|=
                        if(i >= 1) dp[i][j][k] = dp[i][j][k] | dp[i - 1][j][k - c];
                        if(j >= 1) dp[i][j][k] = dp[i][j][k] | dp[i][j - 1][k - c];
                    }
                }
            }
        }
        // 返回grid[m-1][n-1]括号恰好匹配的状态
        return dp[m - 1][n - 1][0];
    }
};
```

# 39. 最长的斐波那契子序列的长度

[873. 最长的斐波那契子序列的长度](https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/)

`dp[i][j]`:在给定数组`A[]`中，以`A[i],A[j]`为结尾两元素的斐波拉契数列的最大长度

- 即在`A[0]...A[i]..A[j]..`中，斐波拉契数列形式为`....A[i],A[j]`

**状态转移方程：**

- 考虑`A[i]`之前的数字中是否存在一个数`A[k]`，使得`A[k] + A[i] = A[j]`
- 即`dp[i][j] = dp[k][i] + 1 ，其中A[k]满足 A[k] + A[i] = A[j]`

**初始化：**

- 任意两个元素都是有效的斐波拉契数列，因此初始化`dp[i][j] = 2`，其中`i~(0,n), j~(i,n)`

**代码编写：**

- 由于给定数组是一个严格递增的序列，因此我们不需要从头到尾去遍历寻找`A[k]`,我们可以利用一个哈希表来快速寻找

```c++
class Solution {
public:
    int lenLongestFibSubseq(vector<int>& arr) {
        int res = 0;
        int n = arr.size();
        unordered_map<int,int> hash;
        //建立映射
        for(int i = 0; i < arr.size(); i++) hash[arr[i]] = i;
        vector<vector<int>> dp(n,vector<int>(n,0));
        //初始化
        for(int i = 0; i < n; i++){
            for(int j = i+1; j < n; j++)
                dp[i][j] = 2;
        }
        dp[0][0] = 1;
        for(int i = 1; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(hash.find(arr[j] - arr[i]) != hash.end()){
                    int k = hash[arr[j] - arr[i]];
                    if(k < i)
                    	dp[i][j] = max(dp[i][j], dp[k][i] + 1);
                    res = max(res, dp[i][j]);
                }
            }
        }
        //题目要求斐波拉契数列长度必须大于等于3
        return res > 2 ? res : 0;
    }
};
```

