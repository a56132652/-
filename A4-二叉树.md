# 1. 二叉树定义

**牢记，以防手撕代码**

```c++
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x): val(x), left(nullptr), right(nullptr){}
};
```



# 2. 二叉树的迭代遍历

## 1) 前序遍历

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> sta;
        if(root != nullptr) sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            result.push_back(node->val);
            if(node->right) sta.push(node->right);
            if(node->left) sta.push(node->left);
        }
        return result;
    }
};
```

## 2) 中序遍历

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> sta;
        vector<int> res;
        if(!root) return res;
        TreeNode* cur = root;
        while(!sta.empty() || cur != nullptr)
        {
            if(cur != nullptr)
            {
                sta.push(cur);
                cur = cur->left; 
            }else{
                TreeNode* temp = sta.top();
                sta.pop();
                res.push_back(temp->val);
                cur = temp->right;
            }
        }
        return res;
    }
};
```

## 3) 后序遍历

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
      vector<int> result;
        stack<TreeNode*> sta;
        if(root != nullptr) sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            result.push_back(node->val);
            if(node->left) sta.push(node->left);
            if(node->right) sta.push(node->right);
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
```

## 4) 统一迭代法

- 中序遍历

  - ```c++
    class Solution {
    public:
        vector<int> inorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            if (root != NULL) st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();
                if (node != NULL) {
                    st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                    if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）
    
                    st.push(node);                          // 添加中节点
                    st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。
    
                    if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
                } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                    st.pop();           // 将空节点弹出
                    node = st.top();    // 重新取出栈中元素
                    st.pop();
                    result.push_back(node->val); // 加入到结果集
                }
            }
            return result;
        }
    };
    ```

- 前序遍历

  - ```c++
    class Solution {
    public:
        vector<int> preorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            if (root != NULL) st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();
                if (node != NULL) {
                    st.pop();
                    if (node->right) st.push(node->right);  // 右
                    if (node->left) st.push(node->left);    // 左
                    st.push(node);                          // 中
                    st.push(NULL);
                } else {
                    st.pop();
                    node = st.top();
                    st.pop();
                    result.push_back(node->val);
                }
            }
            return result;
        }
    };
    ```

- 后序遍历

  - ```c++
    class Solution {
    public:
        vector<int> postorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            if (root != NULL) st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();
                if (node != NULL) {
                    st.pop();
                    st.push(node);                          // 中
                    st.push(NULL);
    
                    if (node->right) st.push(node->right);  // 右
                    if (node->left) st.push(node->left);    // 左
    
                } else {
                    st.pop();
                    node = st.top();
                    st.pop();
                    result.push_back(node->val);
                }
            }
            return result;
        }
    };
    ```

    

# 3. 二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

## 1) 二叉树的层序遍历Ⅱ

[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```c++
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            vector<int> level;
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                level.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
            }
            res.push_back(level);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

## 2) 二叉树的右视图

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            while(size != 1){
                TreeNode* cur = q.front();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
                size--;
            }
            res.push_back(q.front()->val);
            if(q.front()->left) q.push(q.front()->left);
            if(q.front()->right) q.push(q.front()->right);
            q.pop();
        }
        return res;
    }
};
/*------------------------------小小的简化一下----------------------------------------*/
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
			for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                q.pop();
                if(i == size - 1){
                    res.push_back(cur->val);
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return res;
    }
};
```

## 3) 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            double sum = 0;
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                sum += cur->val;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
            }
            double average = sum / size;
            res.push_back(average);
        }
        return res;
    }
};
```



## 4) N叉树的层序遍历

[429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val; 
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        queue<Node*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            vector<int> vec;
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                vec.push_back(cur->val);
                for(auto node : cur->children){
                    q.push(node);
                }
                q.pop();
            }
            res.push_back(vec);
        }
        return res;
    }
};
```



## 5) 在每个数行中找最大值

[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            int max = INT_MIN;
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                if(max < cur->val)
                    max = cur->val;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
            }
            res.push_back(max);
        }
        return res;
    }
};
```



## 6) 填充每个节点的下一个右侧节点指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

**可以直接利用层序遍历，一层一层的处理，代码如下：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                if(i == size - 1){
                    cur->next = NULL;
                    q.pop();
                }
                else{
                    q.pop();
                    Node* next = q.front();
                    cur->next = next;
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
```

**另外一种方式**

- **给定树为完全二叉树**

- 利用父节点直接连接左右子节点，即`node.left->next = node.right`
- 当要连接的两节点属于不同父节点时，可用`node.right->next = node.next->left`
- 每次遍历都要从最左节点开始，**当前层的最左节点一定是上一层最左节点的孩子节点**

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if (root == nullptr) {
            return root;
        }
        
        // 从根节点开始
        Node* leftmost = root;
        
        while (leftmost->left != nullptr) {
            
            // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针
            Node* head = leftmost;
            
            while (head != nullptr) {
                
                // CONNECTION 1
                head->left->next = head->right;
                
                // CONNECTION 2
                if (head->next != nullptr) {
                    head->right->next = head->next->left;
                }
                
                // 指针向后移动
                head = head->next;
            }
            
            // 去下一层的最左的节点
            leftmost = leftmost->left;
        }
        
        return root;
    }
};
```



## 7) 填充每个节点的下一个右侧节点指针Ⅱ

[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
 Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                if(i == size - 1){
                    cur->next = NULL;
                    q.pop();
                }
                else{
                    q.pop();
                    Node* next = q.front();
                    cur->next = next;
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
```

**和上一题没区别呀，提交上一题的代码一样过**

**法二：**

```c++
class Solution {
public:
    void handle(Node* &last, Node* &p, Node* &nextStart) {
        if (last) {
            last->next = p;
        } 
        if (!nextStart) {
            nextStart = p;
        }
        last = p;
    }

    Node* connect(Node* root) {
        if (!root) {
            return nullptr;
        }
        Node *start = root;
        while (start) {
            Node *last = nullptr, *nextStart = nullptr;
            for (Node *p = start; p != nullptr; p = p->next) {
                if (p->left) {
                    handle(last, p->left, nextStart);
                }
                if (p->right) {
                    handle(last, p->right, nextStart);
                }
            }
            start = nextStart;
        }
        return root;
    }
};
```



## 8) 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```c++
/*太久没写递归了，重温一下递归*/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left)+1,maxDepth(root->right)+1);
    }
};
```



```c++
/*层序遍历*/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
                if(i == size - 1)
                    res++;
            }
        }  
        return res;
    }
};
```

## 9) 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        if(!root->left) return minDepth(root->right) + 1;
        if(!root->right) return minDepth(root->left) + 1;
        else return min(minDepth(root->left)+1,minDepth(root->right)+1);
    }
};
```



```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录最小深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
                if (!node->left && !node->right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出
                    return depth;
                }
            }
        }
        return depth;
    }
};
```



# 4. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

## 递归

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;
        TreeNode* left = root->left;
        root->left = root->right;
        root->right = left;
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

## 迭代

```c++
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```



# 5. 对称二叉树

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

## 递归

```c++
class Solution {
public:
    bool isMirror(TreeNode* root1, TreeNode* root2)
    {
        if(!root1 && !root2) return true;
        if(!root1 && root2) return false;
        if(root1 && !root2) return false;
        if(root1->val == root2->val) return isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);
        return false;
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isMirror(root->left,root->right);
    }
};
```

## 迭代

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        while (!que.empty()) {  // 接下来就要判断这这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

**自己写的**

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root->left);
        q.push(root->right);
        while(!q.empty()){
            TreeNode* left = q.front(); q.pop();
            TreeNode* right = q.front(); q.pop();

            if((!left && right) || (!right && left)) return false;
            else if(!left && !right) continue;
            else if(left->val != right->val) return false;
            else{
                    q.push(left->left);
                    q.push(right->right);
                    q.push(left->right);
                    q.push(right->left);
                }
        }
        return true;
    }
};
```

# 6. 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

# 7. n叉树的最大深度

[559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

**层序遍历：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int maxDepth(Node* root) {
        if(!root) return 0;
        int res = 0;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                q.pop();
                for(auto child : cur->children) q.push(child);
            }
            res++;
        }
        return res;
    }
};
```

**递归：**

```c++
class Solution {
public:
    int maxDepth(Node* root) {
        if(!root) return 0;
        int res = 0;
        for(auto child : root->children){
            res = max(res, maxDepth(child));
        }
        return res + 1;
    }
};
```



# 8.二叉树的最小深度

[8.二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

**对我个人而言，该题要注意的就是： 深度为根节点到叶子节点的路径上的节点数，一定要到叶子节点，当根节点左子树为空时，就应该去右子树找，而不是直接返回 1 **

**递归：**

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        if(!root->left) return minDepth(root->right) + 1;
        if(!root->right) return minDepth(root->left) + 1;
        else return min(minDepth(root->left)+1,minDepth(root->right)+1);
    }
};
```

**迭代**：

- 层序遍历过程中，若碰到叶子节点，说明找到了最小深度，当前层即是最小深度层

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode*> q;
        q.push(root);
        int res = 1;
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                q.pop();
                if(!cur->left && !cur->right) return res;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            res++;
        }
        return res;
    }
};
```



# 9. 完全二叉树的节点个数

[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

**即遍历二叉树的所有节点，前中后序遍历都可以做**

**层序遍历：**

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                res++;
                q.pop();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right); 
            }
        }
        return res;
    }
};
```

**递归：**

```c++
class Solution {
public:
    int res;
    void dfs(TreeNode* root){
        if(!root) return;
        res++;
        dfs(root->left);
        dfs(root->right);
    }
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        dfs(root);
        return res;
    }
};
```

**公式法：**

- 完全二叉树有可能是一棵满二叉树，也有可能最后一层节点不满，对于满二叉树，可以直接利用公式`2^n - 1`来计算节点数，其中`n`为二叉树深度，**根节点深度为 1 **
- 因此，遍历二叉树，若遇到满二叉树，**即左右子树深度相同时**，利用公式计算
- 若不是满二叉树，继续递归，直到遇见满二叉树

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftHeight = 0, rightHeight = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftHeight++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightHeight++;
        }
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```



# 10. 平衡二叉树

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

```c++
class Solution {
public:
    int Height(TreeNode* root)
    {
        if(root == nullptr){
            return 0;
        }else{
            return max(Height(root->left),Height(root->right)) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        if(root == nullptr){
            return true;
        }else{
            return abs(Height(root->left)-Height(root->right)) <=1 && isBalanced(root->left) && isBalanced(root->right);
        }
    }
};
```



# 11. 二叉树的所有路径

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

## 递归

```c++
class Solution {
private:

    void traversal(TreeNode* cur, string path, vector<string>& result) {
        path += to_string(cur->val); // 中
        if (cur->left == NULL && cur->right == NULL) {
            result.push_back(path);
            return;
        }
        if (cur->left) traversal(cur->left, path + "->", result); // 左
        if (cur->right) traversal(cur->right, path + "->", result); // 右
    }

public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        string path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;

    }
};
```

**外日，这题把我卡了半天，贴上自己的代码**

```c++
class Solution {
public:
    vector<string> res;
    void backTracking(TreeNode* root, string path){
        if(!root) return;
        if(!root->left && !root->right){
            if(path == "") path += to_string(root->val);
            else
                path = path + "->" + to_string(root->val);
            res.push_back(path);
            return;
        }

        if(path == ""){
            backTracking(root->left, path + to_string(root->val));
            backTracking(root->right, path + to_string(root->val));
        }else{
            backTracking(root->left, path + "->" + to_string(root->val));
            backTracking(root->right, path + "->" + to_string(root->val));
        }
        

    }
    vector<string> binaryTreePaths(TreeNode* root) {
        backTracking(root,"");
        return res;
    }
};
```

**小小的修改一下**

```c++
class Solution {
public:
    vector<string> res;
    void backTracking(TreeNode* root, string path){
        path += to_string(root->val);
        if(!root->left && !root->right){
            res.push_back(path);
            return;
        }

        if(root->left) backTracking(root->left, path + "->");
        if(root->right) backTracking(root->right, path + "->");
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        backTracking(root,"");
        return res;
    }
};
```



## 迭代

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> s1;
        stack<string> s2;
        vector<string> res;
        if(!root) return res;
        s1.push(root);
        s2.push(to_string(root->val));
        while(!s1.empty()){
            TreeNode* cur = s1.top(); s1.pop();
            string path = s2.top(); s2.pop();
            if(!cur->left && !cur->right){
                res.push_back(path);
            }
            if(cur->right){
                s1.push(cur->right);
                s2.push(path + "->" + to_string(cur->right->val));
            }
            if(cur->left){
                s1.push(cur->left);
                s2.push(path + "->" + to_string(cur->left->val));
            }
        }
        return res;
    }
};
```



# 12. 左叶子之和

[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

**左叶子节点：如果当前节点cur 的左节点不为空，并且该子节点左右节点为空，则该子节点为左叶子节点**

- 因此， 判断一个节点是否为左叶子节点，必须借助其父节点
- `if(root->left && !root->left->left && !root->left->right)`

## 递归

- 后序遍历：

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        
        int left = sumOfLeftLeaves(root->left);
        int right = sumOfLeftLeaves(root->right);

        int midValue = 0;
        if(root->left && !root->left->left && !root->left->right){
            midValue = root->left->val;
        }

        return midValue + left + right;
    }
};
```

- 前序遍历

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;                                       // 中
        int midValue = 0;
        if (root->left && !root->left->left && !root->left->right) {
            midValue = root->left->val;
        }
        int leftValue = sumOfLeftLeaves(root->left);    // 左
        int rightValue = sumOfLeftLeaves(root->right);  // 右

        int sum = midValue + leftValue + rightValue;
        return sum;
    }
};
```

- 中序遍历

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        int leftValue = sumOfLeftLeaves(root->left);    // 左
                                    // 中
        int midValue = 0;
        if (root->left && !root->left->left && !root->left->right) {
            midValue = root->left->val;
        }
        
        int rightValue = sumOfLeftLeaves(root->right);  // 右

        int sum = midValue + leftValue + rightValue;
        return sum;
    }
};
```

## 感想：

对于该题，我的想法就是遍历每一个节点，对每一个节点的左子节点做判断，判断他是不是左叶子节点，若是的话，就记录他的值，然后在它的左右子树上进行递归

因为是遍历这颗二叉树，而前中后序三种遍历都是将树遍历一遍，因此三种遍历方法都可以用在这题上，而**Carl哥说“递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和”，我没看懂，我感觉只要捋清楚了递归逻辑，确定了递归的返回值，遍历方法都可以**



## 迭代

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return 0;
        st.push(root);
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
                result += node->left->val;
            }
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return result;
    }
};
```

## 层序遍历

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root || (!root->left && !root->right) ) return 0;
        queue<TreeNode*> q;
        q.push(root);
        int res = 0;
        while(!q.empty()){
            TreeNode* cur = q.front();
            q.pop();
            if(cur->left){
                if(!cur->left->left && !cur->left->right) res += cur->left->val;
                q.push(cur->left);
            }
            if(cur->right) q.push(cur->right);
        }
        return res;
    }
};
```



# 13. 找树左下角的值

[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

## 迭代

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        que.push(root);
        int res;
        while(!que.empty())
        {
            int size = que.size();
            res = que.front()->val;
            for(int i = 0; i < size; i++)
            {
                TreeNode* cur = que.front();
                que.pop();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return res;
    }
};
```

## 递归

```c++
class Solution {
public:
    int maxLen = INT_MIN;
    int maxleftValue;
    void traversal(TreeNode* root, int leftLen) {
        if (root->left == NULL && root->right == NULL) {
            if (leftLen > maxLen) {
                maxLen = leftLen;
                maxleftValue = root->val;
            }
            return;
        }
        if (root->left) {
            leftLen++;
            traversal(root->left, leftLen);
            leftLen--; // 回溯
        }
        if (root->right) {
            leftLen++;
            traversal(root->right, leftLen);
            leftLen--; // 回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return maxleftValue;
    }
};
```



# 14. 路经总和

[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

## 递归

```c++
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if(root == nullptr) return false;
        if(root->left == nullptr && root->right == nullptr)
            return sum == root->val;
        return hasPathSum(root->left,sum-root->val) || hasPathSum(root->right,sum-root->val); 
    }
};
```

## 迭代：

```c++
class solution {

public:
    bool haspathsum(treenode* root, int sum) {
        if (root == null) return false;
        // 此时栈里要放的是pair<节点指针，路径数值>
        stack<pair<treenode*, int>> st;
        st.push(pair<treenode*, int>(root, root->val));
        while (!st.empty()) {
            pair<treenode*, int> node = st.top();
            st.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if (!node.first->left && !node.first->right && sum == node.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->right) {
                st.push(pair<treenode*, int>(node.first->right, node.second + node.first->right->val));
            }

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->left) {
                st.push(pair<treenode*, int>(node.first->left, node.second + node.first->left->val));
            }
        }
        return false;
    }
};
```



# 15. 路径总和 II

[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```c++
class Solution {
public:
    vector<vector<int>> Path ;
    //递归遍历每一条路径
    void dfs(TreeNode* root,vector<int> path,int targetSum,int cur_sum)
    {
        if(!root)  return;
        cur_sum += root->val;
        path.push_back(root->val);
        if(!root->left && !root->right && cur_sum == targetSum)
        {   
            Path.push_back(path);
        }
        dfs(root->left,path,targetSum ,cur_sum);
        dfs(root->right,path,targetSum ,cur_sum);

    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return Path;
        vector<int> path;
        dfs(root,path,targetSum,0);
        return Path;
    }
};
```



# 16. 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        _inorder = inorder;
        _postorder = postorder;
    
        for(int i = 0; i < inorder.size(); i++){
            hash[inorder[i]] = i;
        }
        TreeNode* root = build(0,inorder.size()-1,0,postorder.size()-1);
        return root;
    }
private:
    vector<int> _inorder;
    vector<int> _postorder;
    unordered_map<int,int> hash;

    TreeNode* build(int il,int ir, int pl, int pr){
        if(il > ir || pl > pr) return nullptr;
        TreeNode* root = new TreeNode(_postorder[pr]);
        int Index = hash[_postorder[pr]];
        int l = _inorder.size();
        TreeNode* left = build(il,Index - 1,pl,pl + Index - il - 1);
        TreeNode* right = build(Index + 1,ir,pl + Index - il , pr - 1);
        root->left = left;
        root->right = right;
        return root;
    }
};
```



# 17. 从中序与前序遍历序列构造二叉树

[剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```c++


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

 //前序遍历是 根左右，因此第一个元素即为根结点  [[根] [左子树的前序遍历] [右子树的前序遍历]]
 //中序遍历是 左根右，因此在中序序列中，根节点左边的元素为左子树元素，右边的元素为右子树元素 [ [左子树的中序遍历] [根][右子树的中序遍历]]
 //因此，给定前序遍历和中序遍历，可以递归的去构建一颗二叉树
 
 //首先在前序遍历中找到根结点的值
 //然后在中序遍历中确定左右子树的中序遍历
 //然后回过头来在前序遍历中确定左右子树的前序遍历
class Solution {
public:
    map<int,int> hash;
    vector<int> preorder,inorder;

    TreeNode* dfs(int pl,int pr, int il,int ir)
    {
        if(pl > pr) return nullptr;
        auto root = new TreeNode(preorder[pl]);
        //k为preorder[pl]在中序遍历序列中的下标
        int k = hash[root->val];
        //递归构建左右子树
        auto left = dfs(pl+1,pl+1+k-il-1,il,k-1);
        auto right = dfs(pl+k-il+1,pr,k+1,ir);
        root->left = left;
        root->right = right;
        return root;
    }

    TreeNode* buildTree(vector<int>& _preorder, vector<int>& _inorder) {
        preorder = _preorder;
        inorder = _inorder;
        //利用哈希表，将前序遍历映射到中序遍历中，方便查找前序遍历元素在中序遍历序列中的位置
        for(int i = 0;i < inorder.size();i++)  
            hash[inorder[i]] = i;
        return dfs(0,preorder.size()-1,0,inorder.size()-1);
    }
};

```



# 18. 最大二叉树

[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* dfs(vector<int>& nums, int l, int r)
    {
        if(l > r) return nullptr;
        int max = INT_MIN;
        int index = 0;
        for(int i = l; i <= r; i++){
            if(max < nums[i])
                max = nums[i], index = i;
        }
        TreeNode* root = new TreeNode(max);
        TreeNode* left = dfs(nums,l,index-1);
        TreeNode* right = dfs(nums,index+1,r);
        root->left = left;
        root->right = right;
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        TreeNode* root = dfs(nums,0,nums.size()-1);
        return root;
    }
};
```



# 19. 合并二叉树

[617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1 && !root2) return nullptr;
        if(!root1 && root2) return root2;
        if(root1 && !root2) return root1;

        TreeNode *node = new TreeNode(root1->val + root2->val);
        
        if(node){
            node->left = mergeTrees(root1->left, root2->left);
            node->right = mergeTrees(root1->right, root2->right);
        }
        return node;
    }
};
```



# 20. 二叉搜索树中的搜索

[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return nullptr;
        if(root->val == val) return root;
        else if(root->val < val) return searchBST(root->right, val);
        else
            return searchBST(root->left, val);
        
        return nullptr;
    }
};
```

**迭代：**

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```



# 21. 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

**递归：下面是我自己写的典型错误代码**

- 在处理逻辑中，我只单纯的判断了以当前节点为根节点的子树是否是一颗合理的BST
- 事实上，对于当前子树虽然合理，但是整棵树未必合理
- 例如，对于根节点 5，其右子树为`[6,3,7]`,右子树是一颗合理的BST，但是对于整棵树而言，节点 3 不应该出现在节点 5 的右端，因此不合理

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if(!root || (!root->left && !root->right)) return true;
        if(root->left && root->right) return root->left->val < root->val && root->val < root->right->val;
        if(!root->left) return root->val < root->right->val;
        if(!root->right) return root->val  > root->left->val;

        return isValidBST(root->left) && isValidBST(root->right);
    }
};
```

**利用BST的中序遍历是升序序列的性质，进行判断**

**递归：**

- 因为后台数据有int最小值测试用例，所以maxVal设置为longlong最小值。

```c++
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val) maxVal = root->val;
        else return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
};
```

- 如果测试数据中有 longlong的最小值

```c++
class Solution {
public:
    TreeNode* pre = NULL; // 用来记录前一个节点
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        bool left = isValidBST(root->left);

        if (pre != NULL && pre->val >= root->val) return false;
        pre = root; // 记录前一个节点

        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

**迭代：**

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> s;
        long long pre = (long long)INT_MIN - 1;
        TreeNode* cur = root;
        while(!s.empty() || cur != nullptr){
            while(cur){
                s.push(cur);
                cur = cur->left;
            } 
            cur = s.top();
            s.pop();
            if(cur->val <= pre) return false;
            pre = cur->val;
            cur = cur->right;           
        }
        return true;
    }
};
```

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL; // 记录前一个节点
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur->left;                // 左
            } else {
                cur = st.top();                 // 中
                st.pop();
                if (pre != NULL && cur->val <= pre->val)
                return false;
                pre = cur; //保存前一个访问的结点

                cur = cur->right;               // 右
            }
        }
        return true;
    }
};
```



# 22.二叉搜索树的最小绝对差

[530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

**递归：**

```c++
class Solution {
public:
    TreeNode* pre;
    int res = INT_MAX;
    void dfs(TreeNode* root)
    {
        if(!root) return;
        dfs(root->left);
        if(pre){
            res = min(res,root->val - pre->val);
        }
        pre = root;
        dfs(root->right);
    }
    int getMinimumDifference(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

**迭代：**

```c++
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int result = INT_MAX;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top();
                st.pop();
                if (pre != NULL) {              // 中
                    result = min(result, cur->val - pre->val);
                }
                pre = cur;
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```



# 23.二叉搜索树中的众数

[501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

```c++
class Solution {
public:
    //中序遍历法
    //定义一个前驱节点pre，将前驱节点pre与当前节点cur比较，若相等，则当前节点计数值count++
    //将count值与maxcount比较，若小，则cur不是频率最高的
    //若相等，则将cur存入数组
    //若count更大，则更新maxcount = count，并将之前存入数组的值清空，将cur存入数组

    TreeNode* pre = nullptr;
    int count = 0;
    int maxcount = 0;
    vector<int> v;
    //中序遍历
    void dfs(TreeNode* cur)
    {
        if(!cur) return ;
        //前
        dfs(cur->left);

        //中
        if(pre == nullptr)  count = 1;
        else if(pre->val == cur->val)   count++;
        else{ count = 1;}
        //更新前驱节点
        pre = cur;
        if(count ==　maxcount)   v.push_back(cur->val);
        else if(count > maxcount){
            maxcount = count;
            v.clear();
            v.push_back(cur->val);
        }

        //后
        dfs(cur->right);
        return;
    }

    vector<int> findMode(TreeNode* root) {
        dfs(root);
        return v;
    }
};
```

**迭代：**

```c++
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int maxCount = 0; // 最大频率
        int count = 0; // 统计频率
        vector<int> result;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top();
                st.pop();                       // 中
                if (pre == NULL) { // 第一个节点
                    count = 1;
                } else if (pre->val == cur->val) { // 与前一个节点数值相同
                    count++;
                } else { // 与前一个节点数值不同
                    count = 1;
                }
                if (count == maxCount) { // 如果和最大值相同，放进result中
                    result.push_back(cur->val);
                }

                if (count > maxCount) { // 如果计数大于最大值频率
                    maxCount = count;   // 更新最大频率
                    result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
                    result.push_back(cur->val);
                }
                pre = cur;
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```



# 24. 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == q || root == p) return root;
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        if(!left) return right;
        if(!right) return left;
        return root;
    }
};
```



# 25. 二叉搜索树的最近公共祖先

[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == p || root == q) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if(right && left) return root;
        if(!right) return left;
        return right;
    }
};
```

**迭代**

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root) {
            if (root->val > p->val && root->val > q->val) {
                root = root->left;
            } else if (root->val < p->val && root->val < q->val) {
                root = root->right;
            } else return root;
        }
        return NULL;
    }
};
```



# 26. 二叉搜索树的插入操作

[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

**迭代：**

```c++
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* node = new TreeNode(val);
        if(!root) return node;
        TreeNode* cur = root;
        TreeNode* parent = nullptr;
        while(true){
            if(!cur){
                if(parent->val > val){
                    parent->left = node;
                    return root;
                } 
                else{
                    parent->right = node;
                    return root;
                }
            }
            if(cur->val > val){
                parent = cur;
                cur = cur->left;
            } 
            else{
                parent = cur;
                cur = cur->right;
            } 
        }
        return root;
    }
};
```



```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* parent;
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* node = new TreeNode(val);
        if(!root){
            if(!parent)
                return node;
            else{
                if(parent->val > val)
                    parent->left = node;
                else 
                    parent->right = node;
            }
            return root;
        }
        if(root->val > val){
            parent = root;
            insertIntoBST(root->left,val);
            return root;
        }
        if(root->val < val){
            parent = root;
            insertIntoBST(root->right,val);
            return root;
        }
        return root;
    }
};
```

**关键在于定义一个指针用于记录父亲节点**



# 27. 删除二叉搜索树中的节点

[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

**模拟删除过程：我在这里踩了不少坑，下面贴上自己写的代码** 

**要特别注意其实只有一点：那就是当要删除的节点的左右子树不为空时，对于其左右子树的嫁接操作，我会在代码中标明**

```c++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        TreeNode* cur = root;
        if(!cur) return cur;
        TreeNode* parent = nullptr;
        while(cur && cur->val != key){
            if(cur->val > key){
                parent = cur;
                cur = cur->left;
            }else{
                parent = cur;
                cur = cur->right;
            }
        }
        //未找到
        if(!cur) return root;
        //删除根节点
        if(!parent){
            //根节点左右子树为空
            if(!cur->left && !cur->right) return nullptr;
            else if(cur->left && cur->right){
                //在根节点右子树中寻找一个左叶子节点，因为右子树中所有值都大于左子树中的节点值，因此可以直接将左子树嫁接到右子树中的最左非空节点的左子树上
                TreeNode* temp = cur->right;
                while(temp->left) temp = temp->left;
                temp->left = cur->left;
                //嫁接完成后返回右子树根节点
                return cur->right;
            }else if(!cur->left){
                return cur->right;
            }else{
                return cur->left;
            }
        }
		//若要删除的节点为其父节点的左子树
        if(cur == parent->left){
            if(cur->left && cur->right){
                //与上面一样的操作，嫁接左子树到右子树最左节点上的左子树上
                TreeNode* temp = cur->right;
                while(temp->left) temp = temp->left;
                temp->left = cur->left;
                //嫁接完成后的树再嫁接到父节点左子树上
                parent->left = cur->right;
            }
            else if(cur->left){
                parent->left = cur->left;
            }else{
                parent->left = cur->right;
            }
            return root;
        }
		//若要删除的节点为其父节点的右子树
        if(cur == parent->right){
            if(cur->left && cur->right){
                //与上文一样的操作，不再赘述
                TreeNode* temp = cur->right;
                while(temp->left) temp = temp->left;
                temp->left = cur->left;
                parent->right = cur->right;
            }
            else if(cur->left){
                parent->right = cur->left;
            }else{
                parent->right = cur->right;
            }
            return root;
        }

        return root;

    }
};
```

**递归：前序遍历**

```c++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root) return nullptr;
        if(root->val == key){
            if(!root->left) return root->right;
            if(!root->right) return root->left;
            if(root->left && root->right){
                TreeNode* node = root->right;
                while(node->left){
                    node = node->left;
                }
                node ->left = root->left;
                return root->right;
            }
        }
        if(root->val > key) root->left = deleteNode(root->left,key);
        if(root->val < key) root->right = deleteNode(root->right,key);
        return root;
    }
};
```

**主要在于删除根节点时，且根节点的左右子节点均不为空时，搞清楚删除逻辑**

## 提一嘴：普通二叉树的删除方式

- 第一次是和目标节点的右子树最左面节点交换。
- 第二次直接被NULL覆盖了。

```c++
class Solution {
private:
    // 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上
    // 并返回目标节点右孩子为新的根节点
    // 是动画里模拟的过程
    TreeNode* deleteOneNode(TreeNode* target) {
        if (target == nullptr) return target;
        if (target->right == nullptr) return target->left;
        TreeNode* cur = target->right;
        while (cur->left) {
            cur = cur->left;
        }
        cur->left = target->left;
        return target->right;
    }
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        TreeNode* cur = root;
        TreeNode* pre = nullptr; // 记录cur的父节点，用来删除cur
        while (cur) {
            if (cur->val == key) break;
            pre = cur;
            if (cur->val > key) cur = cur->left;
            else cur = cur->right;
        }
        if (pre == nullptr) { // 如果搜索树只有头结点
            return deleteOneNode(cur);
        }
        // pre 要知道是删左孩子还是右孩子
        if (pre->left && pre->left->val == key) {
            pre->left = deleteOneNode(cur);
        }
        if (pre->right && pre->right->val == key) {
            pre->right = deleteOneNode(cur);
        }
        return root;
    }
};
```



# 28. 修剪二叉搜索树

[669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

- 遍历二叉搜索树
  - 若当前节点值小于下边界，则其左子树所有节点值均小于下边界，整体删除`root->left = nullptr`
  - 若当前节点值大于上边界，则其右子树所有节点值均大于上边界，整体删除`root->right= nullptr`
  - 若当前值处于区间内，递归左右子树

**N刷记忆：**

```c++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(!root) return root;
        if(root->val < low){
            root->left = nullptr;
            return trimBST(root->right, low, high);
        }
        else if(root->val > high){
            root->right = nullptr;
            return trimBST(root->left, low, high);
        }else{
            root->left = trimBST(root->left, low, high);
            root->right = trimBST(root->right, low, high);
        }
        return root;
    }
};
```



```c++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(!root) return root;
        if(root->val > high){
            TreeNode* left =  trimBST(root->left,low,high);
            return left;
        }
        if(root->val < low){
            TreeNode* right = trimBST(root->right,low,high);
            return right;
        }
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);

        return root;
    }
};
```

**迭代：**

```c++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if (!root) return nullptr;

        // 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭
        while (root != nullptr && (root->val < L || root->val > R)) {
            if (root->val < L) root = root->right; // 小于L往右走
            else root = root->left; // 大于R往左走
        }
        TreeNode *cur = root;
        // 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况
        while (cur != nullptr) {
            while (cur->left && cur->left->val < L) {
                cur->left = cur->left->right;
            }
            cur = cur->left;
        }
        cur = root;

        // 此时root已经在[L, R] 范围内，处理右孩子大于R的情况
        while (cur != nullptr) {
            while (cur->right && cur->right->val > R) {
                cur->right = cur->right->left;
            }
            cur = cur->right;
        }
        return root;
    }
};
```



# 29. 将有序数组转换为二叉搜索树

[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

**进行二分操作时，要注意**

`int mid = (left + right) / 2`这种写法当两数都是`INT_MAX`时会发生越界，因此，应习惯写成

`int mid = left + (right - left) / 2`

```c++
class Solution {
public:
    TreeNode* build(vector<int>& nums,int l, int r)
    {
        if(l > r) return nullptr;
        int mid = (l + r) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = build(nums,l,mid - 1);
        root->right = build(nums,mid+1,r);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.empty()) return nullptr;
        return build(nums,0,nums.size()-1);
    }
};
```

**迭代：**

```c++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if (nums.size() == 0) return nullptr;

        TreeNode* root = new TreeNode(0);   // 初始根节点
        queue<TreeNode*> nodeQue;           // 放遍历的节点
        queue<int> leftQue;                 // 保存左区间下标
        queue<int> rightQue;                // 保存右区间下标
        nodeQue.push(root);                 // 根节点入队列
        leftQue.push(0);                    // 0为左区间下标初始位置
        rightQue.push(nums.size() - 1);     // nums.size() - 1为右区间下标初始位置

        while (!nodeQue.empty()) {
            TreeNode* curNode = nodeQue.front();
            nodeQue.pop();
            int left = leftQue.front(); leftQue.pop();
            int right = rightQue.front(); rightQue.pop();
            int mid = left + ((right - left) / 2);

            curNode->val = nums[mid];       // 将mid对应的元素给中间节点

            if (left <= mid - 1) {          // 处理左区间
                curNode->left = new TreeNode(0);
                nodeQue.push(curNode->left);
                leftQue.push(left);
                rightQue.push(mid - 1);
            }

            if (right >= mid + 1) {         // 处理右区间
                curNode->right = new TreeNode(0);
                nodeQue.push(curNode->right);
                leftQue.push(mid + 1);
                rightQue.push(right);
            }
        }
        return root;
    }
};
```



# 30. 把二叉搜索树转换为累加树

[538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

- 遍历顺序应该为 右 根 左



```c++
class Solution {
public:
    int sum = 0;
    void dfs(TreeNode* root){
        if(!root) return;
        dfs(root->right);

		int temp = root->val;
        root->val += sum;
        sum += temp;

        dfs(root->left);
    }
    TreeNode* convertBST(TreeNode* root) {
        if(!root) return root;
        dfs(root);
        return root;
    }
};
```

**迭代：**

```c++
class Solution {
private:
    int pre; // 记录前一个节点的数值
    void traversal(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur->right;   // 右
            } else {
                cur = st.top();     // 中
                st.pop();
                cur->val += pre;
                pre = cur->val;
                cur = cur->left;    // 左
            }
        }
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        pre = 0;
        traversal(root);
        return root;
    }
};
```



# 31. 不同的二叉搜索树

[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

- `G(n)`:长度为`n`的序列能构成的不同二叉搜索树的个数

- `F(i,n)`:长度为`n`的序列，以`i`为根节点时能构成的不同二叉搜索树的个数，`1 <= i <= n`

- 对于给定序列`1 ~ n`,可以构成的不同二叉搜索树的个数就是累加 **以各个值为根节点时可以构成的二叉搜索树的个数**

  - 即`G(n) = F(1,n) + F(2,n) + ... + F(n,n)`
  - `F(1,n)`为长度为`n`的序列，以`1`为根节点时能构成的不同二叉搜索树的个数
    - 以 1 为根节点时，其左子树为空，右子树节点数为`n-1`
    - 因此其右子树共有`G(n-1)`种排列方法
    - 即`F(1,n) = 1 *　G(n-1)`
  - `F(2,n)`为长度为`n`的序列，以`2`为根节点时能构成的不同二叉搜索树的个数
    - 以 2 为根节点时，其左子树只有一个节点`1`，右子树节点数为`n-2`
    - 因此其左子树共有`G(1)`种排列方法，右子树共有`G(n-2)`种排列方法
    - 即`F(2,n) = G(1) *　G(n-2)`
  - `F(i,n)`为长度为`n`的序列，以`i`为根节点时能构成的不同二叉搜索树的个数
    - 以 i 为根节点时，其左子树有`i-1`个节点，右子树节点数为`n-i`
    - 因此其左子树共有`G(i-1)`种排列方法， 右子树共有`G(n-i)`种排列方法
    - 即`F(2,n) = G(1) *　G(n-2)`
  - 综上:`F(i,n) = G(i-1) * G(n-i)`
  - 因此：`G(n) = G(0) * G(n-1) + G(1) * G(n-2) + .. + G(n-1) * G(0)`

  **递推公式如上，代码也就是手到擒来的事情了**

  ```c++
  class Solution {
  public:
      int numTrees(int n) {
          vector<int> G(n + 1, 0);
          G[0] = 1;
          G[1] = 1;
          for (int i = 2; i <= n; ++i) {
              for (int j = 1; j <= i; ++j) {
                  G[i] += G[j - 1] * G[i - j];
              }
          }
          return G[n];
      }
  };
  ```




# 32. 不同的二叉搜索树Ⅱ

[95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

**采用回溯法**

- 对于 节点`i`
  - 从序列`1 ~ i-1`中构建其左子树集合`leftTrees`
  - 从序列`i+1 ~ n`中构建其右子树集合`rightTrees`
- 遍历左右子树集合，每次从两集合中各取一个构成一颗树

```c++
class Solution {
public:
    vector<TreeNode*> generateTrees(int start, int end) {
        if (start > end) {
            return { nullptr };
        }
        vector<TreeNode*> allTrees;
        // 枚举可行根节点
        for (int i = start; i <= end; i++) {
            // 获得所有可行的左子树集合
            vector<TreeNode*> leftTrees = generateTrees(start, i - 1);

            // 获得所有可行的右子树集合
            vector<TreeNode*> rightTrees = generateTrees(i + 1, end);

            // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
            for (auto& left : leftTrees) {
                for (auto& right : rightTrees) {
                    TreeNode* currTree = new TreeNode(i);
                    currTree->left = left;
                    currTree->right = right;
                    allTrees.emplace_back(currTree);
                }
            }
        }
        return allTrees;
    }

    vector<TreeNode*> generateTrees(int n) {
        if (!n) {
            return {};
        }
        return generateTrees(1, n);
    }
};
```



# 33. 恢复二叉搜索树

[99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

首先，交换搜索树的两个节点后，最多有两个位置的值异常，即在中序遍历结果`nums[n]`中，可能有：

- `nums[i] < nums[i+1]`
- `nums[j] < nums[j+1]`

也可能只存在一个位置的值异常，此时就是只交换了父子节点的值

- `nums[i] < nums[i+1]`

有两种方法，

- 中序遍历二叉树，将中序遍历结果存储在一个数组中，然后遍历数组，找出异常值
- 不存储中序遍历结果，可以在中序遍历过程中记录异常值

**法二代码：**

```c++
class Solution {
public:
    void recoverTree(TreeNode* root) {
        if(!root) return;
        TreeNode* x = nullptr;
        TreeNode* y = nullptr;
        TreeNode* pre = nullptr;
        stack<TreeNode*> s;
        TreeNode* cur = root;
        while(!s.empty() || cur){
            if(cur){
                s.push(cur);
                cur = cur->left;
            }else{
                cur = s.top();
                s.pop();
                if(pre && cur->val < pre->val){
                    y = cur;
                    if(!x){
                        x = pre;
                    }
                }
                pre = cur;
                cur = cur->right;
            } 
        }
        swap(x->val,y->val);
    }
};
```



# 34. 二叉树的锯齿形层序遍历

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

**简单层序遍历**

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root) return res;       
        queue<TreeNode*> q;
        q.push(root);
        int i = 0;
        while(!q.empty()){
            vector<int> path;
            int size = q.size();
            for(int j = 0; j < size; j++){
                TreeNode* cur =q.front();
                q.pop();
                path.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            if(i % 2){
                reverse(path.begin(), path.end());
            }
            res.push_back(path);
            i++;
        }
        return res;
    }
};
```



# 35. 求根节点到叶节点数字之和

[129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

**该题与路径之和有异曲同工之妙，也是找到每一条根节点到叶子节点的路径，只不过路径之和的定义变了**

- 采用前序遍历，从根节点一直遍历到叶子节点，遍历过程中更新路径值

  - ```c++
    path = path * 10 + root->val;
    ```

- 当遍历到叶子节点时，说明走完了一条路径，将路径之加入结果集

  - ```c++
    if(!root->left && !root->right){
    	sum += path;
    	return;
    }
    ```

- 继续递归左右子树

**完整代码如下：**

```c++
class Solution {
public:
    int sum;
    void dfs(TreeNode* root,int path){
        if(!root) return;
        path = path * 10 + root->val;
        if(!root->left && !root->right){
            sum += path;
            return;
        }
        dfs(root->left,path);
        dfs(root->right,path);
    }
    int sumNumbers(TreeNode* root) {
        dfs(root,0);
        return sum;
    }
};
```



# 36. 二叉搜索树迭代器

[173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

可以利用数组存储中序遍历结果

```c++
class BSTIterator {
public:
    BSTIterator(TreeNode* root){
        dfs(root);
        point = -1;
    }
    
    void dfs(TreeNode* root){
        if(!root) return;
        TreeNode* cur = root;
        dfs(cur->left);
        v.push_back(cur);
        dfs(cur->right);
    }

    int next() {
        return v[++point]->val;
    }
    
    bool hasNext() {
        if(point == -1) return v.size();
        return point < v.size() - 1;
    }   
private:
    vector<TreeNode*> v;
    int point;
}
```

**也可以利用栈进行迭代遍历**

```c++
class BSTIterator {
private:
    TreeNode* cur;
    stack<TreeNode*> stk;
public:
    BSTIterator(TreeNode* root): cur(root) {}
    
    int next() {
        while (cur != nullptr) {
            stk.push(cur);
            cur = cur->left;
        }
        cur = stk.top();
        stk.pop();
        int ret = cur->val;
        cur = cur->right;
        return ret;
    }
    
    bool hasNext() {
        return cur != nullptr || !stk.empty();
    }
};
```

**统一迭代法：**

```c++
class BSTIterator {
private:
    TreeNode* cur;
    stack<TreeNode*> stk;
public:
    BSTIterator(TreeNode* root): cur(root) {
        stk.push(cur);
    }
    
    int next() {
        while(!stk.empty()){
            TreeNode* node = stk.top();
            if(node){
                stk.pop();
                if(node->right) stk.push(node->right);  //右
                
                stk.push(node);                         //中
                stk.push(nullptr);
                
                if(node->left) stk.push(node->left);    //左
            }else{
                stk.pop();
                TreeNode* ret = stk.top();
                stk.pop();
                return ret->val;
            }
        }
        return -1;
    }
    
    bool hasNext() {
        return !stk.empty();
    }
};
```

