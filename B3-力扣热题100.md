# [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**哈希表**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash;
        vector<int> res;
        for(int i = 0; i < nums.size(); i++)
        {
            if(hash.find(target - nums[i]) != hash.end()){
                res.push_back(hash[target - nums[i]]);
                res.push_back(i);
                return res;
            }else{
                hash[nums[i]] = i;
            }
        }
        return res;
    }
};
```



# [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**模拟**

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = nullptr;
        ListNode* tail = nullptr;
        int carry = 0;
        while(l1 || l2){
            int n1 = l1 ? l1->val : 0;
            int n2 = l2 ? l2->val : 0;
            int number = n1 + n2 + carry;
            carry = number / 10;
            number %= 10;
            if(!head) head = tail = new ListNode(number);
            else{
                tail->next = new ListNode(number);
                tail = tail->next;
            }
            if(l1) l1 = l1->next;
            if(l2) l2 = l2->next;
        }
        if(carry){
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```



# [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

**典型的滑动窗口**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       unordered_set<int> hash;
       int left = 0, right = 0;
       int res = 0;
       while(right < s.size())
       {
           while(hash.find(s[right]) != hash.end()){
               hash.erase(s[left]);
               left++;
           }
           hash.insert(s[right]);
           res = max(res,right - left + 1);
           right++;
       } 
       return res;
    }
};
```



# [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

**可以直接用暴力法，将两个数组合并，然后输出合并后数组的中位数，该方法时间复杂度`O(m+n)`**

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();
        if(!n1 && !n2) return 0;
        vector<int> temp;
        int i = 0, j = 0;
        while(i < n1 && j < n2){
            if(nums1[i] < nums2[j])
                temp.push_back(nums1[i++]);
            else
                temp.push_back(nums2[j++]);
        }
        if(i < n1){
            for(;i < n1;i++){
                temp.push_back(nums1[i]);
            }
        }
        if(j < n2){
            for(;j < n2;j++){
                temp.push_back(nums2[j]);
            }
        }
        int length = n1 + n2;
        if(length % 2 != 0) return temp[length/2];
        double res = (double)(temp[length/2 - 1] + temp[length/2]) / 2;
        return res;
    }
};
```



**也可以使用二分法**

```c++
class Solution {
public:
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int n = nums1.size();
		int m = nums2.size();

		if (n > m)  //保证数组1一定最短
		{
			return findMedianSortedArrays(nums2, nums1);
		}

		// Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。
		int LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n;  //我们目前是虚拟加了'#'所以数组1是2*n长度

		while (lo <= hi)   //二分
		{
			c1 = (lo + hi) / 2;  //c1是二分的结果
			c2 = m + n - c1;

			LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];
			RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2];
			LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];
			RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2];

			if (LMax1 > RMin2)
				hi = c1 - 1;
			else if (LMax2 > RMin1)
				lo = c1 + 1;
			else
				break;
		}
		return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0;
	}
};
```



# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

**动态规划**

- `dp[i][j]`:字符串中第`i`到第`j`个字符组成的回文串的长度，若不是回文串，则长度为0
- 状态转移方程：
  - 若`s[i] == s[j]`
    - 如果`i == j`:则`dp[i][j] = 1`
    - 如果`i - j == 1`：则`dp[i][j] == 2`
    - 如果`dp[i+1][j-1] != 0`,则`dp[i][j] = dp[i+1][j-1] + 2`
  - 若`s[i] != s[j]`
    - `dp[i][j] == 0`
- 边界条件：
  - `dp[i][i] = 1`
- 最终答案即为`max(dp[i][j])`



**注意遍历顺序，首层循环必须从后往前遍历，即`for(int i = n-1; i >= 0; i--)`,因为在状态转移过程中，`dp[i][j]会利用到dp[i+1][j-1]`，所以必须先遍历`dp[i+1]`,然后遍历`dp[i]`**

**代码：**

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2) return s;
        string res = "";
        vector<vector<int>> dp(n,vector<int>(n,0));

        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j])
                {
                    if(i == j) dp[i][j] = 1;
                    else if(j - i == 1){
                        dp[i][j] = 2;
                    }
                    else if(dp[i + 1][j - 1]){
                        dp[i][j] = dp[i+1][j-1] + 2;
                    }
                }
                else{
                    dp[i][j] = 0;
                }
   
                if(dp[i][j] &&( res.size() < j - i + 1)){
                    res.clear();
                    res = s.substr(i,j - i + 1);
                }
            }
        }
        return res;
    }
};
```



# [6. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

## 1. 动态规划数组定义以及状态定义

- `dp[i][j]: 字符串s的前i个字符与模式串p的前j个字符的匹配情况`
- 若 `s[i-1] == p[j-1]`
  - `dp[i][j] = dp[i-1][j-1]`
- 若`s[i-1] != p[j-1]`
  - 若`p[j-1] == '.'`
    - `dp[i][j] == dp[i-1][j-1] `，该类情况可以合并到第一类中
  - 若`p[j-1] == '*'`
    - 则可以匹配0个`p[j-2]`或者匹配 1 个
      - 匹配 0 个时：`dp[i][j] = dp[i][j-2]`
      - 匹配 1 个时：`dp[i][j] = dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')`
  - 若`p[j-1]为小写字母`
    - 则`dp[i][j] = false`

**综上，一共可以分为两种情况，分别为`p[j-1] == '*' 或者 p[j-1] != '*'`**

## 2. DP数组初始化

- 当给定字符串以及模式串均为空是，两者当然是匹配的(空字符匹配空字符)

  - `dp[0][0] = true`

- 当模式字符串为空，而给定字符串不为空时，结果当然是false

  - `for(int i = 1; i <= ns; i++) dp[i][0] = false;`

- 当给定字符串为空，而模式字符串不为空时，只有当模式字符串的偶数位上为`*`时，两者才匹配

  - ```c++
    for(int i = 2; i <= np; i += 2){
               if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
           }
    ```



## 3. 代码

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int ns = s.size();
        int np = p.size();
        vector<vector<bool>> dp(ns+1,vector<bool>(np+1,false));
        dp[0][0] = true;
        for(int i = 1; i <= ns; i++) dp[i][0] = false;
        for(int i = 2; i <= np; i += 2){
            if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
        }

        for(int i = 1; i <= ns; i++)
        {
            for(int j = 1; j <= np; j++)
            {
                if(p[j-1] == '*'){
                    dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'));
                }else{
                    if(s[i-1] == p[j-1] || p[j-1] == '.')
                        dp[i][j] = dp[i-1][j-1];
                    else
                        dp[i][j] = false;
                }
            }
        }

        return dp[ns][np];
    }
};
```



# [7. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

![image-20211126155344279](C:\Users\Sakura\AppData\Roaming\Typora\typora-user-images\image-20211126155344279.png)

**可以看出容量大小取决于两端长度最短的那块板子**

- 利用双指针 `i j`分别指向数组两端
- 如果`heght[i] < height[j]` 则令左指针 `i`左移一位，否则，右指针`j`右移一位

## 双指针移动规律

- 双指针向内收缩时，容器底部长度肯定是减小的
  - 如果`heght[i] < height[j]`，此时若移动较大的指针，即`j--`，移动后的最小板子为`min(height[i],height[j-1])`，由于`height[j]`是较大的那个，因此移动后的容器体积肯定减小，不会增大
  - 如果`heght[i] < height[j]`，此时若移动较 小的指针，即`i++`，移动后的最小板子为`min(height[i-1],height[j])`，此时`height[i-1]`可能会增大，因此容器体积也有可能增大
- 因此每次移动较小的那个指针

## 正解：

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0, j = height.size() -1 ;
        int res = 0;
        while(i < j)
        {
              res = height[i] < height[j] ? 
                max(res, (j - i) * height[i++]): 
                 max(res, (j - i) * height[j--]); 
        }
        return res;
    }
};
```



# [8. 三数之和](https://leetcode-cn.com/problems/3sum/)

**排序+双指针**

为了保证不重复，可以先将数组排序，然后保证每重循环遍历的数字都不小于上一层循环，即保证`a <= b <= c`，并且对于每一层循环，相邻两次枚举的元素不可以重复

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int l = i + 1, r = nums.size() - 1;
            while(l < r){
                if(nums[i] + nums[l] + nums[r] == 0){
                    res.push_back(vector<int>{nums[i], nums[l++], nums[r--]});
                    while(l < r && nums[l] == nums[l-1]) l++;
                    while(l < r && nums[r] == nums[r+1]) r--;
                }else if(nums[i] + nums[l] + nums[r] > 0){
                    r--;
                }else{
                    l++;
                }
            }
        }
        return res;
    }
};
```



# [9. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

**回溯**

- 首先将数字与其代表的字符串映射
- 回溯三部曲
  - 确定递归参数及返回值
    - 递归函数传入输入的数字字符串，并且需要维护一个整型变量Index，表示遍历到了第几个数字
  - 确定递归终止条件——当前字符串长度等于给定字符串长度时，递归终止
  - 确定递归单层逻辑
    - 首先从给定字符串中分离出数字字符
    - 然后去映射数组中取出该数字对应的字符串
    - 遍历字符串，一一取出字符，并递归下一个数字

```c++
class Solution {
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    string s;
    void backtracking(const string& digits, int index) {
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';        // 将index指向的数字转为int
        string letters = letterMap[digit];      // 取数字对应的字符集
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);            // 处理
            backtracking(digits, index++);    // 递归，注意index+1，一下层要处理下一个数字了
            s.pop_back();                       // 回溯
        }
    }
    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if (digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
```

# [10. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

**典型双指针应用**

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head) return head;
        ListNode* dummy = new ListNode(-1,head);
        ListNode* fast = dummy;
        ListNode* slow = dummy;
        while(n--){
            fast = fast->next;
        }
        while(fast->next){
            slow = slow->next;
            fast = fast->next;
        }
        slow->next = slow->next->next;
        return dummy->next;
    }
};
```



# [11. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

**栈**

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> sta;
        for(auto x : s){
            if(sta.empty()){
                sta.push(x);
            }
            else if
              (x == ')' && sta.top() == '(' || 
               x == '}' && sta.top() == '{' || 
               x == ']' && sta.top() == '[')
            {
                sta.pop() ;
            }else{
                sta.push(x);
            }
        }
        return sta.empty();
    }
};
```

# [12. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(!list1) return list2;
        if(!list2) return list1;
        ListNode* dummy = new ListNode(-1);
        ListNode* cur = dummy;
        ListNode* prev = nullptr;
        while(list1 && list2){
            if(list1->val > list2->val){
                cur->next = list2;
                list2 = list2->next;
                prev = cur;
                cur = cur->next;
            }else{
                cur->next = list1;
                list1 = list1->next;
                prev = cur;
                cur = cur->next;
            }
        }
        if(list1) cur->next = list1;
        if(list2) cur->next = list2;

        return dummy->next;
    }
};
```

# [13. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

**回溯：**

- 添加括号的过程中，一定是优先添加左括号，然后添加右括号
- 递归终止条件——当前路径长度==2n
- 递归参数：
  - 用两个变量left和right用于记录当前左右括号的数量
- 递归逻辑
  - 如果左括号数量小于n,则添加一个左括号，递归下一层
  - 如果右括号数量小于n,且小于左括号数量，则添加一个右括号，递归下一层

**代码：**

```c++
class Solution {
public:
    vector<string> res;
    string path;
    void backTracking(int n, int left, int right)
    {
        if(path.size() == 2 * n){
            res.push_back(path);
            return;
        }
        
        if(left < n)
        {
            path += '(';
            left++;
            backTracking(n,left, right);
            left--;
            path.pop_back();
        }
        if(right < n && right < left)
        {
            path += ')';
            right++;
            backTracking(n,left,right);
            right--;
            path.pop_back();
        } 
    }
    vector<string> generateParenthesis(int n) {
        backTracking(n,0,0);
        return res;
    }
};
```

# [14. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

## 法一：根据合并双链表的方法，依次合并所有链表

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode *ans = nullptr;
        for (size_t i = 0; i < lists.size(); ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }
};
```

## 法二：分治合并

**作为法一的优化方法，对链表数组中的链表两两配对合并**

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* merge(vector <ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};

```

## 法三：优先队列

```c++
class Solution {
public:
    struct comp {
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };

    priority_queue<ListNode*, vector<ListNode*>, comp> q;

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        for (auto node: lists) {
            if (node) q.push(node);
        }
        ListNode* head = new ListNode();
        ListNode* tail = head;
        while (!q.empty()) {
            ListNode* node = q.top();
            q.pop();
            tail->next = node; 
            tail = tail->next;
            if (node->next) q.push(node->next);
        }
        return head->next;
    }
};
```



# [15. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        //从后往前遍历，找到第一个升序对(i,i+1)满足nums[i] < nums[i+1]
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        //从i+1至数组尾的所有元素一定满足降序排列
        //从后往前遍历，在i+1至数组尾元素中找到第一个大于nums[i]的元素
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            //交换两者
            swap(nums[i], nums[j]);
        }
        //交换后，nums[j]后的元素一定还是以降序排列，将其反转，使其变为升序排列
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

# [16. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

**动态规划**

-   `dp[i]:`以字符`s[i]`结尾的最长有小括号的长度
- **状态转移：**
  - 若`s[i] == '('`,显然此时`dp[i] = 0`,因为有小括号必然是以右括号结尾
  - 若`s[i] == ')'`
    - 若`s[i-1] == '('`，则两者组成一对括号，故`dp[i] = dp[i-2] + 2`
    - 若`s[i-1] == ')'`
      - 此时，若`s[i]`要组成有效括号对，则其之前的位置必须是有效括号对，即`dp[i-1]`必须是一个有效长度，则与`s[i]`配对的左括号的位置为           `s[i - dp[i-1] - 1]`,若`s[i - dp[i-1] - 1] == '('`，则`dp[i] = dp[i-1] + 2`
      - 还需要注意一点，以上情况是形如`((...))`，若`s[i]`组成的有效括号对形如`(...)((...))`,因此`dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        if(n == 0) return 0;
        vector<int> dp(n+1,0);
        int res = 0;
        for(int i = 1; i < n; i++)
        {
            if(s[i] == '(') dp[i] = 0;
            if(s[i] == ')')
            {
                if(s[i-1] == '('){
                    dp[i] = 2;
                    if(i >= 2) dp[i] += dp[i-2];
                }
                else if(s[i - 1] == ')')
                {
                    if(dp[i-1] > 0 && i - dp[i-1] - 1 >= 0 && s[i - dp[i-1] - 1] == '(')
                    {
                        dp[i] = dp[i-1] + 2;
                        if(i - dp[i-1] - 1 > 0)
                            dp[i] += dp[i - dp[i-1] -2];
                    }
                } 
            }
            res = max(res,dp[i]);
        }
        return res;
    }
};
```



# [17. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

- 原数组`A`为升序排列，经过旋转后分为两部分`A1与A2`
  - 两部分分别为升序数组，`A[0]`为`A1`最小值，`A[A.size()]`为`A2`最大值
  - 并且`A1`中所有值均大于`A2`
- 因此该题可以采用二分法
  - `若A[mid] >= A[0]`
    - `if (A[0] <= target && target < A[mid])`,则在A1中找
    - 否则，去A2寻找
  - `若A[mid] < A[0]`
    - ` if (A[mid] < target && target <= A[n - 1])`,则在A2中找
    - 否则，去A1寻找
  - `若target == A[0]`:则直接返回
- 代码：

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```



# [18. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

**二分法：**

- 假设目标值在有序数组中的下标范围为i ~ j;

  - 则其右边界r满足`nums[r] <= target`
  - 其左边界满足`nums[l] >= target`

- 二分：

- 与普通二分不同的是：

  - 普通二分：`if(nums[mid] == target) return mid`
  - 该题：
    - 查找左边界`if(nums[mid] == target) right = mid - 1;`
    - 查找右边界`if(nums[mid] == target) left = mid + 1`

  ```c++
  class Solution {
  public:
      vector<int> searchRange(vector<int>& nums, int target) {
          vector<int> res{-1,-1};
          if(nums.empty()) return res;
          int l = 0, r = nums.size() - 1;
          while(l <= r){
              int mid = (l + r)/2;
              if(nums[mid] >= target){
                  r = mid - 1;
              }else{
                  l = mid + 1;
              }
          }
          if(l >= nums.size() || nums[l] != target){
              return res;
          }
          else{
              res.clear();
              res.push_back(l);
              int i = 0, j = nums.size() - 1;
              while(i <= j){
                  int mid = i + j >> 1;
                  if(nums[mid] <= target){
                      i = mid + 1;
                  }else{
                      j = mid - 1;
                  }
              }
              res.push_back(j);
          }
          return res; 
      }
  };
  ```

  

# [19. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

**回溯三部曲**

- 递归函数参数

  **此题为了避免重复情况，例如[2,2,3]和[3,2,2],需要设定一个startIndex，用于表示每次循环的起点，防止遍历已经遍历过的元素**

  ```c++
  void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
  ```

  

- 递归终止条件

  当当前和等于给定值或者大于给定值时函数返回

  ```c++
    if(sum == target){
              res.push_back(path);
              return;
    }else if(sum > target) return;
  ```

  

- 单层循环逻辑

  ```c++
  for(int i = startIndex; i < candidates.size(); i++){
        path.push_back(candidates[i]);
        sum += candidates[i];
      //与前面的组合问题不同，此处的startIndex不需要+1，表示可以重复选取元素
        backtracking(candidates,target,sum,i);
        sum -= candidates[i];
        path.pop_back();
  }
  ```

  

**最终结果**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
    {
        if(sum == target){
            res.push_back(path);
            return;
        }else if(sum > target) return;

        for(int i = startIndex; i < candidates.size(); i++){
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(candidates,target,sum,i);
            sum -= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracking(candidates,target,0,0);
        return res;
    }
};
```



**剪枝优化**

```c++
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```



# [20. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

**单调栈：**

- 采用递减栈，栈内存储下标，若当前元素大于栈顶元素，则需要弹出栈顶元素直至栈顶元素大于当前元素
  - 因为若当前元素大于栈顶元素，则表示当前元素与栈顶元素之间存在了凹槽，可以收集雨水
  - 栈顶元素为凹槽底部，栈顶第二个元素就是凹槽左边的柱子，当前元素就是凹槽右边的柱子
  - 如果遇到相同元素，就更新栈顶元素为新元素下标

**为了保证不遗漏，在给定数组尾部加入一个0，保证所有元素都被计算到，如果不加0，当给定数组是递增数组时，栈将不会推出元素**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        heights.push_back(0);
        stack<int> s;
        int res = 0;
        for(int i = 0; i < heights.size(); i++)
        {
            while(!s.empty() && heights[s.top()] > heights[i])
            {
                int mid = s.top();
                int h = heights[mid];
                int w = i;
                s.pop();
                if(!s.empty())
                {   
                    w = i - s.top() - 1;
                }
                res = max(res, h *  w);
            }
            s.push(i);
        }
        return res;
    }
};
```



# [21. 全排列](https://leetcode-cn.com/problems/permutations/)

**回溯**

该题给定数组不包含重复元素，因此只需要保证每次选取数字时不要选取之前已经选过的元素，因此可以使用一个数组来记录当前元素是否已经选取过

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int>& nums, vector<bool>& used){
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            if(used[i] == true) continue;
            path.push_back(nums[i]);
            used[i] = true;
            backTracking(nums, used);
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        backTracking(nums, used);
        return res;
    }
};
```



# [22. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

找规律：

`matrix1[col][n−row−1]=matrix[row][col]`

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        if(matrix.empty()) return ;
        int len = matrix.size();
        int i = 0;
        while(i < len / 2)
        {
            for(int j = i; j < len - i - 1 ; j++)
            {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[len-1-j][i];
                matrix[len-1-j][i] = matrix[len-1-i][len-1-j];
                matrix[len-1-i][len-1-j] = matrix[j][len-1-i];
                matrix[j][len-1-i] = temp;
            }
            i++;
        }
    }
};
```



# [23. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

**哈希表运用**

将单词排序后的结果作为键值key，**字母异位词**排序后的结果应该是一样的，因此以字母异位词组合为value

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>>hash;
        for(auto str : strs){
            string key = str;
            sort(key.begin(),key.end());
            hash[key].push_back(str);
        }
        vector<vector<string>> res;
        for(auto x : hash){
            res.push_back(x.second);
        }
        return res;
    }
};
```



# [24. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

**动态规划：**

- `dp[i]:`以元素`nums[i]`结尾的连续子数组的最大和

- 转移方程：考虑`nums[i]`单独成为一段，还是加入`dp[i-1]`对应的那一段

  - ```c++
    dp[i] = max(dp[i-1] + nums[i], nums[i]);
    ```

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        int res = nums[0];
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] + dp[i-1] < 0 ) dp[i] = max(nums[i],nums[i] + dp[i-1]);
            else
                dp[i] = max(dp[i-1] + nums[i],nums[i]);

            if (dp[i] > res) res = dp[i];
        }
        return res;
    }
};
```



**也可以采用滚动数组**

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0, res = nums[0];
        for(const auto &x : nums){
            pre = max(x, pre + x);
            res = max(res, pre);
        }
        return res;
    }
};
```



# [25. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

**贪心：**

**遍历每一个元素，实时维护从当前位置可以到达的最远位置，如果最远位置超出了数组边界，则表示可以到达**

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.empty()) return false;
        int cover = 0;
        for(int i = 0; i <= cover; i++){
            cover = max(cover, nums[i] + i);
            if(cover >= nums.size() - 1)
                return true;
        }
        return false;
    }
};
```



# [26. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

**总体思路就是：先将数组元素按照首元素大小从小到大排序，然后逐个进行合并操作——前一个元素的末尾元素大于后一个元素的的首元素时，两者可以合并，特别注意一点，合并时并不是简单的分别取两个元素的首尾元素，而是还要再比较一下前一个元素的末尾元素与后一个元素的末尾元素，取其大者，之所以这样做，是考虑到两个数组可能存在包含关系**

**代码实现：**

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        if(intervals.empty()) return res;
        sort(intervals.begin(), intervals.end(),[&](vector<int> a, vector<int> b){
            return a[0] < b[0];
        });
        res.push_back(intervals[0]);
        for(int i = 1; i < intervals.size(); i++){
            if(intervals[i][0] <= res.back()[1]){
                //前一个元素的末尾元素与后一个元素的末尾元素，取其大者
                res.back()[1] = max(intervals[i][1],res.back()[1]);
            }else{
                res.push_back(intervals[i]);
            }
        }
        return res;
    }
};
```



# [27. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

动态规划：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n,0));
        dp[0][0] = 1;
        for(int i = 1; i < m; i++) dp[i][0] = 1;
        for(int i = 1; i < n; i++) dp[0][i] = 1;
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```



# [28. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

**动态规划：**

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = grid[0][0];
        for(int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int i = 1; i < n; i++) dp[0][i] = dp[0][i-1] + grid[0][i];

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
};
```



# [29. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

**动态规划**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```



# [30. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

**动态规划**

- `dp[i][j]：word1的前i个字符串转换成word2的前j个子字符串所使用的最少操作`
- 状态转移：
  - 若`word1[i-1] == word2[j-1]`，则`dp[i][j] = dp[i-1][j-1]`
  - 若`word1[i-1] != word2[j-1]`，此时可以使用增删改来改动字符串
    - 在`word1[i-12]`末尾添加字符：`dp[i][j] = dp[i-1][j] + 1`
    - 在`word2[j-2]`末尾添加字符：`dp[i][j] = dp[i][j-1] + 1`
    - 修改`word1[i-1]`或者修改`word2[j-1]`：`dp[i][j] = dp[i-1][j-1] + 1`

**代码：**

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size();
        int n2 = word2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
        for(int i = 0; i <= n1; i++) dp[i][0] = i;
        for(int i = 0; i <= n2; i++) dp[0][i] = i;
        for(int i = 1; i <= n1; i++){
            for(int j = 1; j <= n2; j++){
                if(word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = min(dp[i-1][j] + 1,min(dp[i][j-1] + 1, dp[i-1][j-1] + 1));
            }
        }
        return dp[n1][n2];
    }
};
```



# [31. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

**双指针**

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
       //双指针
        int n = nums.size();
        int p = 0, q = n - 1;
        for (int i = 0; i <= q; ++i) {
            if (nums[i] == 0) {
                nums[i] = nums[p];
                nums[p] = 0;
                ++p;
            }
            if (nums[i] == 2) {
                nums[i] = nums[q];
                nums[q] = 2;
                --q;
                if (nums[i] != 1) {
                    --i;
                }
            }
        }
        return;
    }
};
```



# [32. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

滑动窗口

**用一个哈希表`ht`记录字符串`t`的字符，用另一个哈希表`hs`记录当前窗口中的元素**

**代码：**

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        string res;
        unordered_map<char,int> hs;
        unordered_map<char,int> ht;
        for(auto x : t) ht[x]++;
        //用于记录,每在窗口中加入一个所需元素，该数加一，cnt == t.size()时表明窗口内是一个符合条件的最小子串
        int cnt = 0;
        //i , j 分别为窗口的左右两边界
        for(int i = 0, j = 0; j < s.size(); j++){
            //窗口向右移动
            hs[s[j]]++;
            //如果当前元素是t中的字符，
            if(hs[s[j]] <= ht[s[j]]) cnt++;
            //窗口左边界收缩
            while(hs[s[i] > ht[s[i]]]) hs[s[i++]]--;
            //找到一个符合条件的最小字串
            if(cnt == t.size()){
                if(res.empty() || res.size() > j - i + 1)
                    res = s.substr(i,j - i + 1);
            }
        }
        return res;
    }
};
```



# [33. 子集](https://leetcode-cn.com/problems/subsets/)

**回溯**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums,int startIndex)
    {
        res.push_back(path);
        if(startIndex > nums.size()) return;
        for(int i = startIndex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backtracking(nums,i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums,0);
        return res;
    }
};
```



# [34. 单词搜索](https://leetcode-cn.com/problems/word-search/)

**回溯**

```c++
class Solution {
public:
    bool backTracking(vector<vector<char>>& board, const string& word, int startIndex, int x, int y)
    {
        if(board[x][y] != word[startIndex]) return false;
        if(startIndex == word.size() - 1){
            return true;
        }

        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};

        char temp = board[x][y];
        board[x][y] = '*';
        for(int i = 0; i < 4; i++){
            int a = x + dx[i];
            int b = y + dy[i];
            if(a >= 0 && a < board.size() && b >= 0 && b < board[a].size()){
                if(backTracking(board,word,startIndex + 1, a, b)) return true;
            }
        }
        board[x][y] = temp;
        return false;

    }
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++){
            for(int j = 0; j < board[0].size(); j++){
                if(backTracking(board,word,0,i,j))
                    return true;
            }
        }
        return false;
    }
};
```



# [35. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

**单调栈**

**参考暴力解法：对一个柱子，枚举以其为矩形高度所能得到的最大面积**

使用单调栈的话，首先要确定栈内元素，该题栈内应该存储下标，便于计算矩形底边长度，其次，确定使用递增栈还是递减栈，，对于该题，由于要以一个柱子的高度为矩形的高度，因此，栈内元素应该为递增，因为只要下一个元素大于栈顶元素，以栈顶元素为高度的矩形底边就能一直扩展。

**举个例子：下标为0的柱子高度为2，下标为1的柱子高度为1，第一个元素先入栈，遍历到第二个元素时，由于1比2小，因此以2为高度的矩形此时无法在向右扩张，此时须计算出其最大面积**

**代码：**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        heights.push_back(0);
        stack<int> s;
        int res = 0;
        for(int i = 0; i < heights.size(); i++)
        {
            while(!s.empty() && heights[s.top()] > heights[i])
            {
                int mid = s.top();
                int h = heights[mid];
                int w = i;
                s.pop();
                if(!s.empty())
                {   
                    w = i - s.top() - 1;
                }
                res = max(res, h *  w);
            }
            s.push(i);
        }
        return res;
    }
};
```



# [36. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

**该题其实是[34. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)的变形，将给定矩形的每一行统计成柱状图，然后分别求最大矩形**

```c++
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.empty() || matrix[0].empty()) return 0;
        int res = 0;
        vector<int> heights(matrix[0].size(),0);

        for(int i = 0; i < matrix.size(); i++)
        {
            for(int j = 0; j < matrix[0].size();j++)
            {
                if(matrix[i][j] == '1') heights[j] += 1;
                else heights[j] = 0;
            }
            res = max(res, largestRectangleArea(heights));
        }
        return res;

    }

    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        heights.push_back(0);
        stack<int> s;
        int res = 0;
        for(int i = 0; i < heights.size(); i++)
        {
            while(!s.empty() && heights[s.top()] > heights[i])
            {
                int mid = s.top();
                int h = heights[mid];
                int w = i;
                s.pop();
                if(!s.empty())
                {   
                    w = i - s.top() - 1;
                }
                res = max(res, h *  w);
            }
            s.push(i);
        }
        return res;
    }
};
```



# [37. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**递归写法：**

```c++
class Solution {
public:
    vector<int> res;
    void dfs(TreeNode* node){
        if(node){
            dfs(node->left);
            res.push_back(node->val);
            dfs(node->right);
        }
    }
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

**迭代写法：**

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```



# [38. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

**动态规划：**

**思路：[代码随想录 (programmercarl.com)](https://programmercarl.com/0096.不同的二叉搜索树.html#思路)**

- `dp[i]`:节点值为1~i可以构成的二叉搜索树数量
- 二叉搜索树的右子树大于根节点值，左子树小于根节点值，因此，对于给定值n,我们可以从该方面思考一共可以组成的二叉搜索树数量：
  - 以`1~n`分别为根节点：
    - 以1为根节点值，则共有`dp[0] * dp[n-1]`种情况，即左子树为空，右子树有`n-1`个节点
    - 以2为根节点值，则共有`dp[1] * dp[n-2]`种情况，即左子树有一个节点，右子树有`n-2`个节点
    - 由此递归，以n为根节点值，则共有`dp[n-1] * dp[0]`种情况，即左子树有`n-1`个节点，右子树为空
- 将以上所有情况相加，即为最终答案
- 因此递归状态转移方程为：
  - `dp[i] += dp[j-1] * dp[i-j],j从1到i依次取值`

**代码：**

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= i; j++)
                dp[i] += dp[j - 1] * dp[i - j];

        return dp[n];
    }
};
```

# [39. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

**二叉搜索数的中序遍历序列为升序序列，根据规则，可以先求出给定二叉树的中序遍历，然后判断是否为升序序列**

```c++
class Solution {
public:
    vector<int> res;
    void dfs(TreeNode* root){
        if(!root) return;
        dfs(root->left);
        res.push_back(root->val);
        dfs(root->right);
    }
    bool isValidBST(TreeNode* root) {
        dfs(root);
        for(int i = 1; i < res.size(); i++){
            if(res[i] <= res[i-1]) return false;
        }
        return true;
    }
};
```

**或者利用迭代中序遍历，遍历的同时进行判断**

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> s;
        long long pre = (long long)INT_MIN - 1;
        TreeNode* cur = root;
        while(!s.empty() || cur != nullptr){
            while(cur){
                s.push(cur);
                cur = cur->left;
            } 
            cur = s.top();
            s.pop();
            if(cur->val <= pre) return false;
            pre = cur->val;
            cur = cur->right;           
        }
        return true;
    }
};
```

**还可以直接递归判断**

```c++
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```



# [40. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

**由题意可知：对于对称二叉树的根节点，其左右子树成镜像对称，由此思路展开，代码如下：**

```c++
class Solution {
public:
    bool isMirror(TreeNode* root1, TreeNode* root2)
    {
        if(!root1 && !root2) return true;
        if(!root1 && root2) return false;
        if(root1 && !root2) return false;
        if(root1->val == root2->val) return isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);
        return false;
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isMirror(root->left,root->right);
    }
};
```

**迭代写法**

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        while (!que.empty()) {  // 接下来就要判断这这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```



# [41. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if(!root) return res;
        q.push(root);
        while(!q.empty())
        {
            int size = q.size();
            vector<int> temp;
            for(int i = 0; i < size; i++)
            {
                TreeNode* cur = q.front();
                q.pop();
                temp.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right); 
            }
            res.push_back(temp);
        }
        return res;
    }
};
```



# [42. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**可以利用层序遍历，即广度优先搜索，每遍历一层记录一下，最终结果就是最大深度，代码如下：**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
                if(i == size - 1)
                    res++;
            }
        }  
        return res;
    }
};
```

**也可以利用深度优先搜索，代码如下：**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```



# [43. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

**前序遍历序列构造为——根 左 右， 中序遍历序列为——左 根 右**

**因此，每次取前序序列的首元素root，其必为二叉树的根节点，同时，在中序序列中，该元素将序列分为两部分，即，中序序列中，root左边的所有元素为root的左子树元素，root右边的所有元素为root的右子树元素，然后在两个序列中继续上述步骤，首先从前序序列中找到根节点，然后在中序序列中分割，递归的构造二叉树**

**代码如下：**

```c++
class Solution {
public:
/*
    前序遍历---根左右
    中序遍历---左根右
    前序遍历的首元素为根的val，然后根据根的val去中序遍历中找到左右子树的元素，然后递归构建
*/
    unordered_map<int,int> hash;

    TreeNode* buildDfs(vector<int>& preorder, vector<int>& inorder, int pl, int pr, int il, int ir)
    {
        //递归终止条件
        if(pl > pr || il > ir) return nullptr;
        //根据前序遍历首元素构造根节点
        TreeNode* root = new TreeNode(preorder[pl]);
        //寻找根节点元素在中序遍历中的下标
        int index = hash[preorder[pl]];
		// 左子树元素个数为 index - il
        root->left = buildDfs(preorder, inorder, pl + 1, pl + 1 + index - il - 1, il, index - 1);
        root->right = buildDfs(preorder, inorder, pl + 1 + index - il - 1 + 1, pr , index + 1, ir);

        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.empty()) return nullptr;
        for(int i = 0; i <inorder.size();i++)
            hash[inorder[i]] = i;

        return buildDfs(preorder,inorder,0,preorder.size()-1, 0, inorder.size()-1);
    }
};
```



# [44. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

**题目要求链表元素顺序与二叉树先序遍历结果相同,观察先序遍历特点，可以按如下步骤进行展开**

1. 对于当前节点`cur`，判断其左子节点`cur->left`是否为空
   1. 左子节点为空`cur->left == nullptr`，对下一个节点进行展开`cur = cur->right`
   2. 左子节点不为空，**找到左子树中的最右边的节点`prev`，将当前节点的右子树赋给最右节点的右子树`prev->right = cur->right`**
   3. 将当前节点左子树赋给右子节点，即`cur->right = cur->left`，然后将当前节点左子节点置空`cur->left = nullptr`

```c++
class Solution {
public:
    void flatten(TreeNode* root) {
        if(!root) return;
        TreeNode* cur = root;
        while(cur)
        {
            if(cur->left){
                TreeNode* next = cur->left;
                TreeNode* prev = next;
                while(prev->right)
                    prev = prev->right;

                prev->right = cur->right;

                cur->right = cur->left;
                cur->left = nullptr;
            }
            cur = cur->right; 
        }
    }
};
```



# [45. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**方法一：遍历数组，维护一个最小值`cur`，不断更新最大利润**

- 若当前元素`price[i]`比`cur`小，则更新`cur = price[i]`
- 不断更新最大利润`res = max(res, prices[i] - cur)`

**代码：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res = 0;
        int cur = INT_MAX;
        for(int i = 0; i < prices.size(); i++){
            cur = cur < prices[i] ? cur : prices[i];
            res = max(res, prices[i] - cur);
        }
        return res;
    }
};
```



**方法二：动态规划**

- `dp[i][j]`:`i`表示第`i`天，`j = 0 或 1`
  - `dp[i][0]`表示第 `i` 天持有股票
  - `dp[i][1]`表示第 `i` 天不持有股票
- **初始状态**：一开始现金为0，`dp[0][0] -= price[i], dp[0][1] = 0 `
- **状态转移方程**：
  - 第一种情况，若第`i`天**持有**股票
    - 延续第`i-1`天 的股票持有情况，则`dp[i][0] = dp[i-1][0]`
    - 在第`i`天买入股票，则`dp[i][0] -= price[i]`
    - **综上，`dp[i][0] = max(dp[i-1][0], -price[i])`**
  - 第二种情况，如第`i`天**不持有**股票
    - 延续第`i-1`天 的股票不持有情况，则`dp[i][1] = dp[i-1][1]`
    - 在第`i`天卖出股票，则`dp[i][1] = dp[i-1][0] + price[i]`
    - **综上，`dp[i][1] = max(dp[i-1][1], dp[i-1][0] + price[i])`**
- **最终结果：**返回`dp[len-1][1]`,在本题全程只允许买卖一次的情况下，肯定**不持有状态下利益大**

**代码：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        /*
            dp[i][j]: i表示第i天，j = 0 或 1，
            dp[i][0]表示第 i 天持有股票
            dp[i][1]表示第 i 天不持有股票
        */
        int n = prices.size();
        vector<vector<int>> dp(n,vector<int>(2,0));

        dp[0][0] -= prices[0];
        dp[0][1] = 0;

        for(int i = 1; i < n; i++)
        {
            dp[i][0] = max(dp[i-1][0],-prices[i]);
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i]);
        }
        return dp[n-1][1];
    }
};
```



# [46. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

**思路：**

该题中的最大路径和，其实就是每个节点与其左右子树中的最大节点值之和

该题可以采用**后序遍历**，先求出叶子节点的**贡献值**，贡献值即为节点值，然后求根节点的贡献值，根节点贡献值为`node.val + max(leftVal,rightVal)`,并且，最大路径和等于`node.val + leftVal + rightVal`,实时更新最大路径和

**代码：**

```c++
class Solution {
private:
    int maxSum = INT_MIN;

public:
    int maxGain(TreeNode* node) {
        if (node == nullptr) {
            return 0;
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = max(maxGain(node->left), 0);
        int rightGain = max(maxGain(node->right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node->val + leftGain + rightGain;

        // 更新答案
        maxSum = max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node->val + max(leftGain, rightGain);
    }

    int maxPathSum(TreeNode* root) {
        maxGain(root);
        return maxSum;
    }
};
```



# [47. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

**运用哈希表存储数组中所有元素，然后遍历寻找连续序列**

- 寻找过程中可以进行一些优化，为了避免遍历完`x , x+1, ..., y`后，下次循环又从`x+1`开始寻找连续序列，在遍历时，可以先判断一下当前元素`x`的前驱元素`x-1`是否存在，因为`unordered_set`中的元素是按升序排列的，如果前驱元素存在，说明在对前驱元素寻找连续序列时已经包含了当前元素



**代码：**

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> hash;
        int res = 0;
        for(const auto num : nums){
            hash.insert(num);
        }
        for(const auto num : hash){
            int len = 1;
            if(hash.count(num - 1)){
                continue;
            }
            int cur = num;
            while(hash.count(cur + 1)){
                cur++;
                len++;
            }
            res = max(res,len);
        }
        return res;
    }
};
```



# [48. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

**异或运算：**

**A^0=A  A^A=0**,并且异或运算支持交换律和结合律，即**B^A^A=B  因为B^A^A=B^(A^A)=B^0=B**

**因此，对于该题，仅有一个元素出现一次，其他元素均出现两次，对所有元素进行异或运算，最终结果就是只出现了一次的元素**

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret = 0;
        for (auto e: nums) ret ^= e;
        return ret;
    }
};
```



# [49. 单词拆分](https://leetcode-cn.com/problems/word-break/)

- `dp[i]:字符串s前i个字母组成的字符串是否可以利用字典中的单词拼接出来`

- 状态转移方程：

  ​		从前往后计算考虑转移方程，每次转移的时候我们需要枚举包含位置 i-1*i*−1 的最后一个单词，看它是否出现在字典中以及除去这部分的字符串是否合法即可。

  ​		逐个划分s中的单词，`dp[i]`要为真，则`s[j] ~ s[i]`能从字典中拼接并且`s[0]~s[j-1]`也能从字典中拼接即`dp[j] == true`

  ​		**`dp[i]=dp[j] && check(s[j..i−1])`**

- 边界条件：

  - 我们定义 `dp[0] = true`表示空串且合法

**代码：**

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   
            for (int j = 0; j < i; j++) {       
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```



# [50. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

 **快慢指针，若有环，则一定会相遇，若无环，则最终两指针均指向空**

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head || !head->next) return false;
        ListNode* fast = head->next;
        ListNode* slow = head;
        while(slow != fast){
            if(!fast || !fast->next) return false;
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow == nullptr ? false : true;
    }
    
};
```



# [51. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

**法一：哈希表**

遍历链表中的每个节点，并将他记录下来，如果碰到了此前遍历过的节点，就可以判断链表存在环

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode *> visited;
        while (head != nullptr) {
            if (visited.count(head)) {
                return head;
            }
            visited.insert(head);
            head = head->next;
        }
        return nullptr;
    }
};
```

**法二：快慢指针**

![image-20220222105243011](F:\A3-git_repos\数据结构与算法_notes\图片\image-20220222105243011.png)

设环外部分长度为`a`，快慢指针在环上`A`点相遇，入口节点`B`与`A`的顺时针距离为b，`A `与`B `的顺时针距离为`c`，此时快指针已经在环内转了`n`圈，其走过的距离为`a +n(b + c) + b `,由于快指针每次走两步，慢指针每次走一步，因此快指针路程为慢指针的两倍，所以有`a +n(b + c) + b = 2(a + b)`，因此，

**`a = c + (n-1)(b+c)`**

因此，从相遇点到入环点的距离加上`n-1` 圈的环长，恰好等于从链表头部到入环点的距离

**定义两个指针index1 与 index2, index1 从头节点出发，一次走一步，index2 从相遇点出发，一次走一步，两者相遇时，相遇点即为环的入口节点**

**当n=1时，a = c, 当n>1时，这种情况和n为1的时候效果是一样的，一样可以通过这个方法找到环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点**

```c++
class Solution {
public:

    ListNode *detectCycle(ListNode *head) {
        if(!head || !head->next) return nullptr;
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast != NULL && fast->next != NULL){
            fast = fast->next->next;
            slow = slow->next; 
            if(fast == slow){
                ListNode* index1 = head;
                ListNode* index2 = slow;
                while(index1 != index2){
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index1;
            }
        }
        return nullptr;
    }
};
```



# [52. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

**哈希表加双向链表，通过哈希表实现时间复杂度为O(1)的查询操作，通过链表实现时间复杂度为O(1)的插入删除操作**

```c++
class LRUCache {
public:
    LRUCache(int capacity) : _capacity(capacity) {

    }
    
    int get(int key) {
        //若不存在，则返回-1
        if(hash.find(key) == hash.end()) return -1;
        //记录结果，然后要将该节点移到链表最前端
        int res = hash[key]->second;
        auto curNode = *hash[key];
        Cache.erase(hash[key]);
        Cache.push_front(curNode);
        hash[key] = Cache.begin();
        return res;
    }
    
    void put(int key, int value) {
        //若当前缓存中不存在key
        if(hash.find(key) == hash.end())
        {
            //如果缓存容量满了
            if(Cache.size() == _capacity)
            {
                //删除链表尾部节点
                auto node = Cache.back();
                hash.erase(node.first);
                Cache.pop_back();
            }
        }else{
            //若缓存中已存在key
            Cache.erase(hash[key]);
        }
        //将节点加入链表头部，并更新哈希表
        Cache.push_front({key,value});
        hash[key] = Cache.begin();
        
    }
private:
    int _capacity;
    //利用双向链表实现O(1)的插入操作
    list<pair<int,int>> Cache;
    //利用哈希表实现O(1)的查询操作 <key,链表节点指针>
    unordered_map<int,list<pair<int,int>>::iterator> hash;
};
```

**也可以自己定义双向链表**

```c++
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;

public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (!cache.count(key)) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode* node = new DLinkedNode(key, value);
            // 添加进哈希表
            cache[key] = node;
            // 添加至双向链表的头部
            addToHead(node);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode* removed = removeTail();
                // 删除哈希表中对应的项
                cache.erase(removed->key);
                // 防止内存泄漏
                delete removed;
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



# [53. 排序链表](https://leetcode-cn.com/problems/sort-list/)

**法一：自顶向下归并排序**

1. 找到链表中点（这里可以使用快慢指针），将链表分为两个子链表
2. 对两个子链表分别排序
3. 将两个排序后的子链表合并，得到完整的链表

可以用递归实现上述过程，递归终止条件为链表为空或者链表只包含一个节点

```c++
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return sortList(head, nullptr);
    }

    ListNode* sortList(ListNode* head, ListNode* tail) {
        if (head == nullptr) {
            return head;
        }
        if (head->next == tail) {
            head->next = nullptr;
            return head;
        }
        ListNode* slow = head, *fast = head;
        while (fast != tail) {
            slow = slow->next;
            fast = fast->next;
            if (fast != tail) {
                fast = fast->next;
            }
        }
        ListNode* mid = slow;
        return merge(sortList(head, mid), sortList(mid, tail));
    }

    ListNode* merge(ListNode* head1, ListNode* head2) {
        ListNode* dummyHead = new ListNode(0);
        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;
        while (temp1 != nullptr && temp2 != nullptr) {
            if (temp1->val <= temp2->val) {
                temp->next = temp1;
                temp1 = temp1->next;
            } else {
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }
        if (temp1 != nullptr) {
            temp->next = temp1;
        } else if (temp2 != nullptr) {
            temp->next = temp2;
        }
        return dummyHead->next;
    }
};
```

时间复杂度是`O(nlogn)`

空间复杂度是`O(logn)`，主要是递归产生的栈空间调用

**法二：自底向上归并排序**

要实现`o(1)`的空间复杂度，就需要使用自底向上的归并排序，**用迭代取代递归**，首先求得链表的长度，然后将链表拆分成子链表进行合并。

每轮合并操作针对的子链表都是**固定长度**：

1. 第一轮合并时每个单位长度为**1**，合并完成后长度变为**2**
2. 第二轮合并时每个单位长度为**2**，合并完成后长度变为**4**

依次类推，若要采用迭代的方法，可以仅根据固定长度计算每个单元边界，并完成链表的合并操作

1. 当长度为1时，将链表第**1**和第**2**节点排序合并，第**3**和第**4**节点排序合并........
2. 当长度为2时，将链表第**1~2**和第**3~4**节点排序合并，第**5~6**和第**7~8**节点排序合并........

**代码：**

```c++
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr) {
            return head;
        }
        int length = 0;
        ListNode* node = head;
        while (node != nullptr) {
            length++;
            node = node->next;
        }
        ListNode* dummyHead = new ListNode(0, head);
        for (int subLength = 1; subLength < length; subLength <<= 1) {
            ListNode* prev = dummyHead, *curr = dummyHead->next;
            while (curr != nullptr) {
                ListNode* head1 = curr;
                for (int i = 1; i < subLength && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                ListNode* head2 = curr->next;
                curr->next = nullptr;
                curr = head2;
                for (int i = 1; i < subLength && curr != nullptr && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                ListNode* next = nullptr;
                if (curr != nullptr) {
                    next = curr->next;
                    curr->next = nullptr;
                }
                ListNode* merged = merge(head1, head2);
                prev->next = merged;
                while (prev->next != nullptr) {
                    prev = prev->next;
                }
                curr = next;
            }
        }
        return dummyHead->next;
    }

    ListNode* merge(ListNode* head1, ListNode* head2) {
        ListNode* dummyHead = new ListNode(0);
        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;
        while (temp1 != nullptr && temp2 != nullptr) {
            if (temp1->val <= temp2->val) {
                temp->next = temp1;
                temp1 = temp1->next;
            } else {
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }
        if (temp1 != nullptr) {
            temp->next = temp1;
        } else if (temp2 != nullptr) {
            temp->next = temp2;
        }
        return dummyHead->next;
    }
};
```



# [54. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

**数组中可能存在负数，因此存在一种可能，当遇到负数时，当前最大值变为了最小值，若之后再遇到一个负数，则最小值则又变为了最大值，因此求解该题过程中，既要维护一个最大值，还要维护一个最小值，遇到负数时，两者互相交换，但是也可能存在整个数组只存在一个负数的情况，因此连乘过程中还要实时维护结果**

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        if(!n) return 0;
        int mmax = 1;
        int mmin = 1;
        int res = nums[0];
        for(int i = 0; i < n; i++)
        {
            if(nums[i] < 0)
            {
                swap(mmax,mmin);
            }
            mmax = max(nums[i],mmax * nums[i]);
            mmin = min(nums[i],mmin * nums[i]);

            res = max(res,mmax);
        }
        return res;
    }
};
```



# [55. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```c++
class MinStack {
public:
    stack<pair<int,int>> sta;
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int val) {
        if(sta.empty())
        {
            sta.push({val,val});
        }else{
            sta.push({val,min(sta.top().second,val)});
        }    
    }
    
    void pop() {
        sta.pop();
    }
    
    int top() {
        return sta.top().first;
    }
    
    int getMin() {
        return sta.top().second;
    }
};
```



# [56. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA || !headB) return NULL;
        ListNode* cur1 = headA, *cur2 = headB;
        while(cur1 != cur2){
            cur1 = cur1 == nullptr ? headB : cur1->next;
            cur2 = cur2 == nullptr ? headA : cur2->next;
        }
        return cur1;
    }
};
```



# [57. 多数元素](https://leetcode-cn.com/problems/majority-element/)

**若某元素个数超过数组总元素个数的一半，则排序后，数组元素肯定为该元素**

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int n = nums.size();
        return nums[n/2];
    }
};
```



# [58. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

**动态规划：**

- `dp[j]`:前`j`个房屋能偷的最大金额
- 状态转移方程：因为相邻房屋不能偷，所以`dp[j] = max(dp[j-1], dp[j-2] + nums[j-1])`
- 边界条件：`dp[0] = 0`

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n+1,0);
        for(int i = 1; i <= n; i++){
            dp[i] = max(dp[i-1],nums[i-1]);
            if(i > 1) dp[i] = max(dp[i], dp[i-2] + nums[i-1]);
        }
        return dp[n];
    }
};
```



# [59. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)



```c++
class Solution {
private:
    const int dx[4] = {0,-1,0,1};
    const int dy[4] = {1,0,-1,0};

    void dfs(vector<vector<char>>& grid,int i, int j, int n, int m)
    {
        if(i < 0 || i >= n || j < 0 || j >= m || grid[i][j] != '1') return;

        grid[i][j] = '2';
        for(int k = 0; k < 4; k++)
        {
            int a = i + dx[k];
            int b = j + dy[k];

            dfs(grid, a, b,n,m);
        }
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();

        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    dfs(grid, r, c,nr,nc);
                }
            }
        }

        return num_islands;
    }
};
```



# [60. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

**迭代：**

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* cur = head;
        if(!cur) return cur;
        while(cur){
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
};
```

**递归：**

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
        if(head == nullptr || head->next == nullptr){
            return head;
        }else{
            ListNode* cur = reverseList(head->next);
            head->next->next = head;
            head->next = nullptr;
            return cur;
        }
    }
};
```



# [61. 课程表](https://leetcode-cn.com/problems/course-schedule/)



# [62. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

```c++
class Trie {
public:
    /** Initialize your data structure here. */
    Trie() {
        isEnd = false;
        memset(next,0,sizeof(next));
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Trie* cur = this;
        for(char temp : word)
        {
            if(cur->next[temp-'a'] == NULL)
            {
                cur->next[temp-'a'] = new Trie();
            }
            cur = cur->next[temp-'a'];
        }
        cur->isEnd = true;
    }

    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Trie* cur = this;
        for(char temp : word)
        {
            if(cur->next[temp-'a'] == NULL)
            {
                return false;
            }else{
                cur = cur->next[temp-'a'];
            }
        }
        return cur->isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Trie* cur = this;
        for(char temp : prefix)
        {
            if(cur->next[temp-'a'] == NULL)
            {
                return false;
            }else{
                cur = cur->next[temp-'a'];
            }
        }
         return true;
    }

private:
    bool isEnd;
    Trie* next[26];
};
```



# *[63. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

**法一：快排**

**利用快速排序的性质：确定一个标志点，每轮从左右两边开始查找，首先从右往左遍历，找一个比标志点小的值right，然后从左往右遍历，找一个比标志点大的值left，然后交换两者，再然后把标志点与right交换，此时，标志点左侧的值都比标志点小，标志点右侧的值都比标志点大，然后以标志点为分界点，在左右子数组中继续以上过程**

**根据以上性质，每轮快排结束后，标志点左侧有i个元素，这i个元素均小于标志点，即标志点为第i个最小的元素，而要求第k个最大的元素，即求第 n - i个最小的元素，其中 n 为数组长度**

**快排时，一定要注意的一点是，每次快排时，一定要先从右向左查找，只有这样，在两个指针相遇时，指向的值一定比标志点小，在与标志点交换时才不会出错，因为每次以左边界点为标志点，交换时一定要保证交换值小于标志点**

```c++
class Solution {
public:
    int quickSort(vector<int>& nums, int l, int r, int k)
    {
        int i = l, j = r;
        while(i < j)
        {
            while(i < j && nums[j] >= nums[l]) j--;
            while(i < j && nums[i] <= nums[l]) i++;
            swap(nums[i],nums[j]);
        }
        swap(nums[l],nums[i]);

        if(i > k) return quickSort(nums,l,i-1,k);
        if(i < k) return quickSort(nums,i+1,r,k);

        return nums[i];
    }
    int findKthLargest(vector<int>& nums, int k) {
        return quickSort(nums,0,nums.size()-1,nums.size() - k);
    }
};
```

**法二：堆排序**

数组中的第K个最大元素即数组按降序排列后第 k 个元素，若利用堆排序来解决该问题，可参照如下思路：

- 小根堆——堆顶元素为最小元素，其他元素均小于该元素
- 大根堆——堆顶元素为最大元素，其他元素均大于该元素

直接利用大根堆的性质，先将数组所有元素存入大根堆，然后删除 k - 1 次堆顶元素，删除后的大根堆的堆顶元素就是答案。

**直接调库：**

```c++

class Solution 
{
public:
    int findKthLargest(vector<int>& nums, int k) 
    {
        priority_queue<int, vector<int>, less<int>> maxHeap;
        for (int x : nums)
            maxHeap.push(x);
        for (int i = 0; i < k - 1; i ++)
            maxHeap.pop();
        return maxHeap.top();
    }
};
```

**自己构建大根堆**

```

```



# [64. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

**动态规划：**

- `dp[i][j]:`以`(i,j)`为右下角，且只包含1的正方形的边长最大值
- 转移方程：
  - 若`matrix[i][j] = 0`，则`dp[i][j] = 0`,即当前位置不可能在由1组成的正方形中
  - 若`matrix[i][j] = 1`，则`dp[i][j]`取决于其上方、左方和左上方的三个相邻位置的`dp`值
    - `dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1`
    - 该转移方程的证明可见[1277. 统计全为 1 的正方形子矩阵](https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/)的官方证明
- 边界条件：
  - 当`i == 0 || j == 0, dp[i][j] = matrix[i][j]`

**代码：**

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        int res = 0;

        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(matrix[i][j] == '1'){
                    if(i == 0 || j == 0) dp[i][j] = 1;
                    else
                        dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;
                }   
                
                res = max(res,dp[i][j]);
            }
        }
        return res * res;
    }
};
```



# [65. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;
        TreeNode* left = root->left;
        root->left = root->right;
        root->right = left;
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```



# [66. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

**将链表后半部分反转，然后对比，具体过程如下：**

1. 使用快慢指针找到链表的中心节点
2. 断开链表，翻转后半部分链表
3. 比较两部分链表，判断是否回文
4. 恢复链表（我将其忽略）
5. 返回结果

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head){
        if(!head || !head->next) return head;
        ListNode* prev = nullptr;
        ListNode* cur = head;
        while(cur){
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }

    bool isPalindrome(ListNode* head) {
        if(!head || !head->next) return true;
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast){
            fast = fast->next;
            slow = slow->next;
            if(fast) fast = fast->next;
        }
        ListNode* mid = slow;
        ListNode* temp = reverseList(mid);
        while(temp){
            if(temp->val == head->val){
                temp = temp->next;
                head = head->next;
            }else{
                return false;
            }
        }
        return true;
    }
};
```



# [67. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

**递归遍历二叉树，用`left`和`right`表示指定节点是否存在左右子树中**

- 若`left && right`：则返回根节点，即根节点就是最近公共祖先
- 若`!left`：则返回`right`，因为两指定节点均存在于右子树，并且由于是后序遍历，最终得到的结果一定是最近公共祖先
- 若`!right`：则返回`left`，同理

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == q || root == p) return root;
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        if(!left) return right;
        if(!right) return left;
        return root;
    }
};
```



# [68. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

**利用前缀积与后缀积组合求出答案**

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        if(nums.empty()) return vector<int>{};
        vector<int> res(nums.size(),1);
        for(int i = 1; i < nums.size(); i++)
        {
            //求出前缀积
            res[i] = nums[i-1] * res[i-1];
        }
        for(int i = nums.size() - 2; i >= 0; i--)
        {
            //前缀积乘上后缀积
            res[i] *= nums[i+1];
            //更新后缀积
            nums[i] *= nums[i+1];
        }
        return res;
    }
};
```

**由于输出数组不算在空间复杂度内，因此该解法空间复杂度为O(1)**



# [69. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

**堆(优先队列):**

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        priority_queue<pair<int, int>> q;
        for (int i = 0; i < k; ++i) {
            q.emplace(nums[i], i);
        }
        vector<int> ans = {q.top().first};
        for (int i = k; i < n; ++i) {
            q.emplace(nums[i], i);
            while (q.top().second <= i - k) {
                q.pop();
            }
            ans.push_back(q.top().first);
        }
        return ans;
    }
};
```

**单调队列：**

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;
        vector<int> res;
        for(int i = 0; i < k; i++){
            while(!dq.empty() && nums[i] >= nums[dq.back()]){
                dq.pop_back();
            }
            dq.push_back(i);
        }
        res.push_back(nums[dq.front()]);

        for(int i = k; i < nums.size(); i++){
            while(!dq.empty() && nums[i] >= nums[dq.back()]){
                dq.pop_back();
            }
            dq.push_back(i);
            while(i - dq.front() >= k){
                dq.pop_front();
            }
            res.push_back(nums[dq.front()]);
        }
        return res;
    }
};
```



# [70. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.empty() || matrix[0].empty()) return false;

        int i = matrix.size() - 1;
        int j = 0;
        while(i >= 0 && j < matrix[0].size()){
            if(matrix[i][j] < target)
                j++;
            else if(matrix[i][j] > target)
                i--;
            else
                return true;
        }
        return false;
    }
};
```



# [71. 会议室Ⅱ](https://leetcode-cn.com/problems/meeting-rooms-ii)

![会议室Ⅱ](F:\A3-git_repos\数据结构与算法_notes\图片\会议室Ⅱ.png)

 

# [72. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

**完全背包问题：你有m种硬币,面额分别为1,4,9,16......你需要购买一个价格为n的商品,问最少花费几枚硬币**

```c++
class Solution {
public:
    int numSquares(int n) {
        /*
            dp[j]: 和为 j 的完全平方数的最少数量为dp[j]
            dp[j] = dp[j-1]+1 dp[j-4] + 1....
        */
        vector<int> dp(n+1,INT_MAX);
        int nums = sqrt(n);
        dp[0] = 0;
        //遍历背包容量
        for(int i = 1; i <= n; i++){
            //遍历硬币
            for(int j = 1; j*j <= i; j++){
                dp[i] = min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
};
```

运用[四平方和定理](https://baike.baidu.com/item/四平方和定理)，四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界，同时四平方和定理包含了一个更强的结论：

- 当且仅当` n != 4^k*(8m+7)` 时，`n` 可以被表示为至多三个正整数的平方和。因此，当`n =4^k*(8m+7)`时， n 只能被表示为四个正整数的平方和，此时可以直接返回4





```c++
class Solution {
public:
    // 判断是否为完全平方数
    bool isPerfectSquare(int x) {
        int y = sqrt(x);
        return y * y == x;
    }

    // 判断是否能表示为 4^k*(8m+7)
    bool checkAnswer4(int x) {
        while (x % 4 == 0) {
            x /= 4;
        }
        return x % 8 == 7;
    }

    int numSquares(int n) {
        if (isPerfectSquare(n)) {
            return 1;
        }
        if (checkAnswer4(n)) {
            return 4;
        }
        for (int i = 1; i * i <= n; i++) {
            int j = n - i * i;
            if (isPerfectSquare(j)) {
                return 2;
            }
        }
        return 3;
    }
};
```



# [73. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

**从数组头部开始，往后寻找非0元素，并依次从头部开始填充**

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.empty()) return;
        int i = 0, j = 0;
        while(j < nums.size()){
            if(nums[j] == 0)
                j++;
            else
                nums[i++] = nums[j++];
        }
        if(i < nums.size()){
            for(int k = i;k < nums.size(); k++)
                nums[k] = 0;
        }
            
    }
};
```



# [74. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

**一个萝卜一个坑，将每个数字都放到它应在的位置上，若交换时发现位置上的数与自己相同，则重复**

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0; i < n; i++){
            while(nums[i] != i + 1 && nums[nums[i] - 1] != nums[i]){
                swap(nums[i], nums[nums[i] - 1]);
            }
            if(nums[i] != i + 1 && nums[nums[i] - 1] == nums[i])
                return nums[i];
        }
        return 0;
    }
};
```

**快慢指针**

与判断是否环形链表思想相同，利用快慢指针，当链表存在环时，两指针一定会在环上某点相遇，此时我们再将slow放置起点，两指针每次移动一步，相遇点就是答案

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```

# [75. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

## 1. 序列化

利用层序遍历，将二叉树中的所有节点都打印出来，**包括叶子节点的左右孩子即空节点**

- 遇到空节点时，用字符`#`表示
- 节点与节点之间用`,`分离

```c++
string serialize(TreeNode* root) {
        string res;
        if(!root) return res;
        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty())
        {
            TreeNode* cur = q.front();
            q.pop();
            if(!cur)
            {
                res += '#';
                res += ',';
            }
            else{
                res += to_string(cur->val);
                res += ',';
                q.push(cur->left);
                q.push(cur->right);
            }
        }
        return res;
    }
```

## 2. 反序列化

对于层序遍历序列，**一个节点与其左右孩子节点的位置是固定的**,对于一个二叉树层序遍历结果`[1,2,3,null,null,4,5]`

- 根节点的左右孩子为`2,3`，**在数组中的下标分别为1，2**，

- 而`2`的左右孩子节点为`null,null`，**在数组中的下标分别为3，4**,  
- `3`的左右孩子节点为`4,5`，**在数组中的下标分别为5，6**

可以明显看出每个节点的左右子树下标从1开始自增，对此可以用一下代码来表示

```c++
int pos = 1;
for(int i = 0; i < v.size(); ++i)
{
    if(v[i] == nullptr)
    continue;
    v[i]->left = v[pos++];
    v[i]->right = v[pos++];
}
```

**首次错误提交*

```c++
  TreeNode* deserialize(string data) {
        if(data.empty()) return nullptr;
        vector<TreeNode*> v;
        for(auto s : data)
        {
            if(s == ',') continue;
            if(s == '#'){
                v.push_back(nullptr);
            }
            else{
                TreeNode* node = new TreeNode(s - '0');
                v.push_back(node);
            }
        }

        int pos = 1;
        for(int i = 0; i < v.size(); ++i)
        {
            if(v[i] == nullptr)
                continue;
            v[i]->left = v[pos++];
            v[i]->right = v[pos++];
        }
        return v[0];
    }
```

**我的这段代码出错出在对字符串的处理，我的想法是对字符串的每一个字符进行提取，这种想法就默认了一个字符代表一个数字，即当出现负数或者两位数时，提取的字符就是错的，因此对该部分要进行修改：因为数字之间用逗号隔开，因此两个逗号之间的所有字符合在一起才是一个完整的数字**

```c++
 TreeNode* deserialize(string s) {
        if(s.empty()) return nullptr;
        vector<TreeNode*> v;
        for(int i = 0; i < s.size(); i++)
        {
            //遇到逗号跳过
            if(s[i] == ',') continue;
            //遇到'#'就加入空指针
            else if(s[i] == '#')
                v.push_back(nullptr);
            else{
                //定义一个字符用来提取数字
                string temp = "";
                int j = i;
                while(s[j] != ','){
                    temp += s[j];
                    j++;
                }
                TreeNode * node = new TreeNode (stoi(temp));
                v.push_back(node);
                i = j;
            }
        }

        int pos = 1;
        for(int i = 0; i < v.size(); ++i)
        {
            if(v[i] == nullptr)
                continue;
            v[i]->left = v[pos++];
            v[i]->right = v[pos++];
        }
        return v[0];
    }
```

**以上的字符提取过程还可以进行修改**

```c++
		int j = 0;
        while(j < data.size())
        {
            string stmp = "";
            while(data[j] != ',')
            {
                stmp += data[j];
                j++;
            }

            if(stmp == "#")
            {
                nodes.push_back(nullptr);
            }
            else
            {
                int tmp = atoi(stmp.c_str());
                TreeNode* newnode = new TreeNode(tmp);
                nodes.push_back(newnode);
            }
            j++;
        }
```



# [76. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

**动态规划：**

- `dp[i]:`以 `nums[i]`结尾的最长递增子序列
- 转移方程：遍历`nums[0] ~ nums[i-1]`
  - 若存在`nums[j] < nums[i]`,则`dp[i] = dp[j] + 1`
  - 在遍历过程中`dp[i]`的值是不断更新的，因此更新时还要与原值比较，因此
  - `dp[i] = max(dp[i], dp[j] + 1)`



```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result) result = dp[i]; // 取长的子序列
        }
        return result;
    }
};
```



# [77. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

**回溯：**

- 遍历字符串，求出**需要删除的左括号最小数量**`lremove`和**需要删除的右括号最小数量**`rremove`
- 尝试在字符串中去删除对应的左括号数量和右括号数量，若删除后字符串合理，则加入结果集



```c++
class Solution {
public:
    vector<string> res;
    vector<string> removeInvalidParentheses(string s) {
        int lremove = 0;
        int rremove = 0;

        for (char c : s) {
            if (c == '(') {
                lremove++;
            } else if (c == ')') {
                if (lremove == 0) {
                    rremove++;
                } else {
                    lremove--;
                }
            }
        }
        helper(s, 0, 0, 0, lremove, rremove);
        return res;
    }

    void helper(string str, int start, int lcount, int rcount, int lremove, int rremove) {
        if (lremove == 0 && rremove == 0) {
            if (isValid(str)) {
                res.push_back(str);
            }
            return;
        }

        for (int i = start; i < str.size(); i++) {
            if (i != start && str[i] == str[i - 1]) {
                continue;
            }
            // 如果剩余的字符无法满足去掉的数量要求，直接返回
            if (lremove + rremove > str.size() - i) {
                return;
            } 
            // 尝试去掉一个左括号
            if (lremove > 0 && str[i] == '(') {
                helper(str.substr(0, i) + str.substr(i + 1), i, lcount, rcount, lremove - 1, rremove);
            }
            // 尝试去掉一个右括号
            if (rremove > 0 && str[i] == ')') {
                helper(str.substr(0, i) + str.substr(i + 1), i, lcount, rcount, lremove, rremove - 1);
            }
            if (str[i] == ')') {
                lcount++;
            } else if (str[i] == ')') {
                rcount++;
            }
            // 当前右括号的数量大于左括号的数量则为非法,直接返回.
            if (rcount > lcount) {
                break;
            }
        }
    }

    inline bool isValid(const string & str) {
        int cnt = 0;

        for (int i = 0; i < str.size(); i++) {
            if (str[i] == '(') {
                cnt++;
            } else if (str[i] == ')') {
                cnt--;
                if (cnt < 0) {
                    return false;
                }
            }
        }

        return cnt == 0;
    }
};
```



# [78. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

## DP方法一：

- 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
- 卖出股票状态，这里就有两种卖出股票状态
  - 状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
  - 状态三：今天卖出了股票
- 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

**状态转移：**

1. 状态一：买入股票
   - 保持昨日买入股票状态,`dp[i][0] = dp[i-1][0]`
   - 昨天是冷冻期，今天买入,`dp[i][0] = dp[i-1][3] - prices[i]`
   - 两天前就卖出了股票，度过了冷冻期，今日买入,`dp[i][0] = dp[i-1][1] - prices[i]`
   - `dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);`
2. 状态二：保持卖出股票状态
   - 昨天就是状态二，今天保持，`dp[i][1] = dp[i-1][1]`
   - 前一天是冷冻期，`dp[i][1] = dp[i-1][3]`
   - `dp[i][1] = max(dp[i-1][1], dp[i-1][3])`
3. 状态三：今天卖出股票
   - 昨天一定是买入股票状态（不论是否是昨天当天购买）`dp[i-1][2] = dp[i-1][0] + prices[i]`
4. 状态四：今天是冷冻期
   - 昨天卖出股票 ，`dp[i][3] = dp[i-1][2]`

**代码：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3],max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```



## DP方法二：

**`dp[i]:`第 i 天结束之后的累计最大收益**

- 状态一：第 i 天结束之后持有一支股票
  - 前一天就持有，`dp[i][0] = dp[i-1][0]`
  - 今天买入，则前一天不能处于冷冻期，`dp[i][0] = dp[i-1][2] - prices[i]`
  - `dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])`
- 目前不持有股票：
  - 状态二：第` i` 天结束之后处于冷冻期
    - 即在第` i `天卖出了股票，则第 `i - 1`天必须持有股票`dp[i][1] = dp[i-1][0] + prices[i]`
  - 状态三：第 i 天结束之后不处于冷冻期
    - 即第 `i - 1`天不持有股票
      - 第 `i - 1`天处于冷冻期，`dp[i][2] = dp[i-1][1]`
      - 第 `i - 1`天不处于冷冻期，`dp[i][2] = dp[i-1][2]`
      - `dp[i][2] = max(dp[i-1][1], dp[i-1][2])`
- **综上：`res = max(dp[n-1][0], dp[n-1][1], dp[n-1][2])`**

**代码：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }

        int n = prices.size();
        // f[i][0]: 手上持有股票的最大收益
        // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
        // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
        vector<vector<int>> dp(n, vector<int>(3));
        dp[0][0] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
            dp[i][1] = dp[i - 1][0] + prices[i];
            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]);
        }
        return max(dp[n - 1][1], f[n - 1][2]);
    }
};
```



# [79. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

**首先，为了方便处理，先将数组首尾各插入一个 1 **

如果按照题目要求戳气球，则会导致两个气球从不相邻变为相邻，使得后续操作难以处理，因此我们可以将这些操作倒过来看，将全程看作是每次添加一个气球。

`dp[i][j]:`填满开区间`(i, j)`能得到的最多硬币数

**状态转移：**

假设最后戳破的气球下标为 `k`,则戳破气球 k 时可以得到的硬币数为：

​	`dp[i][j] = val[i] * val[k] * val[j] + dp[i][k] + dp[k][j]`

**注意事项：**

由转移方程可以看出，数组的遍历顺序是要从后往前的，对于区间`(i ,j)`，求`dp[i][j]`时需要知道`dp[i][i+1]、dp[i+k][j]....`的值，因此对于`i`需要从后往前遍历

```c++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<int> val(n + 2 ,0);
        val[0] = val[n+1] = 1;
        for(int i = 0; i < n; i++){
            val[i+1] = nums[i];
        }

        vector<vector<int>> dp(n+2, vector<int>(n+2,0));
        for(int i = n - 1; i >= 0; i--){
            for(int j = i + 2; j < n + 2; j++){
                for(int k = i + 1; k < j; k++){
                    int sum = val[i] * val[k] * val[j];
                    sum += dp[i][k] + dp[k][j];
                    dp[i][j] = max(dp[i][j], sum);
                }
            }
        }
        return dp[0][n+1];
    }
};
```



# [80. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

**背包问题**

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过
                    dp[j] = min( dp[j],dp[j - coins[i]] + 1);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```



# [81. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

```c++
class Solution {
public:
    int rob(TreeNode* root) {
        if(!root) return 0;
        vector<int> res = robTree(root);
        return max(res[0],res[1]);
    }
    vector<int> robTree(TreeNode* root)
    {
        if(!root) return vector<int>{0,0};
        vector<int> left = robTree(root->left);
        vector<int> right = robTree(root->right);
        int val1 = root->val + left[0] + right[0];
        int val2 = max(left[0],left[1]) + max(right[0],right[1]);

        return vector<int>{val2,val1};
    }
};
```



# [82. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

**Brian Kernighan算法：**

- 对于任意整数x, 令 `x = x & (x - 1)`，该运算将 `x`的二进制表示的最后一个 `1`变成`0`，因此，对`x`重复该操作，直到其变为 0 ，则操作次数即为答案

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> res;
        for(int i = 0; i <= n; i++){
            int cnt = 0;
            int x = i;
            while(x){
                x &= (x - 1);
                cnt++;
            }
            res.push_back(cnt);
        }
        return res;
    }
};
```



**最低有效位：**

​		所有整数可以分为奇数和偶数

- 对于奇数x而言，其二进制表示比偶数 x - 1 多一个 1，即多二进制表示的末尾的 1
- 对于偶数x而言，其二进制表示的末尾一定为 0 ，因此将其右移一位，即除以 2之后，两数二进制所含1的个数相同，因为仅仅是去除了末尾的那个 1

**因此可以根据奇偶性开始遍历：**

```c++
class Solution {
public:
    vector<int> countBits(int num) {
        int i = 1;
        vector<int> ans(num + 1);
        for (int i = 0; i <= num; i++) {
            if (i % 2 == 0) 
                ans[i] = ans[i / 2];
            else 
                ans[i] = ans[i / 2] + 1;
        }
        return ans;
    }
};
```



# [83. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

首先用哈希表记录每个元素出现的次数，形成一个出现次数数组，问题即变为找出出现次数数组的前 k 大的值

## **堆排序：**

- 建立小顶堆，遍历 次数数组
- 如果堆的元素个数小于 k,则直接插入
- 如果堆的元素个数等于 k,则检查堆顶元素与当前元素的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中
- 最终堆中的元素就代表了 前 k 大的值

```c++
class Solution {
public:
    static bool cmp(pair<int, int>& m, pair<int, int>& n) {
        return m.second > n.second;
    }

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> occurrences;
        for (auto& v : nums) {
            occurrences[v]++;
        }

        // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);
        for (auto& [num, count] : occurrences) {
            if (q.size() == k) {
                if (q.top().second < count) {
                    q.pop();
                    q.emplace(num, count);
                }
            } else {
                q.emplace(num, count);
            }
        }
        vector<int> ret;
        while (!q.empty()) {
            ret.emplace_back(q.top().first);
            q.pop();
        }
        return ret;
    }
};
```



****

## 快速排序：

与[62. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)有异曲同工之妙，该题其实就是求 出现次数数组的前 K 个最大元素

```c++
class Solution {
public:
    void qsort(vector<pair<int, int>>& v, int start, int end, vector<int>& ret, int k) {
        int picked = rand() % (end - start + 1) + start;
        swap(v[picked], v[start]);

        int pivot = v[start].second;
        int index = start;
        for (int i = start + 1; i <= end; i++) {
            if (v[i].second >= pivot) {
                swap(v[index + 1], v[i]);
                index++;
            }
        }
        swap(v[start], v[index]);

        if (k <= index - start) {
            qsort(v, start, index - 1, ret, k);
        } else {
            for (int i = start; i <= index; i++) {
                ret.push_back(v[i].first);
            }
            if (k > index - start + 1) {
                qsort(v, index + 1, end, ret, k - (index - start + 1));
            }
        }
    }

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> occurrences;
        for (auto& v: nums) {
            occurrences[v]++;
        }

        vector<pair<int, int>> values;
        for (auto& kv: occurrences) {
            values.push_back(kv);
        }
        vector<int> ret;
        qsort(values, 0, values.size() - 1, ret, k);
        return ret;
    }
};

```



# [84. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

**本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应**

**思路：**

- 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈
- 如果当前的字符为字母或者左括号，直接进栈
- 如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字，就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈

**算法具体流程：**

构建辅助栈` stack`， 遍历字符串`s `中每个字符`c`；

- 当 `c `为数字时，将数字字符转化为数字 `multi`，用于后续倍数计算；
- 当` c `为字母时，在 res 尾部添加` c`；
- 当 `c `为` [ `时，将当前 `multi `和` res` 入栈，并分别置空置` 0`
  - 记录此` [ `前的临时结果` res `至栈，用于发现对应` ]` 后的拼接操作；
  - 记录此` [ `前的倍数 `multi `至栈，用于发现对应 `] `后，获取 `multi × [...] `字符串。
  - 进入到新 `[ `后，`res` 和 `multi `重新记录。
- 当 `c` 为 `] `时，`stack `出栈，拼接字符串 `res = last_res + cur_multi * res`，其中:
  - `last_res`是上个 `[ `到当前` [ `的字符串，例如 `"3[a2[c]]" `中的 `a`；
  - `cur_multi`是当前 `[ `到` ] `内字符串的重复倍数，例如 `"3[a2[c]]" `中的 `2`。
- 返回字符串 `res`

```c++
class Solution {
public:
    string decodeString(string s) {
	//两个栈分别压int res和用pair
	stack<pair<int, string>> sta;
	int num = 0; string res = "";
	//循环检查字符串
	for (int i = 0; i < s.size(); i++) {
		//遇到数字则存入num
		if (s[i] >= '0'&&s[i] <= '9') {
			num *= 10;
			num += (s[i] - '0');//这里括号是否需要
		}
		else if (s[i] == '[') {//遇到[压栈数字和字符串，置零置空
			sta.push(make_pair(num, res));
			num = 0;
			res = "";
		}
		else if (s[i] == ']') {//遇到]出栈数字和字符串，组装
			int n = sta.top().first;//n指示的是res的循环次数，不是a的
			string a = sta.top().second;
			sta.pop();
			for (int i = 0; i < n; i++)  a = a + res; //循环n次
			res = a;
		}
		else {//遇到字符存入字符
			res += s[i];
		}		
	}
	return res;
}
};
```



# *[85. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)



# [86. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

**首先将身高作为第一关键字按照从高到低进行排序，将另一要素作为第二关键字按照升序排列，然后进行插入排序**

**定义一个新的队列，从头遍历排序后数组，将数组元素插入新队列中**

- 假如队列中已排序完成 `i`个元素，对于第`i + 1`个元素，取`int n = people[i+1][1]`,插入对于第`i + 1`个元素时，因此该元素的身高均小于队列中已排好的元素，因此该元素的插入位置不会影响已排好序元素，因此只需要按照`n`值寻找插入位置即可

  ```c++
  int position = people[i][1];
  auto iter = res.begin();
  while (position--) { // 寻找在插入位置
      iter++;
  }
  res.insert(iter, people[i]);
  ```

- 考虑到使用的是**插入**的方法进行排序，因此使用**链表结构**

**代码：**

```c++
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        //使用链表
        list<vector<int>> res;
        sort(people.begin(),people.end(),[&](const vector<int>& a, const vector<int>& b){
            if(a[0] == b[0]) return a[1] < b[1];
            return a[0] > b[0];
        });
        for(int i = 0; i < people.size(); i++)
        {
            int position = people[i][1];
            auto iter = res.begin();
            while (position--) { // 寻找在插入位置
                iter++;
            }
            res.insert(iter, people[i]);
        }
        vector<vector<int>> ans(res.begin(),res.end());
        return ans;
    }
};
```

**也可以直接使用数组的插入功能**

```c++
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(),people.end(),[&](const vector<int>& a, const vector<int>& b){
            if(a[0] == b[0]) return a[1] < b[1];
            return a[0] > b[0];
        });
        vector<vector<int>> ans;
        for (const vector<int>& person: people) {
            ans.insert(ans.begin() + person[1], person);
        }
        return ans;
    }
};
```



# [87. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

**动态规划：背包问题**



```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x : nums)  sum += x;
        if(sum % 2 == 1) return false;
        int con = sum / 2;

        vector<int> dp(con+1,0);

        for(int i = 0; i < n; i++){
            for(int j = con; j >= nums[i]; j--){  
                dp[j] = max(dp[j],dp[j-nums[i]] + nums[i]);
            }
        }
        if(dp[con] == con) return true;
        return false;
    }
};
```



# [88. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

**回溯**

```c++
class Solution {
public:
   int dfs(TreeNode* root, int targetSum){
        if(!root) return 0;
        int res = 0;
        if(root->val == targetSum){
            res++;
        }

        res += dfs(root->left, targetSum - root->val);
        res += dfs(root->right, targetSum - root->val);

        return res;
    }
    int pathSum(TreeNode* root, int targetSum) {
        if(!root) return 0;
        int res = 0;
        res += dfs(root, targetSum);

        res += pathSum(root->left, targetSum);
        res += pathSum(root->right, targetSum);

        return res;
    }
};

```

**前缀和**

```c++
class Solution {
private:
    unordered_map<int, int> prefix;         // <前缀和，其出现次数>
    void dfs(TreeNode* root, int sum, int cur_sum, int& res)
    {
        if (!root) return;
        cur_sum += root->val;               // 更新前缀和
        // 当前路径中存在以当前节点为终点的和为sum的子路径
        if (prefix.find(cur_sum - sum) != prefix.end())
            res += prefix[cur_sum - sum];
        prefix[cur_sum]++;                  // 将当前节点加入路径
        dfs(root->left, sum, cur_sum, res); // 在其左子树中递归寻找
        dfs(root->right, sum, cur_sum, res);// 在其右子树中递归寻找
        prefix[cur_sum]--;                  // 回溯
    }
public:
    int pathSum(TreeNode* root, int sum) 
    {
        int res = 0;    // 满足条件的路径数量
        prefix[0] = 1;  // 前缀和为0的路径只有一条：哪个节点都不选
        dfs(root, sum, 0, res);
        return res;
    }
};

```



# [89. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

滑动窗口

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int ns = s.size();
        int np = p.size();
        if(ns < np) return vector<int>{};
        vector<int> vs(26,0);
        vector<int> vp(26,0);
        vector<int> res;

        for(int i = 0; i < np; i++){
            vs[s[i] - 'a']++;
            vp[p[i] - 'a']++;
        }
        if(vs == vp) res.push_back(0);

        for(int i = 0; i < ns - np;i++)
        {
            //每次减去头字母
            vs[s[i] - 'a']--;
            //加入一个新字母
            vs[s[i + np] - 'a']++;
            if(vs == vp) res.push_back(i+1);
        }
        return res;
    }
};
```



# [90. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

**优化的哈希表：利用数组充当哈希表，因为数组中每一个元素都是[1,n]的，因此遍历数组时，令元素`nums[i]`对应的下标`nums[i]-1`所代表的元素加 `n`，遍历完成后，所有出现的元素所代表的下标指向的元素应该都是大于n的，若小于等于n,则说明该下标所代表的元素没有出现**

**注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n 取模来还原出它本来的值。**

```c++
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        for (auto& num : nums) {
            int x = (num - 1) % n;
            nums[x] += n;
        }
        vector<int> ret;
        for (int i = 0; i < n; i++) {
            if (nums[i] <= n) {
                ret.push_back(i + 1);
            }
        }
        return ret;
    }
};
```



# [91. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

**两数异或运算后，结果中 1 的数量就是汉明距离**

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int res = 0;
        int a = x^y;
        while(a)
        {
            res += (a & 1);
            a >>= 1;
        }
        return res;
    }
};
```

**Brian Kernighan 算法**

对于任意整数x, 令 `x = x & (x - 1)`，该运算将 `x`的二进制表示的最后一个 `1`变成`0`，因此，对`x`重复该操作，直到其变为 0 ，则操作次数即为x所含 1 的个数

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int res = 0;
        int a = x^y;
        while(a)
        {
            a &= (a -1);
            res++;
        }
        return res;
    }
};
```



# [92. 目标和](https://leetcode-cn.com/problems/target-sum/)

### 思路：

**目标和为target, 所有元素之和为sum，假设加法对应的总和为x，则减法对应的总和为 sum - x,**

**则有x - (sum - x) = target， 即 x = (target + sum) / 2, 因此只要给定数组中有相加之和为x 的一组元素，则代表有一组解**

### 暴力解法（回溯）

```c++
class Solution {
public:
    int res;
    void backTracking(vector<int>& nums, int target,int sum, int startIndex)
    {
        if(sum == target){
            res++;
        }
        for(int i = startIndex; i < nums.size() && sum + nums[i] <= target; i++){
            sum += nums[i];
            backTracking(nums,target,sum,i+1);
            sum -= nums[i];
        }
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int sum = 0;
        for(auto x : nums) sum += x;
        if(target > sum ) return 0;
        if((target + sum) % 2 == 1) return 0;
        int x = (target + sum) / 2;
        

        backTracking(nums,x,0,0);
        return res;
    }
};
```

**在判断终止条件处要注意，满足条件时并未return，而是继续递归，因为当给定数组中有重复0时，继续相加的结果不变，但元素个数增加了一个，因此也算一种答案**

```c++
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
0
```



### 动态规划

**考虑转化为01背包问题**

- 背包容量为 x = (target + sum) / 2
- 物品体积以及价值均为num[i]
- 物品数量为nums.size()
- dp[i]表示填满容量为i的背包有dp[i]种方法

**该公式在利用背包解决排列组合问题时经常会用到**

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(S) > sum) return 0; // 此时没有方案
        if ((S + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (S + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```



# [93. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

**确定遍历顺序，首先，这是一棵二叉搜索树：**

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树

**因此，遍历顺序应该是 右根左，然后进行累加**

```c++
class Solution {
public:
    int sum;
    void dfs(TreeNode* root){
        if(!root) return;
        dfs(root->right);

        root->val += sum;
        sum = root->val;

        dfs(root->left);
    }
    TreeNode* convertBST(TreeNode* root) {
        if(!root) return root;
        dfs(root);
        return root;
    }
};
```



# [94. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

- 以某节点为根节点，其左右子树最大深度分别为L，R
- 则以其为根节点的二叉树直径为 L + R
- 该题就是遍历二叉树，分别以所有节点为根节点求出直径，并记录最大直径

```c++
class Solution {
public:
    int res ;
    int dfs(TreeNode* root){
        if(!root) return 0;

        int left = dfs(root->left);
        int right = dfs(root->right);

        res = max(res, left + right);
        return max(left, right) + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        if(!root) return 0;
        dfs(root);
        return res;
    }
};
```



# [95. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

**前缀和**

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        //一定要初始化mp[0] = 1,用于首次找到满足条件子数组时的计数
        mp[0] = 1;
        int count = 0, pre = 0;
        for (auto& x:nums) {
            pre += x;
            if (mp.find(pre - k) != mp.end()) {
                count += mp[pre - k];
            }
            mp[pre]++;
        }
        return count;
    }
};
```



# [96. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

**方法一：将数组排序后与原数组比较**

```c++

class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        if (is_sorted(nums.begin(), nums.end())) {
            return 0;
        }
        vector<int> numsSorted(nums);
        sort(numsSorted.begin(), numsSorted.end());
        int left = 0;
        while (nums[left] == numsSorted[left]) {
            left++;
        }
        int right = nums.size() - 1;
        while (nums[right] == numsSorted[right]) {
            right--;
        }
        return right - left + 1;
    }
};
```

**方法二：一次遍历**

将数组分为前中后三部分，前端和后端数组都是有序的，中间的数组是无序，并且，**前端数组的所有元素均小于中部数组，后端数组的所有元素均大于中部数组**

因此：

- 从前往后遍历，维护一个**最大值**，作为中部数组的**右**边界
  - 进入后端数组之前，所有元素都小于该最大值
    - 若`max < nums[i]`，就更新`max`
    - 若`max > nums[i] `，就更新右边界right
  - 进入后端数组之后，则一直更新`max`值，`right`值则不会更新
- 从后往前遍历，维护一个**最小值**，作为中部数组的**左**边界

**代码：**

```c++
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int n = nums.size();
        int maxx = INT_MIN;
        int minn = INT_MAX;
        int left = -1, right = -1;
        for(int i = 0; i < nums.size(); i++)
        {
            //从左到右寻找右边界right
            if(nums[i] < maxx)
                right = i;
            else
                maxx = nums[i];

            //从右到左寻找左边界left
            if(nums[n - i - 1] > minn)
                left = n - i - 1;
            else
                minn = nums[n-i-1];
        }

        return right == -1 ? 0 : right - left + 1;
    }
};
```



# [97. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;
        if(!root2) return root1;
        TreeNode* root = new TreeNode;
        root->val = root1->val + root2->val;
        root->left=mergeTrees(root1->left,root2->left);
        root->right = mergeTrees(root1->right,root2->right);
        return root;
    }
};
```

**迭代**

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == nullptr) {
            return t2;
        }
        if (t2 == nullptr) {
            return t1;
        }
        auto merged = new TreeNode(t1->val + t2->val);
        auto q = queue<TreeNode*>();
        auto queue1 = queue<TreeNode*>();
        auto queue2 = queue<TreeNode*>();
        q.push(merged);
        queue1.push(t1);
        queue2.push(t2);
        while (!queue1.empty() && !queue2.empty()) {
            auto node = q.front(), node1 = queue1.front(), node2 = queue2.front();
            q.pop();
            queue1.pop();
            queue2.pop();
            auto left1 = node1->left, left2 = node2->left, right1 = node1->right, right2 = node2->right;
            if (left1 != nullptr || left2 != nullptr) {
                if (left1 != nullptr && left2 != nullptr) {
                    auto left = new TreeNode(left1->val + left2->val);
                    node->left = left;
                    q.push(left);
                    queue1.push(left1);
                    queue2.push(left2);
                } else if (left1 != nullptr) {
                    node->left = left1;
                } else if (left2 != nullptr) {
                    node->left = left2;
                }
            }
            if (right1 != nullptr || right2 != nullptr) {
                if (right1 != nullptr && right2 != nullptr) {
                    auto right = new TreeNode(right1->val + right2->val);
                    node->right = right;
                    q.push(right);
                    queue1.push(right1);
                    queue2.push(right2);
                } else if (right1 != nullptr) {
                    node->right = right1;
                } else {
                    node->right = right2;
                }
            }
        }
        return merged;
    }
};
```



# [98. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

**桶思想：**

**对于冷却时间`n`，我们设计桶的容量为`n+1`，则在一个桶内不可能出现相同的任务。**

对于重复的任务，只能将其放入不同的桶中，因此，**桶的个数就是重复次数最多的任务的个数**

除最后一个桶，每个桶占用的时间都是`n+1`，对于最后一个桶，它有可能没有放满，因此其占用时间为桶中任务数量

- **总时间 = (桶数量 - 1) * (n + 1) + 最后一个桶的任务数**
  - **(桶数量 - 1)**：代表除了最后一个桶以外的所有桶
  - **(n + 1)** ：代表每个桶的容量
  - 对于最后一个桶，它有可能没有放满，因此其占用时间为桶中任务数量，**因此最后加上最后一个桶的任务数**

**还有一种特殊情况，当任务种类很多，但重复率较低时，可能出现桶不够用的情况**

- 此时可以临时扩充某些桶的大小
- 这种情况下，每个任务之间不存在空余时间，时间被填满了，因此总时间就是总的任务数



**算法流程：**

1. 找出最大任务数`N`，找出任务数量并列最多的任务数量`X`，即最后一个桶的任务数，则`num1 = (N-1)*(n+1) + x`
2. 计算任务总数`num2`
3. 输出较大值

```c++
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        int N = tasks.size();
        int cnt = 0;
        vector<int> vec(26,0);
        for(auto task : tasks) vec[task - 'A']++;
        sort(vec.begin(), vec.end(), [&](const int& a, const int& b){
            return a > b;
        });
        while(cnt < vec.size() && vec[cnt] == vec[0]) cnt++;

        return max(N, (n+1)*(vec[0]-1) + cnt);
    }
};
```



# [99. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

**动态规划：**

`dp[i][j]`: 区间`[i,j]`内的子字符串是否为回文子串

1. `s[i] != s[j]: dp[i][j] = false`
2. `s[i] == s[j]`:
   - `i == j: dp[i][j] = true`
   - `i = j - 1 : dp[i][j] = true`
   - `dp[i+1][j-1] == true: dp[i][j] = true`

**遍历顺序：由于计算`dp[i][j]`时会用到`dp[i+1][j-1]`，因此对于 i 的遍历要从大到小**

**代码：**

```c++
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int result = 0;
        for (int i = s.size() - 1; i >= 0; i--) {  // 注意遍历顺序
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (j - i <= 1) { // 情况一 和 情况二
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { // 情况三
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return result;
    }
};
```



**中心扩展法**

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int result = 0;
        for (int i = 0; i < s.size(); i++) {
            result += extend(s, i, i, s.size()); // 以i为中心
            result += extend(s, i, i + 1, s.size()); // 以i和i+1为中心
        }
        return result;
    }
    int extend(const string& s, int i, int j, int n) {
        int res = 0;
        while (i >= 0 && j < n && s[i] == s[j]) {
            i--;
            j++;
            res++;
        }
        return res;
    }
};
```



```c++
class Solution {
public:
    int countSubstrings(string s) {
        int res = 0;
        int len = s.size();
        //单个中心点为len个,双个中心点为len-1个，因此遍历2len-1次
        for(int i = 0;i<2*len -1;i++)
        {
            int left = i/2;
            int right = left + i%2;
            while(left>=0 && right < len && s[left] == s[right])
            {
                left--;
                right++;
                res++;
            }
        }
        return res;
    }
};
```



# [100. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

**单调栈**

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int size = temperatures.size();
        vector<int> res(size, 0);
        stack<int> s;
        for(int i = 0; i < size; i++)
        {
            while(!s.empty() && temperatures[i] > temperatures[s.top()]){
                res[s.top()] = i - s.top();
                s.pop();
            }
            s.push(i);
        }
        return res;
    }
};
```



