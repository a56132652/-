# 1. 二分查找

[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

于我个人而言，二分查找的难点在于：

```c++
while(l < r) || while(l <= r)

r = mid || r = mid - 1;
l = mid || l = mid + 1;

```

**写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)**

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

```c++
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};

```

```cpp
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```



# 2. 搜索插入位置

[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l = 0, r =nums.size() - 1;
        int res = 0;
        while(l <= r){
            int mid = l + r >> 1;
            if(nums[mid] > target){
                r = mid - 1;
            }else if(nums[mid] < target){
                l = mid + 1;
            }else{
                return mid;
            }
        }
        return l;
    }
};
```

## Carl哥做法

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle;
            }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前  [0, -1]
        // 目标值等于数组中某一个元素  return middle;
        // 目标值插入数组中的位置 [left, right]，return  right + 1
        // 目标值在数组所有元素之后的情况 [left, right]， return right + 1
        return right + 1;
    }
};

class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n; // 定义target在左闭右开的区间里，[left, right)  target
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在 [middle+1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值的情况，直接返回下标
            }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前 [0,0)
        // 目标值等于数组中某一个元素 return middle
        // 目标值插入数组中的位置 [left, right) ，return right 即可
        // 目标值在数组所有元素之后的情况 [left, right)，return right 即可
        return right;
    }
};
```

#### 

# 3. 在排序数组中查找元素的第一个和最后一个位置

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

该题要注意对该元素的左右边界分别用二分进行查找，而这两种二分的判断条件要特别注意

对于左边界left,其左边的数均小于target

```c++
//该二分结束后，左边界 l 为target 的左边界
while(l <= r)
{
    int mid = l + r >> 1;
    //特别注意此处是 大于等于 >=
    if(nums[mid] >= target)
        r = mid - 1;
    else
        l = mid + 1;
}
```

对于右边界right,其右边的数均大于target

```c++
//该二分结束后，右边界 r 为target 的右边界
while(l <= r)
{
	int mid = l + r >> 1;
    //特别注意此处是 小于等于 <=
    if(nums[mid] <= target)
        l = mid + 1;
    else
        r = mid - 1;
}
```

## 完整代码

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> res{-1,-1};
        if(nums.empty()) return res;
        int l = 0, r = nums.size() - 1;
        while(l <= r){
            int mid = (l + r)/2;
            if(nums[mid] >= target){
                r = mid - 1;
            }else{
                l = mid + 1;
            }
        }
        if(l >= nums.size() || nums[l] != target){
            return res;
        }
        else{
            res.clear();
            res.push_back(l);
            int i = 0, j = nums.size() - 1;
            while(i <= j){
                int mid = i + j >> 1;
                if(nums[mid] <= target){
                    i = mid + 1;
                }else{
                    j = mid - 1;
                }
            }
            res.push_back(j);
        }
        return res;
    }
};
```



# 4. Sqrt(x)

[69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)

```c++
class Solution {
public:
    int mySqrt(int x) {
        int l = 0, r = x;
        while (l <= r) {
            int mid = l + r >> 1;
            if ((long long)mid * mid <= x) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return r;
    }
};
```

**对于返回值为什么是返回右边界 r 一定要想清楚**

因此判断条件是 

```c++
 if ((long long)mid * mid <= x) {
	l = mid + 1;
```

按照此条件进行判断，最终得到的有边界r,其右边的数均大于 mid* mid,因此 r 是满足条件的最大值

# 5. 有效的完全平方数

[367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int l = 0, r = num;
        while(l <= r)
        {
            long long mid = l + r >> 1;
            if(mid * mid > num)
                r = mid - 1;
            else if(mid * mid < num)
                l = mid + 1;
            else
                return true;
        }
        return false;
    }
};
```





