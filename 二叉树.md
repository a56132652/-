# 1. 二叉树定义

**牢记，以防手撕代码**

```c++
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x): val(x), left(nullptr), right(nullptr){}
};
```



# 2. 二叉树的迭代遍历

## 1) 前序遍历

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> sta;
        if(root != nullptr) sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            result.push_back(node->val);
            if(node->right) sta.push(node->right);
            if(node->left) sta.push(node->left);
        }
        return result;
    }
};
```

## 2) 中序遍历

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> sta;
        vector<int> res;
        if(!root) return res;
        TreeNode* cur = root;
        while(!sta.empty() || cur != nullptr)
        {
            if(cur != nullptr)
            {
                sta.push(cur);
                cur = cur->left; 
            }else{
                TreeNode* temp = sta.top();
                sta.pop();
                res.push_back(temp->val);
                cur = temp->right;
            }
        }
        return res;
    }
};
```

## 3) 后序遍历

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
      vector<int> result;
        stack<TreeNode*> sta;
        if(root != nullptr) sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            result.push_back(node->val);
            if(node->left) sta.push(node->left);
            if(node->right) sta.push(node->right);
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
```

## 4) 统一迭代法

- 中序遍历

  - ```c++
    class Solution {
    public:
        vector<int> inorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            if (root != NULL) st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();
                if (node != NULL) {
                    st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                    if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）
    
                    st.push(node);                          // 添加中节点
                    st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。
    
                    if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
                } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                    st.pop();           // 将空节点弹出
                    node = st.top();    // 重新取出栈中元素
                    st.pop();
                    result.push_back(node->val); // 加入到结果集
                }
            }
            return result;
        }
    };
    ```

- 前序遍历

  - ```c++
    class Solution {
    public:
        vector<int> preorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            if (root != NULL) st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();
                if (node != NULL) {
                    st.pop();
                    if (node->right) st.push(node->right);  // 右
                    if (node->left) st.push(node->left);    // 左
                    st.push(node);                          // 中
                    st.push(NULL);
                } else {
                    st.pop();
                    node = st.top();
                    st.pop();
                    result.push_back(node->val);
                }
            }
            return result;
        }
    };
    ```

- 后序遍历

  - ```c++
    class Solution {
    public:
        vector<int> postorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            if (root != NULL) st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();
                if (node != NULL) {
                    st.pop();
                    st.push(node);                          // 中
                    st.push(NULL);
    
                    if (node->right) st.push(node->right);  // 右
                    if (node->left) st.push(node->left);    // 左
    
                } else {
                    st.pop();
                    node = st.top();
                    st.pop();
                    result.push_back(node->val);
                }
            }
            return result;
        }
    };
    ```

    

# 3. 二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

## 1) 二叉树的层序遍历Ⅱ

[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```c++
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            vector<int> level;
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                level.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
            }
            res.push_back(level);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

## 2) 二叉树的右视图

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            while(size != 1){
                TreeNode* cur = q.front();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
                size--;
            }
            res.push_back(q.front()->val);
            if(q.front()->left) q.push(q.front()->left);
            if(q.front()->right) q.push(q.front()->right);
            q.pop();
        }
        return res;
    }
};
/*------------------------------小小的简化一下----------------------------------------*/
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
			for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                q.pop();
                if(i == size - 1){
                    res.push_back(cur->val);
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return res;
    }
};
```

## 3) 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            double sum = 0;
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                sum += cur->val;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
            }
            double average = sum / size;
            res.push_back(average);
        }
        return res;
    }
};
```



## 4) N叉树的层序遍历

[429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val; 
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        queue<Node*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            vector<int> vec;
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                vec.push_back(cur->val);
                for(auto node : cur->children){
                    q.push(node);
                }
                q.pop();
            }
            res.push_back(vec);
        }
        return res;
    }
};
```



## 5) 在每个数行中找最大值

[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            int max = INT_MIN;
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                if(max < cur->val)
                    max = cur->val;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
            }
            res.push_back(max);
        }
        return res;
    }
};
```



## 6) 填充每个节点的下一个右侧节点指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                if(i == size - 1){
                    cur->next = NULL;
                    q.pop();
                }
                else{
                    q.pop();
                    Node* next = q.front();
                    cur->next = next;
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
```



## 7) 填充每个节点的下一个右侧节点指针Ⅱ

[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
 Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                if(i == size - 1){
                    cur->next = NULL;
                    q.pop();
                }
                else{
                    q.pop();
                    Node* next = q.front();
                    cur->next = next;
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
```

**和上一题没区别呀，提交上一题的代码一样过**

## 8) 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```c++
/*太久没写递归了，重温一下递归*/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left)+1,maxDepth(root->right)+1);
    }
};
```



```c++
/*层序遍历*/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
                if(i == size - 1)
                    res++;
            }
        }  
        return res;
    }
};
```

## 9) 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        if(!root->left) return minDepth(root->right) + 1;
        if(!root->right) return minDepth(root->left) + 1;
        else return min(minDepth(root->left)+1,minDepth(root->right)+1);
    }
};
```



```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录最小深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
                if (!node->left && !node->right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出
                    return depth;
                }
            }
        }
        return depth;
    }
};
```



# 4. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

## 递归

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;
        TreeNode* left = root->left;
        root->left = root->right;
        root->right = left;
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

## 迭代

```c++
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```



# 5. 对称二叉树

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

## 递归

```c++
class Solution {
public:
    bool isMirror(TreeNode* root1, TreeNode* root2)
    {
        if(!root1 && !root2) return true;
        if(!root1 && root2) return false;
        if(root1 && !root2) return false;
        if(root1->val == root2->val) return isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);
        return false;
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isMirror(root->left,root->right);
    }
};
```

## 迭代

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        while (!que.empty()) {  // 接下来就要判断这这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```



# 6. 二叉树的所有路径

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

## 递归

```c++
class Solution {
public:
    void Path(TreeNode* root,vector<string> &path, string s)
    {
        if(root != nullptr)
        {
            s += to_string(root->val);
            
            if(!root->left && !root->right)
            {
                path.push_back(s);
            }else{
                s += "->";
            }
            Path(root->left,path,s);
            Path(root->right,path,s);
        }
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        string s = "";
        vector<string> path;
        Path(root,path,"");
        return path;
    }
};
```

## 迭代

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> s1;
        stack<string> s2;
        vector<string> res;
        if(!root) return res;
        s1.push(root);
        s2.push(to_string(root->val));
        while(!s1.empty()){
            TreeNode* cur = s1.top(); s1.pop();
            string path = s2.top(); s2.pop();
            if(!cur->left && !cur->right){
                res.push_back(path);
            }
            if(cur->right){
                s1.push(cur->right);
                s2.push(path + "->" + to_string(cur->right->val));
            }
            if(cur->left){
                s1.push(cur->left);
                s2.push(path + "->" + to_string(cur->left->val));
            }
        }
        return res;
    }
};
```



# 7. 左叶子之和

[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

## 递归

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        
        int left = sumOfLeftLeaves(root->left);
        int right = sumOfLeftLeaves(root->right);

        int midValue = 0;
        if(root->left && !root->left->left && !root->left->right){
            midValue = root->left->val;
        }

        return midValue + left + right;
    }
};
```

## 迭代

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return 0;
        st.push(root);
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
                result += node->left->val;
            }
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return result;
    }
};
```

# 8. 找树左下角的值

[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

## 迭代

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        que.push(root);
        int res;
        while(!que.empty())
        {
            int size = que.size();
            res = que.front()->val;
            for(int i = 0; i < size; i++)
            {
                TreeNode* cur = que.front();
                que.pop();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return res;
    }
};
```

## 递归

```c++
class Solution {
public:
    int maxLen = INT_MIN;
    int maxleftValue;
    void traversal(TreeNode* root, int leftLen) {
        if (root->left == NULL && root->right == NULL) {
            if (leftLen > maxLen) {
                maxLen = leftLen;
                maxleftValue = root->val;
            }
            return;
        }
        if (root->left) {
            leftLen++;
            traversal(root->left, leftLen);
            leftLen--; // 回溯
        }
        if (root->right) {
            leftLen++;
            traversal(root->right, leftLen);
            leftLen--; // 回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return maxleftValue;
    }
};
```



# 9. 路经总和

[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

## 递归

```c++
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if(root == nullptr) return false;
        if(root->left == nullptr && root->right == nullptr)
            return sum == root->val;
        return hasPathSum(root->left,sum-root->val) || hasPathSum(root->right,sum-root->val); 
    }
};
```



# 10. 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

此题与第11题大同小异，主要是对于两种遍历序列的相关性的理解以及区间划分的代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        _inorder = inorder;
        _postorder = postorder;
    
        for(int i = 0; i < inorder.size(); i++){
            hash[inorder[i]] = i;
        }
        TreeNode* root = build(0,inorder.size()-1,0,postorder.size()-1);
        return root;
    }
private:
    vector<int> _inorder;
    vector<int> _postorder;
    unordered_map<int,int> hash;

    TreeNode* build(int il,int ir, int pl, int pr){
        if(il > ir || pl > pr) return nullptr;
        TreeNode* root = new TreeNode(_postorder[pr]);
        int Index = hash[_postorder[pr]];
        int l = _inorder.size();
        TreeNode* left = build(il,Index - 1,pl,pl + Index - il - 1);
        TreeNode* right = build(Index + 1,ir,pl + Index - il , pr - 1);
        root->left = left;
        root->right = right;
        return root;
    }
};
```



# 11. 从中序与前序遍历序列构造二叉树

[剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```c++


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

 //前序遍历是 根左右，因此第一个元素即为根结点  [[根] [左子树的前序遍历] [右子树的前序遍历]]
 //中序遍历是 左根右，因此在中序序列中，根节点左边的元素为左子树元素，右边的元素为右子树元素 [ [左子树的中序遍历] [根][右子树的中序遍历]]
 //因此，给定前序遍历和中序遍历，可以递归的去构建一颗二叉树
 
 //首先在前序遍历中找到根结点的值
 //然后在中序遍历中确定左右子树的中序遍历
 //然后回过头来在前序遍历中确定左右子树的前序遍历
class Solution {
public:
    map<int,int> hash;
    vector<int> preorder,inorder;

    TreeNode* dfs(int pl,int pr, int il,int ir)
    {
        if(pl > pr) return nullptr;
        auto root = new TreeNode(preorder[pl]);
        //k为preorder[pl]在中序遍历序列中的下标
        int k = hash[root->val];
        //递归构建左右子树
        auto left = dfs(pl+1,pl+1+k-il-1,il,k-1);
        auto right = dfs(pl+k-il+1,pr,k+1,ir);
        root->left = left;
        root->right = right;
        return root;
    }

    TreeNode* buildTree(vector<int>& _preorder, vector<int>& _inorder) {
        preorder = _preorder;
        inorder = _inorder;
        //利用哈希表，将前序遍历映射到中序遍历中，方便查找前序遍历元素在中序遍历序列中的位置
        for(int i = 0;i < inorder.size();i++)  
            hash[inorder[i]] = i;
        return dfs(0,preorder.size()-1,0,inorder.size()-1);
    }
};

```



# 12. 最大二叉树

[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* dfs(vector<int>& nums, int l, int r)
    {
        if(l > r) return nullptr;
        int max = INT_MIN;
        int index = 0;
        for(int i = l; i <= r; i++){
            if(max < nums[i])
                max = nums[i], index = i;
        }
        TreeNode* root = new TreeNode(max);
        TreeNode* left = dfs(nums,l,index-1);
        TreeNode* right = dfs(nums,index+1,r);
        root->left = left;
        root->right = right;
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        TreeNode* root = dfs(nums,0,nums.size()-1);
        return root;
    }
};
```



# 13. 二叉搜索树的插入操作

[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* parent;
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* node = new TreeNode(val);
        if(!root){
            if(!parent)
                return node;
            else{
                if(parent->val > val)
                    parent->left = node;
                else 
                    parent->right = node;
            }
            return root;
        }
        if(root->val > val){
            parent = root;
            insertIntoBST(root->left,val);
            return root;
        }
        if(root->val < val){
            parent = root;
            insertIntoBST(root->right,val);
            return root;
        }
        return root;
    }
};
```

**关键在于定义一个指针用于记录父亲节点**



# 14. 删除二叉搜索树中的节点

[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root) return nullptr;
        if(root->val == key){
            if(!root->left) return root->right;
            if(!root->right) return root->left;
            if(root->left && root->right){
                TreeNode* node = root->right;
                while(node->left){
                    node = node->left;
                }
                node ->left = root->left;
                return root->right;
            }
        }
        if(root->val > key) root->left = deleteNode(root->left,key);
        if(root->val < key) root->right = deleteNode(root->right,key);
        return root;
    }
};
```

**主要在于删除根节点时，且根节点的左右子节点均不为空时，搞清楚删除逻辑**
