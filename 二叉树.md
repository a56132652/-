# 1. 二叉树定义

**牢记，以防手撕代码**

```c++
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x): val(x), left(nullptr), right(nullptr){}
};
```



# 2. 二叉树的迭代遍历

## 1) 前序遍历

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> sta;
        if(root != nullptr) sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            result.push_back(node->val);
            if(node->right) sta.push(node->right);
            if(node->left) sta.push(node->left);
        }
        return result;
    }
};
```

## 2) 中序遍历

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> sta;
        vector<int> res;
        if(!root) return res;
        TreeNode* cur = root;
        while(!sta.empty() || cur != nullptr)
        {
            if(cur != nullptr)
            {
                sta.push(cur);
                cur = cur->left; 
            }else{
                TreeNode* temp = sta.top();
                sta.pop();
                res.push_back(temp->val);
                cur = temp->right;
            }
        }
        return res;
    }
};
```

## 3) 后序遍历

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
      vector<int> result;
        stack<TreeNode*> sta;
        if(root != nullptr) sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            result.push_back(node->val);
            if(node->left) sta.push(node->left);
            if(node->right) sta.push(node->right);
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
```

## 4) 统一迭代法

- 中序遍历

  - ```c++
    class Solution {
    public:
        vector<int> inorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            if (root != NULL) st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();
                if (node != NULL) {
                    st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                    if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）
    
                    st.push(node);                          // 添加中节点
                    st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。
    
                    if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
                } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                    st.pop();           // 将空节点弹出
                    node = st.top();    // 重新取出栈中元素
                    st.pop();
                    result.push_back(node->val); // 加入到结果集
                }
            }
            return result;
        }
    };
    ```

- 前序遍历

  - ```c++
    class Solution {
    public:
        vector<int> preorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            if (root != NULL) st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();
                if (node != NULL) {
                    st.pop();
                    if (node->right) st.push(node->right);  // 右
                    if (node->left) st.push(node->left);    // 左
                    st.push(node);                          // 中
                    st.push(NULL);
                } else {
                    st.pop();
                    node = st.top();
                    st.pop();
                    result.push_back(node->val);
                }
            }
            return result;
        }
    };
    ```

- 后序遍历

  - ```c++
    class Solution {
    public:
        vector<int> postorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            if (root != NULL) st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();
                if (node != NULL) {
                    st.pop();
                    st.push(node);                          // 中
                    st.push(NULL);
    
                    if (node->right) st.push(node->right);  // 右
                    if (node->left) st.push(node->left);    // 左
    
                } else {
                    st.pop();
                    node = st.top();
                    st.pop();
                    result.push_back(node->val);
                }
            }
            return result;
        }
    };
    ```

    

# 3. 二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

## 1) 二叉树的层序遍历Ⅱ

[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```c++
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            vector<int> level;
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                level.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
            }
            res.push_back(level);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

## 2) 二叉树的右视图

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            while(size != 1){
                TreeNode* cur = q.front();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
                size--;
            }
            res.push_back(q.front()->val);
            if(q.front()->left) q.push(q.front()->left);
            if(q.front()->right) q.push(q.front()->right);
            q.pop();
        }
        return res;
    }
};
/*------------------------------小小的简化一下----------------------------------------*/
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
			for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                q.pop();
                if(i == size - 1){
                    res.push_back(cur->val);
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return res;
    }
};
```

## 3) 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            double sum = 0;
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                sum += cur->val;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
            }
            double average = sum / size;
            res.push_back(average);
        }
        return res;
    }
};
```



## 4) N叉树的层序遍历

[429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val; 
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        queue<Node*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            vector<int> vec;
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                vec.push_back(cur->val);
                for(auto node : cur->children){
                    q.push(node);
                }
                q.pop();
            }
            res.push_back(vec);
        }
        return res;
    }
};
```



## 5) 在每个数行中找最大值

[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            int max = INT_MIN;
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                if(max < cur->val)
                    max = cur->val;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
            }
            res.push_back(max);
        }
        return res;
    }
};
```



## 6) 填充每个节点的下一个右侧节点指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

**可以直接利用层序遍历，一层一层的处理，代码如下：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                if(i == size - 1){
                    cur->next = NULL;
                    q.pop();
                }
                else{
                    q.pop();
                    Node* next = q.front();
                    cur->next = next;
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
```

**另外一种方式**

- **给定树为完全二叉树**

- 利用父节点直接连接左右子节点，即`node.left->next = node.right`
- 当要连接的两节点属于不同父节点时，可用`node.right->next = node.next->left`
- 每次遍历都要从最左节点开始，**当前层的最左节点一定是上一层最左节点的孩子节点**

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if (root == nullptr) {
            return root;
        }
        
        // 从根节点开始
        Node* leftmost = root;
        
        while (leftmost->left != nullptr) {
            
            // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针
            Node* head = leftmost;
            
            while (head != nullptr) {
                
                // CONNECTION 1
                head->left->next = head->right;
                
                // CONNECTION 2
                if (head->next != nullptr) {
                    head->right->next = head->next->left;
                }
                
                // 指针向后移动
                head = head->next;
            }
            
            // 去下一层的最左的节点
            leftmost = leftmost->left;
        }
        
        return root;
    }
};
```



## 7) 填充每个节点的下一个右侧节点指针Ⅱ

[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
 Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                if(i == size - 1){
                    cur->next = NULL;
                    q.pop();
                }
                else{
                    q.pop();
                    Node* next = q.front();
                    cur->next = next;
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
```

**和上一题没区别呀，提交上一题的代码一样过**

**法二：**

```c++
class Solution {
public:
    void handle(Node* &last, Node* &p, Node* &nextStart) {
        if (last) {
            last->next = p;
        } 
        if (!nextStart) {
            nextStart = p;
        }
        last = p;
    }

    Node* connect(Node* root) {
        if (!root) {
            return nullptr;
        }
        Node *start = root;
        while (start) {
            Node *last = nullptr, *nextStart = nullptr;
            for (Node *p = start; p != nullptr; p = p->next) {
                if (p->left) {
                    handle(last, p->left, nextStart);
                }
                if (p->right) {
                    handle(last, p->right, nextStart);
                }
            }
            start = nextStart;
        }
        return root;
    }
};
```



## 8) 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```c++
/*太久没写递归了，重温一下递归*/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left)+1,maxDepth(root->right)+1);
    }
};
```



```c++
/*层序遍历*/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
                if(i == size - 1)
                    res++;
            }
        }  
        return res;
    }
};
```

## 9) 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        if(!root->left) return minDepth(root->right) + 1;
        if(!root->right) return minDepth(root->left) + 1;
        else return min(minDepth(root->left)+1,minDepth(root->right)+1);
    }
};
```



```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录最小深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
                if (!node->left && !node->right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出
                    return depth;
                }
            }
        }
        return depth;
    }
};
```



# 4. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

## 递归

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;
        TreeNode* left = root->left;
        root->left = root->right;
        root->right = left;
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

## 迭代

```c++
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```



# 5. 对称二叉树

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

## 递归

```c++
class Solution {
public:
    bool isMirror(TreeNode* root1, TreeNode* root2)
    {
        if(!root1 && !root2) return true;
        if(!root1 && root2) return false;
        if(root1 && !root2) return false;
        if(root1->val == root2->val) return isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);
        return false;
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isMirror(root->left,root->right);
    }
};
```

## 迭代

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        while (!que.empty()) {  // 接下来就要判断这这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

**自己写的**

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root->left);
        q.push(root->right);
        while(!q.empty()){
            TreeNode* left = q.front(); q.pop();
            TreeNode* right = q.front(); q.pop();

            if((!left && right) || (!right && left)) return false;
            else if(!left && !right) continue;
            else if(left->val != right->val) return false;
            else{
                    q.push(left->left);
                    q.push(right->right);
                    q.push(left->right);
                    q.push(right->left);
                }
        }
        return true;
    }
};
```

# 6. 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

# 7. n叉树的最大深度

[559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

**层序遍历：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int maxDepth(Node* root) {
        if(!root) return 0;
        int res = 0;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                Node* cur = q.front();
                q.pop();
                for(auto child : cur->children) q.push(child);
            }
            res++;
        }
        return res;
    }
};
```

**递归：**

```c++
class Solution {
public:
    int maxDepth(Node* root) {
        if(!root) return 0;
        int res = 0;
        for(auto child : root->children){
            res = max(res, maxDepth(child));
        }
        return res + 1;
    }
};
```



# 8.二叉树的最小深度

[8.二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

**对我个人而言，该题要注意的就是： 深度为根节点到叶子节点的路径上的节点数，一定要到叶子节点，当根节点左子树为空时，就应该去右子树找，而不是直接返回 1 **

**递归：**

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        if(!root->left) return minDepth(root->right) + 1;
        if(!root->right) return minDepth(root->left) + 1;
        else return min(minDepth(root->left)+1,minDepth(root->right)+1);
    }
};
```

**迭代**：

- 层序遍历过程中，若碰到叶子节点，说明找到了最小深度，当前层即是最小深度层

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode*> q;
        q.push(root);
        int res = 1;
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                q.pop();
                if(!cur->left && !cur->right) return res;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            res++;
        }
        return res;
    }
};
```



# 9. 完全二叉树的节点个数

[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

**即遍历二叉树的所有节点，前中后序遍历都可以做**

**层序遍历：**

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                res++;
                q.pop();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right); 
            }
        }
        return res;
    }
};
```

**递归：**

```c++
class Solution {
public:
    int res;
    void dfs(TreeNode* root){
        if(!root) return;
        res++;
        dfs(root->left);
        dfs(root->right);
    }
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        dfs(root);
        return res;
    }
};
```

**公式法：**

- 完全二叉树有可能是一棵满二叉树，也有可能最后一层节点不满，对于满二叉树，可以直接利用公式`2^n - 1`来计算节点数，其中`n`为二叉树深度，**根节点深度为 1 **
- 因此，遍历二叉树，若遇到满二叉树，**即左右子树深度相同时**，利用公式计算
- 若不是满二叉树，继续递归，直到遇见满二叉树

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftHeight = 0, rightHeight = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftHeight++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightHeight++;
        }
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```



# 10. 平衡二叉树

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

```c++
class Solution {
public:
    int Height(TreeNode* root)
    {
        if(root == nullptr){
            return 0;
        }else{
            return max(Height(root->left),Height(root->right)) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        if(root == nullptr){
            return true;
        }else{
            return abs(Height(root->left)-Height(root->right)) <=1 && isBalanced(root->left) && isBalanced(root->right);
        }
    }
};
```



# 11. 二叉树的所有路径

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

## 递归

```c++
class Solution {
private:

    void traversal(TreeNode* cur, string path, vector<string>& result) {
        path += to_string(cur->val); // 中
        if (cur->left == NULL && cur->right == NULL) {
            result.push_back(path);
            return;
        }
        if (cur->left) traversal(cur->left, path + "->", result); // 左
        if (cur->right) traversal(cur->right, path + "->", result); // 右
    }

public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        string path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;

    }
};
```

**外日，这题把我卡了半天，贴上自己的代码**

```c++
class Solution {
public:
    vector<string> res;
    void backTracking(TreeNode* root, string path){
        if(!root) return;
        if(!root->left && !root->right){
            if(path == "") path += to_string(root->val);
            else
                path = path + "->" + to_string(root->val);
            res.push_back(path);
            return;
        }

        if(path == ""){
            backTracking(root->left, path + to_string(root->val));
            backTracking(root->right, path + to_string(root->val));
        }else{
            backTracking(root->left, path + "->" + to_string(root->val));
            backTracking(root->right, path + "->" + to_string(root->val));
        }
        

    }
    vector<string> binaryTreePaths(TreeNode* root) {
        backTracking(root,"");
        return res;
    }
};
```

**小小的修改一下**

```c++
class Solution {
public:
    vector<string> res;
    void backTracking(TreeNode* root, string path){
        path += to_string(root->val);
        if(!root->left && !root->right){
            res.push_back(path);
            return;
        }

        if(root->left) backTracking(root->left, path + "->");
        if(root->right) backTracking(root->right, path + "->");
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        backTracking(root,"");
        return res;
    }
};
```



## 迭代

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> s1;
        stack<string> s2;
        vector<string> res;
        if(!root) return res;
        s1.push(root);
        s2.push(to_string(root->val));
        while(!s1.empty()){
            TreeNode* cur = s1.top(); s1.pop();
            string path = s2.top(); s2.pop();
            if(!cur->left && !cur->right){
                res.push_back(path);
            }
            if(cur->right){
                s1.push(cur->right);
                s2.push(path + "->" + to_string(cur->right->val));
            }
            if(cur->left){
                s1.push(cur->left);
                s2.push(path + "->" + to_string(cur->left->val));
            }
        }
        return res;
    }
};
```



# 12. 左叶子之和

[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

**左叶子节点：如果当前节点cur 的左节点不为空，并且该子节点左右节点为空，则该子节点为左叶子节点**

- 因此， 判断一个节点是否为左叶子节点，必须借助其父节点
- `if(root->left && !root->left->left && !root->left->right)`

## 递归

- 后序遍历：

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        
        int left = sumOfLeftLeaves(root->left);
        int right = sumOfLeftLeaves(root->right);

        int midValue = 0;
        if(root->left && !root->left->left && !root->left->right){
            midValue = root->left->val;
        }

        return midValue + left + right;
    }
};
```

- 前序遍历

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;                                       // 中
        int midValue = 0;
        if (root->left && !root->left->left && !root->left->right) {
            midValue = root->left->val;
        }
        int leftValue = sumOfLeftLeaves(root->left);    // 左
        int rightValue = sumOfLeftLeaves(root->right);  // 右

        int sum = midValue + leftValue + rightValue;
        return sum;
    }
};
```

- 中序遍历

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        int leftValue = sumOfLeftLeaves(root->left);    // 左
                                    // 中
        int midValue = 0;
        if (root->left && !root->left->left && !root->left->right) {
            midValue = root->left->val;
        }
        
        int rightValue = sumOfLeftLeaves(root->right);  // 右

        int sum = midValue + leftValue + rightValue;
        return sum;
    }
};
```

## 感想：

对于该题，我的想法就是遍历每一个节点，对每一个节点的左子节点做判断，判断他是不是左叶子节点，若是的话，就记录他的值，然后在它的左右子树上进行递归

因为是遍历这颗二叉树，而前中后序三种遍历都是将树遍历一遍，因此三种遍历方法都可以用在这题上，而**Carl哥说“递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和”，我没看懂，我感觉只要捋清楚了递归逻辑，确定了递归的返回值，遍历方法都可以**



## 迭代

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return 0;
        st.push(root);
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
                result += node->left->val;
            }
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return result;
    }
};
```

## 层序遍历

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root || (!root->left && !root->right) ) return 0;
        queue<TreeNode*> q;
        q.push(root);
        int res = 0;
        while(!q.empty()){
            TreeNode* cur = q.front();
            q.pop();
            if(cur->left){
                if(!cur->left->left && !cur->left->right) res += cur->left->val;
                q.push(cur->left);
            }
            if(cur->right) q.push(cur->right);
        }
        return res;
    }
};
```



# 13. 找树左下角的值

[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

## 迭代

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        que.push(root);
        int res;
        while(!que.empty())
        {
            int size = que.size();
            res = que.front()->val;
            for(int i = 0; i < size; i++)
            {
                TreeNode* cur = que.front();
                que.pop();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return res;
    }
};
```

## 递归

```c++
class Solution {
public:
    int maxLen = INT_MIN;
    int maxleftValue;
    void traversal(TreeNode* root, int leftLen) {
        if (root->left == NULL && root->right == NULL) {
            if (leftLen > maxLen) {
                maxLen = leftLen;
                maxleftValue = root->val;
            }
            return;
        }
        if (root->left) {
            leftLen++;
            traversal(root->left, leftLen);
            leftLen--; // 回溯
        }
        if (root->right) {
            leftLen++;
            traversal(root->right, leftLen);
            leftLen--; // 回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return maxleftValue;
    }
};
```



# 14. 路经总和

[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

## 递归

```c++
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if(root == nullptr) return false;
        if(root->left == nullptr && root->right == nullptr)
            return sum == root->val;
        return hasPathSum(root->left,sum-root->val) || hasPathSum(root->right,sum-root->val); 
    }
};
```

## 迭代：

```c++
class solution {

public:
    bool haspathsum(treenode* root, int sum) {
        if (root == null) return false;
        // 此时栈里要放的是pair<节点指针，路径数值>
        stack<pair<treenode*, int>> st;
        st.push(pair<treenode*, int>(root, root->val));
        while (!st.empty()) {
            pair<treenode*, int> node = st.top();
            st.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if (!node.first->left && !node.first->right && sum == node.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->right) {
                st.push(pair<treenode*, int>(node.first->right, node.second + node.first->right->val));
            }

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->left) {
                st.push(pair<treenode*, int>(node.first->left, node.second + node.first->left->val));
            }
        }
        return false;
    }
};
```



# 15. 路径总和 II

[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```c++
class Solution {
public:
    vector<vector<int>> Path ;
    //递归遍历每一条路径
    void dfs(TreeNode* root,vector<int> path,int targetSum,int cur_sum)
    {
        if(!root)  return;
        cur_sum += root->val;
        path.push_back(root->val);
        if(!root->left && !root->right && cur_sum == targetSum)
        {   
            Path.push_back(path);
        }
        dfs(root->left,path,targetSum ,cur_sum);
        dfs(root->right,path,targetSum ,cur_sum);

    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return Path;
        vector<int> path;
        dfs(root,path,targetSum,0);
        return Path;
    }
};
```



# 16. 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        _inorder = inorder;
        _postorder = postorder;
    
        for(int i = 0; i < inorder.size(); i++){
            hash[inorder[i]] = i;
        }
        TreeNode* root = build(0,inorder.size()-1,0,postorder.size()-1);
        return root;
    }
private:
    vector<int> _inorder;
    vector<int> _postorder;
    unordered_map<int,int> hash;

    TreeNode* build(int il,int ir, int pl, int pr){
        if(il > ir || pl > pr) return nullptr;
        TreeNode* root = new TreeNode(_postorder[pr]);
        int Index = hash[_postorder[pr]];
        int l = _inorder.size();
        TreeNode* left = build(il,Index - 1,pl,pl + Index - il - 1);
        TreeNode* right = build(Index + 1,ir,pl + Index - il , pr - 1);
        root->left = left;
        root->right = right;
        return root;
    }
};
```



# 17. 从中序与前序遍历序列构造二叉树

[剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```c++


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

 //前序遍历是 根左右，因此第一个元素即为根结点  [[根] [左子树的前序遍历] [右子树的前序遍历]]
 //中序遍历是 左根右，因此在中序序列中，根节点左边的元素为左子树元素，右边的元素为右子树元素 [ [左子树的中序遍历] [根][右子树的中序遍历]]
 //因此，给定前序遍历和中序遍历，可以递归的去构建一颗二叉树
 
 //首先在前序遍历中找到根结点的值
 //然后在中序遍历中确定左右子树的中序遍历
 //然后回过头来在前序遍历中确定左右子树的前序遍历
class Solution {
public:
    map<int,int> hash;
    vector<int> preorder,inorder;

    TreeNode* dfs(int pl,int pr, int il,int ir)
    {
        if(pl > pr) return nullptr;
        auto root = new TreeNode(preorder[pl]);
        //k为preorder[pl]在中序遍历序列中的下标
        int k = hash[root->val];
        //递归构建左右子树
        auto left = dfs(pl+1,pl+1+k-il-1,il,k-1);
        auto right = dfs(pl+k-il+1,pr,k+1,ir);
        root->left = left;
        root->right = right;
        return root;
    }

    TreeNode* buildTree(vector<int>& _preorder, vector<int>& _inorder) {
        preorder = _preorder;
        inorder = _inorder;
        //利用哈希表，将前序遍历映射到中序遍历中，方便查找前序遍历元素在中序遍历序列中的位置
        for(int i = 0;i < inorder.size();i++)  
            hash[inorder[i]] = i;
        return dfs(0,preorder.size()-1,0,inorder.size()-1);
    }
};

```



# 18. 最大二叉树

[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* dfs(vector<int>& nums, int l, int r)
    {
        if(l > r) return nullptr;
        int max = INT_MIN;
        int index = 0;
        for(int i = l; i <= r; i++){
            if(max < nums[i])
                max = nums[i], index = i;
        }
        TreeNode* root = new TreeNode(max);
        TreeNode* left = dfs(nums,l,index-1);
        TreeNode* right = dfs(nums,index+1,r);
        root->left = left;
        root->right = right;
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        TreeNode* root = dfs(nums,0,nums.size()-1);
        return root;
    }
};
```



# 19.合并二叉树

[617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1 && !root2) return nullptr;
        if(!root1 && root2) return root2;
        if(root1 && !root2) return root1;

        TreeNode *node = new TreeNode(root1->val + root2->val);
        
        if(node){
            node->left = mergeTrees(root1->left, root2->left);
            node->right = mergeTrees(root1->right, root2->right);
        }
        return node;
    }
};
```



# 20. 二叉搜索树中的搜索

[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return nullptr;
        if(root->val == val) return root;
        else if(root->val < val) return searchBST(root->right, val);
        else
            return searchBST(root->left, val);
        
        return nullptr;
    }
};
```

**迭代：**

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```



# 21. 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

**递归：下面是我自己写的典型错误代码**

- 在处理逻辑中，我只单纯的判断了以当前节点为根节点的子树是否是一颗合理的BST
- 事实上，对于当前子树虽然合理，但是整棵树未必合理
- 例如，对于根节点 5，其右子树为`[6,3,7]`,右子树是一颗合理的BST，但是对于整棵树而言，节点 3 不应该出现在节点 5 的右端，因此不合理

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if(!root || (!root->left && !root->right)) return true;
        if(root->left && root->right) return root->left->val < root->val && root->val < root->right->val;
        if(!root->left) return root->val < root->right->val;
        if(!root->right) return root->val  > root->left->val;

        return isValidBST(root->left) && isValidBST(root->right);
    }
};
```

**利用BST的中序遍历是升序序列的性质，进行判断**

**递归：**

- 因为后台数据有int最小值测试用例，所以maxVal设置为longlong最小值。

```c++
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val) maxVal = root->val;
        else return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
};
```

- 如果测试数据中有 longlong的最小值

```c++
class Solution {
public:
    TreeNode* pre = NULL; // 用来记录前一个节点
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        bool left = isValidBST(root->left);

        if (pre != NULL && pre->val >= root->val) return false;
        pre = root; // 记录前一个节点

        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

**迭代：**

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> s;
        long long pre = (long long)INT_MIN - 1;
        TreeNode* cur = root;
        while(!s.empty() || cur != nullptr){
            while(cur){
                s.push(cur);
                cur = cur->left;
            } 
            cur = s.top();
            s.pop();
            if(cur->val <= pre) return false;
            pre = cur->val;
            cur = cur->right;           
        }
        return true;
    }
};
```

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL; // 记录前一个节点
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur->left;                // 左
            } else {
                cur = st.top();                 // 中
                st.pop();
                if (pre != NULL && cur->val <= pre->val)
                return false;
                pre = cur; //保存前一个访问的结点

                cur = cur->right;               // 右
            }
        }
        return true;
    }
};
```



# 22.二叉搜索树的最小绝对差

[530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

**递归：**

```c++
class Solution {
public:
    TreeNode* pre;
    int res = INT_MAX;
    void dfs(TreeNode* root)
    {
        if(!root) return;
        dfs(root->left);
        if(pre){
            res = min(res,root->val - pre->val);
        }
        pre = root;
        dfs(root->right);
    }
    int getMinimumDifference(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

**迭代：**

```c++
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int result = INT_MAX;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top();
                st.pop();
                if (pre != NULL) {              // 中
                    result = min(result, cur->val - pre->val);
                }
                pre = cur;
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```



# 23.二叉搜索树中的众数

[501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

```c++
class Solution {
public:
    //中序遍历法
    //定义一个前驱节点pre，将前驱节点pre与当前节点cur比较，若相等，则当前节点计数值count++
    //将count值与maxcount比较，若小，则cur不是频率最高的
    //若相等，则将cur存入数组
    //若count更大，则更新maxcount = count，并将之前存入数组的值清空，将cur存入数组

    TreeNode* pre = nullptr;
    int count = 0;
    int maxcount = 0;
    vector<int> v;
    //中序遍历
    void dfs(TreeNode* cur)
    {
        if(!cur) return ;
        //前
        dfs(cur->left);

        //中
        if(pre == nullptr)  count = 1;
        else if(pre->val == cur->val)   count++;
        else{ count = 1;}
        //更新前驱节点
        pre = cur;
        if(count ==　maxcount)   v.push_back(cur->val);
        else if(count > maxcount){
            maxcount = count;
            v.clear();
            v.push_back(cur->val);
        }

        //后
        dfs(cur->right);
        return;
    }

    vector<int> findMode(TreeNode* root) {
        dfs(root);
        return v;
    }
};
```

**迭代：**

```c++
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int maxCount = 0; // 最大频率
        int count = 0; // 统计频率
        vector<int> result;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top();
                st.pop();                       // 中
                if (pre == NULL) { // 第一个节点
                    count = 1;
                } else if (pre->val == cur->val) { // 与前一个节点数值相同
                    count++;
                } else { // 与前一个节点数值不同
                    count = 1;
                }
                if (count == maxCount) { // 如果和最大值相同，放进result中
                    result.push_back(cur->val);
                }

                if (count > maxCount) { // 如果计数大于最大值频率
                    maxCount = count;   // 更新最大频率
                    result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
                    result.push_back(cur->val);
                }
                pre = cur;
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```



# 24. 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == q || root == p) return root;
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        if(!left) return right;
        if(!right) return left;
        return root;
    }
};
```



# 25. 二叉搜索树的最近公共祖先

[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == p || root == q) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if(right && left) return root;
        if(!right) return left;
        return right;
    }
};
```

**迭代**

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root) {
            if (root->val > p->val && root->val > q->val) {
                root = root->left;
            } else if (root->val < p->val && root->val < q->val) {
                root = root->right;
            } else return root;
        }
        return NULL;
    }
};
```



# 26. 二叉搜索树的插入操作

[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* parent;
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* node = new TreeNode(val);
        if(!root){
            if(!parent)
                return node;
            else{
                if(parent->val > val)
                    parent->left = node;
                else 
                    parent->right = node;
            }
            return root;
        }
        if(root->val > val){
            parent = root;
            insertIntoBST(root->left,val);
            return root;
        }
        if(root->val < val){
            parent = root;
            insertIntoBST(root->right,val);
            return root;
        }
        return root;
    }
};
```

**关键在于定义一个指针用于记录父亲节点**



# 14. 删除二叉搜索树中的节点

[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root) return nullptr;
        if(root->val == key){
            if(!root->left) return root->right;
            if(!root->right) return root->left;
            if(root->left && root->right){
                TreeNode* node = root->right;
                while(node->left){
                    node = node->left;
                }
                node ->left = root->left;
                return root->right;
            }
        }
        if(root->val > key) root->left = deleteNode(root->left,key);
        if(root->val < key) root->right = deleteNode(root->right,key);
        return root;
    }
};
```

**主要在于删除根节点时，且根节点的左右子节点均不为空时，搞清楚删除逻辑**
