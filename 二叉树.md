# 1. 二叉树定义

**牢记，以防手撕代码**

```c++
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x): val(x), left(nullptr), right(nullptr){}
};
```



# 2. 二叉树的迭代遍历

## 1) 前序遍历

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> sta;
        if(root != nullptr) sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            result.push_back(node->val);
            if(node->right) sta.push(node->right);
            if(node->left) sta.push(node->left);
        }
        return result;
    }
};
```

## 2) 中序遍历

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> sta;
        vector<int> res;
        if(!root) return res;
        TreeNode* cur = root;
        while(!sta.empty() || cur != nullptr)
        {
            if(cur != nullptr)
            {
                sta.push(cur);
                cur = cur->left; 
            }else{
                TreeNode* temp = sta.top();
                sta.pop();
                res.push_back(temp->val);
                cur = temp->right;
            }
        }
        return res;
    }
};
```

## 3) 后序遍历

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
      vector<int> result;
        stack<TreeNode*> sta;
        if(root != nullptr) sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            result.push_back(node->val);
            if(node->left) sta.push(node->left);
            if(node->right) sta.push(node->right);
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
```

