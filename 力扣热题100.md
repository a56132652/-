

# [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**哈希表**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash;
        vector<int> res;
        for(int i = 0; i < nums.size(); i++)
        {
            if(hash.find(target - nums[i]) != hash.end()){
                res.push_back(hash[target - nums[i]]);
                res.push_back(i);
                return res;
            }else{
                hash[nums[i]] = i;
            }
        }
        return res;
    }
};
```



# [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**模拟**

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = nullptr;
        ListNode* tail = nullptr;
        int carry = 0;
        while(l1 || l2){
            int n1 = l1 ? l1->val : 0;
            int n2 = l2 ? l2->val : 0;
            int number = n1 + n2 + carry;
            carry = number / 10;
            number %= 10;
            if(!head) head = tail = new ListNode(number);
            else{
                tail->next = new ListNode(number);
                tail = tail->next;
            }
            if(l1) l1 = l1->next;
            if(l2) l2 = l2->next;
        }
        if(carry){
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```



# [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

**典型的滑动窗口**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       unordered_set<int> hash;
       int left = 0, right = 0;
       int res = 0;
       while(right < s.size())
       {
           while(hash.find(s[right]) != hash.end()){
               hash.erase(s[left]);
               left++;
           }
           hash.insert(s[right]);
           res = max(res,right - left + 1);
           right++;
       } 
       return res;
    }
};
```



# [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

**可以直接用暴力法，将两个数组合并，然后输出合并后数组的中位数，该方法时间复杂度`O(m+n)`**

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();
        if(!n1 && !n2) return 0;
        vector<int> temp;
        int i = 0, j = 0;
        while(i < n1 && j < n2){
            if(nums1[i] < nums2[j])
                temp.push_back(nums1[i++]);
            else
                temp.push_back(nums2[j++]);
        }
        if(i < n1){
            for(;i < n1;i++){
                temp.push_back(nums1[i]);
            }
        }
        if(j < n2){
            for(;j < n2;j++){
                temp.push_back(nums2[j]);
            }
        }
        int length = n1 + n2;
        if(length % 2 != 0) return temp[length/2];
        double res = (double)(temp[length/2 - 1] + temp[length/2]) / 2;
        return res;
    }
};
```



**也可以使用二分法**

```c++
class Solution {
public:
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int n = nums1.size();
		int m = nums2.size();

		if (n > m)  //保证数组1一定最短
		{
			return findMedianSortedArrays(nums2, nums1);
		}

		// Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。
		int LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n;  //我们目前是虚拟加了'#'所以数组1是2*n长度

		while (lo <= hi)   //二分
		{
			c1 = (lo + hi) / 2;  //c1是二分的结果
			c2 = m + n - c1;

			LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];
			RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2];
			LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];
			RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2];

			if (LMax1 > RMin2)
				hi = c1 - 1;
			else if (LMax2 > RMin1)
				lo = c1 + 1;
			else
				break;
		}
		return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0;
	}
};
```



# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

**动态规划**

- `dp[i][j]`:字符串中第`i`到第`j`个字符组成的回文串的长度，若不是回文串，则长度为0
- 状态转移方程：
  - 若`s[i] == s[j]`
    - 如果`i == j`:则`dp[i][j] = 1`
    - 如果`i - j == 1`：则`dp[i][j] == 2`
    - 如果`dp[i+1][j-1] != 0`,则`dp[i][j] = dp[i+1][j-1] + 2`
  - 若`s[i] != s[j]`
    - `dp[i][j] == 0`
- 边界条件：
  - `dp[i][i] = 1`
- 最终答案即为`max(dp[i][j])`



**注意遍历顺序，首层循环必须从后往前遍历，即`for(int i = n-1; i >= 0; i--)`,因为在状态转移过程中，`dp[i][j]会利用到dp[i+1][j-1]`，所以必须先遍历`dp[i+1]`,然后遍历`dp[i]`**

**代码：**

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2) return s;
        string res = "";
        vector<vector<int>> dp(n,vector<int>(n,0));

        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j])
                {
                    if(i == j) dp[i][j] = 1;
                    else if(j - i == 1){
                        dp[i][j] = 2;
                    }
                    else if(dp[i + 1][j - 1]){
                        dp[i][j] = dp[i+1][j-1] + 2;
                    }
                }
                else{
                    dp[i][j] = 0;
                }
   
                if(dp[i][j] &&( res.size() < j - i + 1)){
                    res.clear();
                    res = s.substr(i,j - i + 1);
                }
            }
        }
        return res;
    }
};
```



# [6. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

## 1. 动态规划数组定义以及状态定义

- `dp[i][j]: 字符串s的前i个字符与模式串p的前j个字符的匹配情况`
- 若 `s[i-1] == p[j-1]`
  - `dp[i][j] = dp[i-1][j-1]`
- 若`s[i-1] != p[j-1]`
  - 若`p[j-1] == '.'`
    - `dp[i][j] == dp[i-1][j-1] `，该类情况可以合并到第一类中
  - 若`p[j-1] == '*'`
    - 则可以匹配0个`p[j-2]`或者匹配 1 个
      - 匹配 0 个时：`dp[i][j] = dp[i][j-2]`
      - 匹配 1 个时：`dp[i][j] = dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')`
  - 若`p[j-1]为小写字母`
    - 则`dp[i][j] = false`

**综上，一共可以分为两种情况，分别为`p[j-1] == '*' 或者 p[j-1] != '*'`**

## 2. DP数组初始化

- 当给定字符串以及模式串均为空是，两者当然是匹配的(空字符匹配空字符)

  - `dp[0][0] = true`

- 当模式字符串为空，而给定字符串不为空时，结果当然是false

  - `for(int i = 1; i <= ns; i++) dp[i][0] = false;`

- 当给定字符串为空，而模式字符串不为空时，只有当模式字符串的偶数位上为`*`时，两者才匹配

  - ```c++
    for(int i = 2; i <= np; i += 2){
               if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
           }
    ```



## 3. 代码

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int ns = s.size();
        int np = p.size();
        vector<vector<bool>> dp(ns+1,vector<bool>(np+1,false));
        dp[0][0] = true;
        for(int i = 1; i <= ns; i++) dp[i][0] = false;
        for(int i = 2; i <= np; i += 2){
            if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
        }

        for(int i = 1; i <= ns; i++)
        {
            for(int j = 1; j <= np; j++)
            {
                if(p[j-1] == '*'){
                    dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'));
                }else{
                    if(s[i-1] == p[j-1] || p[j-1] == '.')
                        dp[i][j] = dp[i-1][j-1];
                    else
                        dp[i][j] = false;
                }
            }
        }

        return dp[ns][np];
    }
};
```



# [7. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

![image-20211126155344279](C:\Users\Sakura\AppData\Roaming\Typora\typora-user-images\image-20211126155344279.png)

**可以看出容量大小取决于两端长度最短的那块板子**

- 利用双指针 `i j`分别指向数组两端
- 如果`heght[i] < height[j]` 则令左指针 `i`左移一位，否则，右指针`j`右移一位

## 双指针移动规律

- 双指针向内收缩时，容器底部长度肯定是减小的
  - 如果`heght[i] < height[j]`，此时若移动较大的指针，即`j--`，移动后的最小板子为`min(height[i],height[j-1])`，由于`height[j]`是较大的那个，因此移动后的容器体积肯定减小，不会增大
  - 如果`heght[i] < height[j]`，此时若移动较 小的指针，即`i++`，移动后的最小板子为`min(height[i-1],height[j])`，此时`height[i-1]`可能会增大，因此容器体积也有可能增大
- 因此每次移动较小的那个指针

## 正解：

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0, j = height.size() -1 ;
        int res = 0;
        while(i < j)
        {
              res = height[i] < height[j] ? 
                max(res, (j - i) * height[i++]): 
                 max(res, (j - i) * height[j--]); 
        }
        return res;
    }
};
```



# [8. 三数之和](https://leetcode-cn.com/problems/3sum/)

**排序+双指针**

为了保证不重复，可以先将数组排序，然后保证每重循环遍历的数字都不小于上一层循环，即保证`a <= b <= c`，并且对于每一层循环，相邻两次枚举的元素不可以重复

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int l = i + 1, r = nums.size() - 1;
            while(l < r){
                if(nums[i] + nums[l] + nums[r] == 0){
                    res.push_back(vector<int>{nums[i], nums[l++], nums[r--]});
                    while(l < r && nums[l] == nums[l-1]) l++;
                    while(l < r && nums[r] == nums[r+1]) r--;
                }else if(nums[i] + nums[l] + nums[r] > 0){
                    r--;
                }else{
                    l++;
                }
            }
        }
        return res;
    }
};
```



# [9. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

**回溯**

- 首先将数字与其代表的字符串映射
- 回溯三部曲
  - 确定递归参数及返回值
    - 递归函数传入输入的数字字符串，并且需要维护一个整型变量Index，表示遍历到了第几个数字
  - 确定递归终止条件——当前字符串长度等于给定字符串长度时，递归终止
  - 确定递归单层逻辑
    - 首先从给定字符串中分离出数字字符
    - 然后去映射数组中取出该数字对应的字符串
    - 遍历字符串，一一取出字符，并递归下一个数字

```c++
class Solution {
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    string s;
    void backtracking(const string& digits, int index) {
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';        // 将index指向的数字转为int
        string letters = letterMap[digit];      // 取数字对应的字符集
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);            // 处理
            backtracking(digits, index++);    // 递归，注意index+1，一下层要处理下一个数字了
            s.pop_back();                       // 回溯
        }
    }
    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if (digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
```

# [10. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

**典型双指针应用**

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head) return head;
        ListNode* dummy = new ListNode(-1,head);
        ListNode* fast = dummy;
        ListNode* slow = dummy;
        while(n--){
            fast = fast->next;
        }
        while(fast->next){
            slow = slow->next;
            fast = fast->next;
        }
        slow->next = slow->next->next;
        return dummy->next;
    }
};
```



# [11. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

**栈**

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> sta;
        for(auto x : s){
            if(sta.empty()){
                sta.push(x);
            }
            else if
              (x == ')' && sta.top() == '(' || 
               x == '}' && sta.top() == '{' || 
               x == ']' && sta.top() == '[')
            {
                sta.pop() ;
            }else{
                sta.push(x);
            }
        }
        return sta.empty();
    }
};
```

# [12. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(!list1) return list2;
        if(!list2) return list1;
        ListNode* dummy = new ListNode(-1);
        ListNode* cur = dummy;
        ListNode* prev = nullptr;
        while(list1 && list2){
            if(list1->val > list2->val){
                cur->next = list2;
                list2 = list2->next;
                prev = cur;
                cur = cur->next;
            }else{
                cur->next = list1;
                list1 = list1->next;
                prev = cur;
                cur = cur->next;
            }
        }
        if(list1) cur->next = list1;
        if(list2) cur->next = list2;

        return dummy->next;
    }
};
```

# [13. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

**回溯：**

- 添加括号的过程中，一定是优先添加左括号，然后添加右括号
- 递归终止条件——当前路径长度==2n
- 递归参数：
  - 用两个变量left和right用于记录当前左右括号的数量
- 递归逻辑
  - 如果左括号数量小于n,则添加一个左括号，递归下一层
  - 如果右括号数量小于n,且小于左括号数量，则添加一个右括号，递归下一层

**代码：**

```c++
class Solution {
public:
    vector<string> res;
    string path;
    void backTracking(int n, int left, int right)
    {
        if(path.size() == 2 * n){
            res.push_back(path);
            return;
        }
        
        if(left < n)
        {
            path += '(';
            left++;
            backTracking(n,left, right);
            left--;
            path.pop_back();
        }
        if(right < n && right < left)
        {
            path += ')';
            right++;
            backTracking(n,left,right);
            right--;
            path.pop_back();
        } 
    }
    vector<string> generateParenthesis(int n) {
        backTracking(n,0,0);
        return res;
    }
};
```

# [14. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

## 法一：根据合并双链表的方法，依次合并所有链表

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode *ans = nullptr;
        for (size_t i = 0; i < lists.size(); ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }
};
```

## 法二：分治合并

**作为法一的优化方法，对链表数组中的链表两两配对合并**

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* merge(vector <ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};

```

## 法三：优先队列

```c++
class Solution {
public:
    struct comp {
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };

    priority_queue<ListNode*, vector<ListNode*>, comp> q;

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        for (auto node: lists) {
            if (node) q.push(node);
        }
        ListNode* head = new ListNode();
        ListNode* tail = head;
        while (!q.empty()) {
            ListNode* node = q.top();
            q.pop();
            tail->next = node; 
            tail = tail->next;
            if (node->next) q.push(node->next);
        }
        return head->next;
    }
};
```



# [15. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        //从后往前遍历，找到第一个升序对(i,i+1)满足nums[i] < nums[i+1]
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        //从i+1至数组尾的所有元素一定满足降序排列
        //从后往前遍历，在i+1至数组尾元素中找到第一个大于nums[i]的元素
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            //交换两者
            swap(nums[i], nums[j]);
        }
        //交换后，nums[j]后的元素一定还是以降序排列，将其反转，使其变为升序排列
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

# [16. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

**动态规划**

-   `dp[i]:`以字符`s[i]`结尾的最长有小括号的长度
- **状态转移：**
  - 若`s[i] == '('`,显然此时`dp[i] = 0`,因为有小括号必然是以右括号结尾
  - 若`s[i] == ')'`
    - 若`s[i-1] == '('`，则两者组成一对括号，故`dp[i] = dp[i-2] + 2`
    - 若`s[i-1] == ')'`
      - 此时，若`s[i]`要组成有效括号对，则其之前的位置必须是有效括号对，即`dp[i-1]`必须是一个有效长度，则与`s[i]`配对的左括号的位置为           `s[i - dp[i-1] - 1]`,若`s[i - dp[i-1] - 1] == '('`，则`dp[i] = dp[i-1] + 2`
      - 还需要注意一点，以上情况是形如`((...))`，若`s[i]`组成的有效括号对形如`(...)((...))`,因此`dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        if(n == 0) return 0;
        vector<int> dp(n+1,0);
        int res = 0;
        for(int i = 1; i < n; i++)
        {
            if(s[i] == '(') dp[i] = 0;
            if(s[i] == ')')
            {
                if(s[i-1] == '('){
                    dp[i] = 2;
                    if(i >= 2) dp[i] += dp[i-2];
                }
                else if(s[i - 1] == ')')
                {
                    if(dp[i-1] > 0 && i - dp[i-1] - 1 >= 0 && s[i - dp[i-1] - 1] == '(')
                    {
                        dp[i] = dp[i-1] + 2;
                        if(i - dp[i-1] - 1 > 0)
                            dp[i] += dp[i - dp[i-1] -2];
                    }
                } 
            }
            res = max(res,dp[i]);
        }
        return res;
    }
};
```



# [17. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

- 原数组`A`为升序排列，经过旋转后分为两部分`A1与A2`
  - 两部分分别为升序数组，`A[0]`为`A1`最小值，`A[A.size()]`为`A2`最大值
  - 并且`A1`中所有值均大于`A2`
- 因此该题可以采用二分法
  - `若A[mid] >= A[0]`
    - `if (A[0] <= target && target < A[mid])`,则在A1中找
    - 否则，去A2寻找
  - `若A[mid] < A[0]`
    - ` if (A[mid] < target && target <= A[n - 1])`,则在A2中找
    - 否则，去A1寻找
  - `若target == A[0]`:则直接返回
- 代码：

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```



# [18. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

**二分法：**

- 假设目标值在有序数组中的下标范围为i ~ j;

  - 则其右边界r满足`nums[r] <= target`
  - 其左边界满足`nums[l] >= target`

- 二分：

- 与普通二分不同的是：

  - 普通二分：`if(nums[mid] == target) return mid`
  - 该题：
    - 查找左边界`if(nums[mid] == target) right = mid - 1;`
    - 查找右边界`if(nums[mid] == target) left = mid + 1`

  ```c++
  class Solution {
  public:
      vector<int> searchRange(vector<int>& nums, int target) {
          vector<int> res{-1,-1};
          if(nums.empty()) return res;
          int l = 0, r = nums.size() - 1;
          while(l <= r){
              int mid = (l + r)/2;
              if(nums[mid] >= target){
                  r = mid - 1;
              }else{
                  l = mid + 1;
              }
          }
          if(l >= nums.size() || nums[l] != target){
              return res;
          }
          else{
              res.clear();
              res.push_back(l);
              int i = 0, j = nums.size() - 1;
              while(i <= j){
                  int mid = i + j >> 1;
                  if(nums[mid] <= target){
                      i = mid + 1;
                  }else{
                      j = mid - 1;
                  }
              }
              res.push_back(j);
          }
          return res; 
      }
  };
  ```

  

  # [19. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

  **回溯三部曲**

  - 递归函数参数

    **此题为了避免重复情况，例如[2,2,3]和[3,2,2],需要设定一个startIndex，用于表示每次循环的起点，防止遍历已经遍历过的元素**

    ```c++
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
    ```

    

  - 递归终止条件

    当当前和等于给定值或者大于给定值时函数返回

    ```c++
      if(sum == target){
                res.push_back(path);
                return;
      }else if(sum > target) return;
    ```

    

  - 单层循环逻辑

    ```c++
    for(int i = startIndex; i < candidates.size(); i++){
          path.push_back(candidates[i]);
          sum += candidates[i];
        //与前面的组合问题不同，此处的startIndex不需要+1，表示可以重复选取元素
          backtracking(candidates,target,sum,i);
          sum -= candidates[i];
          path.pop_back();
    }
    ```

    

  **最终结果**

  ```c++
  class Solution {
  public:
      vector<vector<int>> res;
      vector<int> path;
      void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
      {
          if(sum == target){
              res.push_back(path);
              return;
          }else if(sum > target) return;
  
          for(int i = startIndex; i < candidates.size(); i++){
              path.push_back(candidates[i]);
              sum += candidates[i];
              backtracking(candidates,target,sum,i);
              sum -= candidates[i];
              path.pop_back();
          }
      }
      vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
          backtracking(candidates,target,0,0);
          return res;
      }
  };
  ```

  

  **剪枝优化**

  ```c++
  for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
  ```

  

# [19. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

**单调栈：**

- 采用递减栈，栈内存储下标，若当前元素大于栈顶元素，则需要弹出栈顶元素直至栈顶元素大于当前元素
  - 因为若当前元素大于栈顶元素，则表示当前元素与栈顶元素之间存在了凹槽，可以收集雨水
  - 栈顶元素为凹槽底部，栈顶第二个元素就是凹槽左边的柱子，当前元素就是凹槽右边的柱子
  - 如果遇到相同元素，就更新栈顶元素为新元素下标

**为了保证不遗漏，在给定数组尾部加入一个0，保证所有元素都被计算到，如果不加0，当给定数组是递增数组时，栈将不会推出元素**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        heights.push_back(0);
        stack<int> s;
        int res = 0;
        for(int i = 0; i < heights.size(); i++)
        {
            while(!s.empty() && heights[s.top()] > heights[i])
            {
                int mid = s.top();
                int h = heights[mid];
                int w = i;
                s.pop();
                if(!s.empty())
                {   
                    w = i - s.top() - 1;
                }
                res = max(res, h *  w);
            }
            s.push(i);
        }
        return res;
    }
};
```



# [20. 全排列](https://leetcode-cn.com/problems/permutations/)

**回溯**

该题给定数组不包含重复元素，因此只需要保证每次选取数字时不要选取之前已经选过的元素，因此可以使用一个数组来记录当前元素是否已经选取过

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int>& nums, vector<bool>& used){
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            if(used[i] == true) continue;
            path.push_back(nums[i]);
            used[i] = true;
            backTracking(nums, used);
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        backTracking(nums, used);
        return res;
    }
};
```



# [21. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

找规律：

`matrix1[col][n−row−1]=matrix[row][col]`

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        if(matrix.empty()) return ;
        int len = matrix.size();
        int i = 0;
        while(i < len / 2)
        {
            for(int j = i; j < len - i - 1 ; j++)
            {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[len-1-j][i];
                matrix[len-1-j][i] = matrix[len-1-i][len-1-j];
                matrix[len-1-i][len-1-j] = matrix[j][len-1-i];
                matrix[j][len-1-i] = temp;
            }
            i++;
        }
    }
};
```



# [22. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)



**哈希表运用**

将单词排序后的结果作为键值key，**字母异位词**排序后的结果应该是一样的，因此以字母异位词组合为value

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>>hash;
        for(auto str : strs){
            string key = str;
            sort(key.begin(),key.end());
            hash[key].push_back(str);
        }
        vector<vector<string>> res;
        for(auto x : hash){
            res.push_back(x.second);
        }
        return res;
    }
};
```



# [23. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

**动态规划：**

- `dp[i]:`以元素`nums[i]`结尾的连续子数组的最大和

- 转移方程：考虑`nums[i]`单独成为一段，还是加入`dp[i-1]`对应的那一段

  - ```c++
    dp[i] = max(dp[i-1] + nums[i], nums[i]);
    ```

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        int res = nums[0];
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] + dp[i-1] < 0 ) dp[i] = max(nums[i],nums[i] + dp[i-1]);
            else
                dp[i] = max(dp[i-1] + nums[i],nums[i]);

            if (dp[i] > res) res = dp[i];
        }
        return res;
    }
};
```



**也可以采用滚动数组**

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0, res = nums[0];
        for(const auto &x : nums){
            pre = max(x, pre + x);
            res = max(res, pre);
        }
        return res;
    }
};
```



# [24. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

**贪心：**

**遍历每一个元素，实时维护从当前位置可以到达的最远位置，如果最远位置超出了数组边界，则表示可以到达**

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.empty()) return false;
        int cover = 0;
        for(int i = 0; i <= cover; i++){
            cover = max(cover, nums[i] + i);
            if(cover >= nums.size() - 1)
                return true;
        }
        return false;
    }
};
```



# [25. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

**总体思路就是：先将数组元素按照首元素大小从小到大排序，然后逐个进行合并操作——前一个元素的末尾元素大于后一个元素的的首元素时，两者可以合并，特别注意一点，合并时并不是简单的分别取两个元素的首尾元素，而是还要再比较一下前一个元素的末尾元素与后一个元素的末尾元素，取其大者，之所以这样做，是考虑到两个数组可能存在包含关系**

**代码实现：**

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        if(intervals.empty()) return res;
        sort(intervals.begin(), intervals.end(),[&](vector<int> a, vector<int> b){
            return a[0] < b[0];
        });
        res.push_back(intervals[0]);
        for(int i = 1; i < intervals.size(); i++){
            if(intervals[i][0] <= res.back()[1]){
                //前一个元素的末尾元素与后一个元素的末尾元素，取其大者
                res.back()[1] = max(intervals[i][1],res.back()[1]);
            }else{
                res.push_back(intervals[i]);
            }
        }
        return res;
    }
};
```



# [26. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

动态规划：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n,0));
        dp[0][0] = 1;
        for(int i = 1; i < m; i++) dp[i][0] = 1;
        for(int i = 1; i < n; i++) dp[0][i] = 1;
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```



# [27. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

**动态规划：**

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = grid[0][0];
        for(int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int i = 1; i < n; i++) dp[0][i] = dp[0][i-1] + grid[0][i];

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
};
```



# [28. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

**动态规划**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```



# [29. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

**动态规划**

- `dp[i][j]：word1的前i个字符串转换成word2的前j个子字符串所使用的最少操作`
- 状态转移：
  - 若`word1[i-1] == word2[j-1]`，则`dp[i][j] = dp[i-1][j-1]`
  - 若`word1[i-1] != word2[j-1]`，此时可以使用增删改来改动字符串
    - 在`word1[i-12]`末尾添加字符：`dp[i][j] = dp[i-1][j] + 1`
    - 在`word2[j-2]`末尾添加字符：`dp[i][j] = dp[i][j-1] + 1`
    - 修改`word1[i-1]`或者修改`word2[j-1]`：`dp[i][j] = dp[i-1][j-1] + 1`

**代码：**

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size();
        int n2 = word2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
        for(int i = 0; i <= n1; i++) dp[i][0] = i;
        for(int i = 0; i <= n2; i++) dp[0][i] = i;
        for(int i = 1; i <= n1; i++){
            for(int j = 1; j <= n2; j++){
                if(word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = min(dp[i-1][j] + 1,min(dp[i][j-1] + 1, dp[i-1][j-1] + 1));
            }
        }
        return dp[n1][n2];
    }
};
```



# [30. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

**双指针**

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
       //双指针
        int n = nums.size();
        int p = 0, q = n - 1;
        for (int i = 0; i <= q; ++i) {
            if (nums[i] == 0) {
                nums[i] = nums[p];
                nums[p] = 0;
                ++p;
            }
            if (nums[i] == 2) {
                nums[i] = nums[q];
                nums[q] = 2;
                --q;
                if (nums[i] != 1) {
                    --i;
                }
            }
        }
        return;
    }
};
```



# [31. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

滑动窗口

**用一个哈希表`ht`记录字符串`t`的字符，用另一个哈希表`hs`记录当前窗口中的元素**

**代码：**

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        string res;
        unordered_map<char,int> hs;
        unordered_map<char,int> ht;
        for(auto x : t) ht[x]++;
        //用于记录,每在窗口中加入一个所需元素，该数加一，cnt == t.size()时表明窗口内是一个符合条件的最小子串
        int cnt = 0;
        //i , j 分别为窗口的左右两边界
        for(int i = 0, j = 0; j < s.size(); j++){
            //窗口向右移动
            hs[s[j]]++;
            //如果当前元素是t中的字符，
            if(hs[s[j]] <= ht[s[j]]) cnt++;
            //窗口左边界收缩
            while(hs[s[i] > ht[s[i]]]) hs[s[i++]]--;
            //找到一个符合条件的最小字串
            if(cnt == t.size()){
                if(res.empty() || res.size() > j - i + 1)
                    res = s.substr(i,j - i + 1);
            }
        }
        return res;
    }
};
```



# [32. 子集](https://leetcode-cn.com/problems/subsets/)

**回溯**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums,int startIndex)
    {
        res.push_back(path);
        if(startIndex > nums.size()) return;
        for(int i = startIndex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backtracking(nums,i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums,0);
        return res;
    }
};
```



# [33. 单词搜索](https://leetcode-cn.com/problems/word-search/)

**回溯**

```c++
class Solution {
public:
    bool backTracking(vector<vector<char>>& board, const string& word, int startIndex, int x, int y)
    {
        if(board[x][y] != word[startIndex]) return false;
        if(startIndex == word.size() - 1){
            return true;
        }

        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};

        char temp = board[x][y];
        board[x][y] = '*';
        for(int i = 0; i < 4; i++){
            int a = x + dx[i];
            int b = y + dy[i];
            if(a >= 0 && a < board.size() && b >= 0 && b < board[a].size()){
                if(backTracking(board,word,startIndex + 1, a, b)) return true;
            }
        }
        board[x][y] = temp;
        return false;

    }
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++){
            for(int j = 0; j < board[0].size(); j++){
                if(backTracking(board,word,0,i,j))
                    return true;
            }
        }
        return false;
    }
};
```



# [34. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

**单调栈**

**参考暴力解法：对一个柱子，枚举以其为矩形高度所能得到的最大面积**

使用单调栈的话，首先要确定栈内元素，该题栈内应该存储下标，便于计算矩形底边长度，其次，确定使用递增栈还是递减栈，，对于该题，由于要以一个柱子的高度为矩形的高度，因此，栈内元素应该为递增，因为只要下一个元素大于栈顶元素，以栈顶元素为高度的矩形底边就能一直扩展。

**举个例子：下标为0的柱子高度为2，下标为1的柱子高度为1，第一个元素先入栈，遍历到第二个元素时，由于1比2小，因此以2为高度的矩形此时无法在向右扩张，此时须计算出其最大面积**

**代码：**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        heights.push_back(0);
        stack<int> s;
        int res = 0;
        for(int i = 0; i < heights.size(); i++)
        {
            while(!s.empty() && heights[s.top()] > heights[i])
            {
                int mid = s.top();
                int h = heights[mid];
                int w = i;
                s.pop();
                if(!s.empty())
                {   
                    w = i - s.top() - 1;
                }
                res = max(res, h *  w);
            }
            s.push(i);
        }
        return res;
    }
};
```



# [35. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

**该题其实是[34. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)的变形，将给定矩形的每一行统计成柱状图，然后分别求最大矩形**

```c++
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.empty() || matrix[0].empty()) return 0;
        int res = 0;
        vector<int> heights(matrix[0].size(),0);

        for(int i = 0; i < matrix.size(); i++)
        {
            for(int j = 0; j < matrix[0].size();j++)
            {
                if(matrix[i][j] == '1') heights[j] += 1;
                else heights[j] = 0;
            }
            res = max(res, largestRectangleArea(heights));
        }
        return res;

    }

    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        heights.push_back(0);
        stack<int> s;
        int res = 0;
        for(int i = 0; i < heights.size(); i++)
        {
            while(!s.empty() && heights[s.top()] > heights[i])
            {
                int mid = s.top();
                int h = heights[mid];
                int w = i;
                s.pop();
                if(!s.empty())
                {   
                    w = i - s.top() - 1;
                }
                res = max(res, h *  w);
            }
            s.push(i);
        }
        return res;
    }
};
```



# [36. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**递归写法：**

```c++
class Solution {
public:
    vector<int> res;
    void dfs(TreeNode* node){
        if(node){
            dfs(node->left);
            res.push_back(node->val);
            dfs(node->right);
        }
    }
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

**迭代写法：**

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```



# [37. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

**动态规划：**

**思路：[代码随想录 (programmercarl.com)](https://programmercarl.com/0096.不同的二叉搜索树.html#思路)**

- `dp[i]`:节点值为1~i可以构成的二叉搜索树数量
- 二叉搜索树的右子树大于根节点值，左子树小于根节点值，因此，对于给定值n,我们可以从该方面思考一共可以组成的二叉搜索树数量：
  - 以`1~n`分别为根节点：
    - 以1为根节点值，则共有`dp[0] * dp[n-1]`种情况，即左子树为空，右子树有`n-1`个节点
    - 以2为根节点值，则共有`dp[1] * dp[n-2]`种情况，即左子树有一个节点，右子树有`n-2`个节点
    - 由此递归，以n为根节点值，则共有`dp[n-1] * dp[0]`种情况，即左子树有`n-1`个节点，右子树为空
- 将以上所有情况相加，即为最终答案
- 因此递归状态转移方程为：
  - `dp[i] += dp[j-1] * dp[i-j],j从1到i依次取值`

**代码：**

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= i; j++)
                dp[i] += dp[j - 1] * dp[i - j];

        return dp[n];
    }
};
```

# [38. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

**二叉搜索数的中序遍历序列为升序序列，根据规则，可以先求出给定二叉树的中序遍历，然后判断是否为升序序列**

```c++
class Solution {
public:
    vector<int> res;
    void dfs(TreeNode* root){
        if(!root) return;
        dfs(root->left);
        res.push_back(root->val);
        dfs(root->right);
    }
    bool isValidBST(TreeNode* root) {
        dfs(root);
        for(int i = 1; i < res.size(); i++){
            if(res[i] <= res[i-1]) return false;
        }
        return true;
    }
};
```

**或者利用迭代中序遍历，遍历的同时进行判断**

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> s;
        long long pre = (long long)INT_MIN - 1;
        TreeNode* cur = root;
        while(!s.empty() || cur != nullptr){
            while(cur){
                s.push(cur);
                cur = cur->left;
            } 
            cur = s.top();
            s.pop();
            if(cur->val <= pre) return false;
            pre = cur->val;
            cur = cur->right;           
        }
        return true;
    }
};
```

**还可以直接递归判断**

```c++
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```



# [39. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

**由题意可知：对于对称二叉树的根节点，其左右子树成镜像对称，由此思路展开，代码如下：**

```c++
class Solution {
public:
    bool isMirror(TreeNode* root1, TreeNode* root2)
    {
        if(!root1 && !root2) return true;
        if(!root1 && root2) return false;
        if(root1 && !root2) return false;
        if(root1->val == root2->val) return isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);
        return false;
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isMirror(root->left,root->right);
    }
};
```

**迭代写法**

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        while (!que.empty()) {  // 接下来就要判断这这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```



# [40. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if(!root) return res;
        q.push(root);
        while(!q.empty())
        {
            int size = q.size();
            vector<int> temp;
            for(int i = 0; i < size; i++)
            {
                TreeNode* cur = q.front();
                q.pop();
                temp.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right); 
            }
            res.push_back(temp);
        }
        return res;
    }
};
```



# [41. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**可以利用层序遍历，即广度优先搜索，每遍历一层记录一下，最终结果就是最大深度，代码如下：**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode* cur = q.front();
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
                q.pop();
                if(i == size - 1)
                    res++;
            }
        }  
        return res;
    }
};
```

**也可以利用深度优先搜索，代码如下：**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```



# [42. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

**前序遍历序列构造为——根 左 右， 中序遍历序列为——左 根 右**

**因此，每次取前序序列的首元素root，其必为二叉树的根节点，同时，在中序序列中，该元素将序列分为两部分，即，中序序列中，root左边的所有元素为root的左子树元素，root右边的所有元素为root的右子树元素，然后在两个序列中继续上述步骤，首先从前序序列中找到根节点，然后在中序序列中分割，递归的构造二叉树**

**代码如下：**

```c++
class Solution {
public:
/*
    前序遍历---根左右
    中序遍历---左根右
    前序遍历的首元素为根的val，然后根据根的val去中序遍历中找到左右子树的元素，然后递归构建
*/
    unordered_map<int,int> hash;

    TreeNode* buildDfs(vector<int>& preorder, vector<int>& inorder, int pl, int pr, int il, int ir)
    {
        //递归终止条件
        if(pl > pr || il > ir) return nullptr;
        //根据前序遍历首元素构造根节点
        TreeNode* root = new TreeNode(preorder[pl]);
        //寻找根节点元素在中序遍历中的下标
        int index = hash[preorder[pl]];
		// 左子树元素个数为 index - il
        root->left = buildDfs(preorder, inorder, pl + 1, pl + 1 + index - il - 1, il, index - 1);
        root->right = buildDfs(preorder, inorder, pl + 1 + index - il - 1 + 1, pr , index + 1, ir);

        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.empty()) return nullptr;
        for(int i = 0; i <inorder.size();i++)
            hash[inorder[i]] = i;

        return buildDfs(preorder,inorder,0,preorder.size()-1, 0, inorder.size()-1);
    }
};
```



# [43. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

**题目要求链表元素顺序与二叉树先序遍历结果相同,观察先序遍历特点，可以按如下步骤进行展开**

1. 对于当前节点`cur`，判断其左子节点`cur->left`是否为空
   1. 左子节点为空`cur->left == nullptr`，对下一个节点进行展开`cur = cur->right`
   2. 左子节点不为空，**找到左子树中的最右边的节点`prev`，将当前节点的右子树赋给最右节点的右子树`prev->right = cur->right`**
   3. 将当前节点左子树赋给右子节点，即`cur->right = cur->left`，然后将当前节点左子节点置空`cur->left = nullptr`

```c++
class Solution {
public:
    void flatten(TreeNode* root) {
        if(!root) return;
        TreeNode* cur = root;
        while(cur)
        {
            if(cur->left){
                TreeNode* next = cur->left;
                TreeNode* prev = next;
                while(prev->right)
                    prev = prev->right;

                prev->right = cur->right;

                cur->right = cur->left;
                cur->left = nullptr;
            }
            cur = cur->right; 
        }
    }
};
```



# [44. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**方法一：遍历数组，维护一个最小值`cur`，不断更新最大利润**

- 若当前元素`price[i]`比`cur`小，则更新`cur = price[i]`
- 不断更新最大利润`res = max(res, prices[i] - cur)`

**代码：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res = 0;
        int cur = INT_MAX;
        for(int i = 0; i < prices.size(); i++){
            cur = cur < prices[i] ? cur : prices[i];
            res = max(res, prices[i] - cur);
        }
        return res;
    }
};
```



**方法二：动态规划**

- `dp[i][j]`:`i`表示第`i`天，`j = 0 或 1`
  - `dp[i][0]`表示第 `i` 天持有股票
  - `dp[i][1]`表示第 `i` 天不持有股票
- **初始状态**：一开始现金为0，`dp[0][0] -= price[i], dp[0][1] = 0 `
- **状态转移方程**：
  - 第一种情况，若第`i`天**持有**股票
    - 延续第`i-1`天 的股票持有情况，则`dp[i][0] = dp[i-1][0]`
    - 在第`i`天买入股票，则`dp[i][0] -= price[i]`
    - **综上，`dp[i][0] = max(dp[i-1][0], -price[i])`**
  - 第二种情况，如第`i`天**不持有**股票
    - 延续第`i-1`天 的股票不持有情况，则`dp[i][1] = dp[i-1][1]`
    - 在第`i`天卖出股票，则`dp[i][1] = dp[i-1][0] + price[i]`
    - **综上，`dp[i][1] = max(dp[i-1][1], dp[i-1][0] + price[i])`**
- **最终结果：**返回`dp[len-1][1]`,在本题全程只允许买卖一次的情况下，肯定**不持有状态下利益大**

**代码：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        /*
            dp[i][j]: i表示第i天，j = 0 或 1，
            dp[i][0]表示第 i 天持有股票
            dp[i][1]表示第 i 天不持有股票
        */
        int n = prices.size();
        vector<vector<int>> dp(n,vector<int>(2,0));

        dp[0][0] -= prices[0];
        dp[0][1] = 0;

        for(int i = 1; i < n; i++)
        {
            dp[i][0] = max(dp[i-1][0],-prices[i]);
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i]);
        }
        return dp[n-1][1];
    }
};
```



# [45. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

**思路：**

该题中的最大路径和，其实就是每个节点与其左右子树中的最大节点值之和

该题可以采用**后序遍历**，先求出叶子节点的**贡献值**，贡献值即为节点值，然后求根节点的贡献值，根节点贡献值为`node.val + max(leftVal,rightVal)`,并且，最大路径和等于`node.val + leftVal + rightVal`,实时更新最大路径和

**代码：**

```c++
class Solution {
private:
    int maxSum = INT_MIN;

public:
    int maxGain(TreeNode* node) {
        if (node == nullptr) {
            return 0;
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = max(maxGain(node->left), 0);
        int rightGain = max(maxGain(node->right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node->val + leftGain + rightGain;

        // 更新答案
        maxSum = max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node->val + max(leftGain, rightGain);
    }

    int maxPathSum(TreeNode* root) {
        maxGain(root);
        return maxSum;
    }
};
```



# [46. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

**运用哈希表存储数组中所有元素，然后遍历寻找连续序列**

- 寻找过程中可以进行一些优化，为了避免遍历完`x , x+1, ..., y`后，下次循环又从`x+1`开始寻找连续序列，在遍历时，可以先判断一下当前元素`x`的前驱元素`x-1`是否存在，因为`unordered_set`中的元素是按升序排列的，如果前驱元素存在，说明在对前驱元素寻找连续序列时已经包含了当前元素



**代码：**

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> hash;
        int res = 0;
        for(const auto num : nums){
            hash.insert(num);
        }
        for(const auto num : hash){
            int len = 1;
            if(hash.count(num - 1)){
                continue;
            }
            int cur = num;
            while(hash.count(cur + 1)){
                cur++;
                len++;
            }
            res = max(res,len);
        }
        return res;
    }
};
```



# [47. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

**异或运算：**

**A^0=A  A^A=0**,并且异或运算支持交换律和结合律，即**B^A^A=B  因为B^A^A=B^(A^A)=B^0=B**

**因此，对于该题，仅有一个元素出现一次，其他元素均出现两次，对所有元素进行异或运算，最终结果就是只出现了一次的元素**

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret = 0;
        for (auto e: nums) ret ^= e;
        return ret;
    }
};
```



# [48. 单词拆分](https://leetcode-cn.com/problems/word-break/)

- `dp[i]:字符串s前i个字母组成的字符串是否可以利用字典中的单词拼接出来`

- 状态转移方程：

  ​		从前往后计算考虑转移方程，每次转移的时候我们需要枚举包含位置 i-1*i*−1 的最后一个单词，看它是否出现在字典中以及除去这部分的字符串是否合法即可。

  ​		逐个划分s中的单词，`dp[i]`要为真，则`s[j] ~ s[i]`能从字典中拼接并且`s[0]~s[j-1]`也能从字典中拼接即`dp[j] == true`

  ​		**`dp[i]=dp[j] && check(s[j..i−1])`**

- 边界条件：

  - 我们定义 `dp[0] = true`表示空串且合法

**代码：**

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   
            for (int j = 0; j < i; j++) {       
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```



# [49. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

 **快慢指针，若有环，则一定会相遇，若无环，则最终两指针均指向空**

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head || !head->next) return false;
        ListNode* fast = head->next;
        ListNode* slow = head;
        while(slow != fast){
            if(!fast || !fast->next) return false;
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow == nullptr ? false : true;
    }
    
};
```



# [50. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

**法一：哈希表**

遍历链表中的每个节点，并将他记录下来，如果碰到了此前遍历过的节点，就可以判断链表存在环

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode *> visited;
        while (head != nullptr) {
            if (visited.count(head)) {
                return head;
            }
            visited.insert(head);
            head = head->next;
        }
        return nullptr;
    }
};
```

**法二：快慢指针**

![image-20220222105243011](F:\A3-git_repos\数据结构与算法_notes\图片\image-20220222105243011.png)

设环外部分长度为`a`，快慢指针在环上`A`点相遇，入口节点`B`与`A`的顺时针距离为b，`A `与`B `的顺时针距离为`c`，此时快指针已经在环内转了`n`圈，其走过的距离为`a +n(b + c) + b `,由于快指针每次走两步，慢指针每次走一步，因此快指针路程为慢指针的两倍，所以有`a +n(b + c) + b = 2(a + b)`，因此，

**`a = c + (n-1)(b+c)`**

因此，从相遇点到入环点的距离加上`n-1` 圈的环长，恰好等于从链表头部到入环点的距离

**定义两个指针index1 与 index2, index1 从头节点出发，一次走一步，index2 从相遇点出发，一次走一步，两者相遇时，相遇点即为环的入口节点**

**当n=1时，a = c, 当n>1时，这种情况和n为1的时候效果是一样的，一样可以通过这个方法找到环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点**

```c++
class Solution {
public:

    ListNode *detectCycle(ListNode *head) {
        if(!head || !head->next) return nullptr;
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast != NULL && fast->next != NULL){
            fast = fast->next->next;
            slow = slow->next; 
            if(fast == slow){
                ListNode* index1 = head;
                ListNode* index2 = slow;
                while(index1 != index2){
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index1;
            }
        }
        return nullptr;
    }
};
```



# [51. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

**哈希表加双向链表，通过哈希表实现时间复杂度为O(1)的查询操作，通过链表实现时间复杂度为O(1)的插入删除操作**

```c++
class LRUCache {
public:
    LRUCache(int capacity) : _capacity(capacity) {

    }
    
    int get(int key) {
        //若不存在，则返回-1
        if(hash.find(key) == hash.end()) return -1;
        //记录结果，然后要将该节点移到链表最前端
        int res = hash[key]->second;
        auto curNode = *hash[key];
        Cache.erase(hash[key]);
        Cache.push_front(curNode);
        hash[key] = Cache.begin();
        return res;
    }
    
    void put(int key, int value) {
        //若当前缓存中不存在key
        if(hash.find(key) == hash.end())
        {
            //如果缓存容量满了
            if(Cache.size() == _capacity)
            {
                //删除链表尾部节点
                auto node = Cache.back();
                hash.erase(node.first);
                Cache.pop_back();
            }
        }else{
            //若缓存中已存在key
            Cache.erase(hash[key]);
        }
        //将节点加入链表头部，并更新哈希表
        Cache.push_front({key,value});
        hash[key] = Cache.begin();
        
    }
private:
    int _capacity;
    //利用双向链表实现O(1)的插入操作
    list<pair<int,int>> Cache;
    //利用哈希表实现O(1)的查询操作 <key,链表节点指针>
    unordered_map<int,list<pair<int,int>>::iterator> hash;
};
```

**也可以自己定义双向链表**

```c++
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;

public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (!cache.count(key)) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode* node = new DLinkedNode(key, value);
            // 添加进哈希表
            cache[key] = node;
            // 添加至双向链表的头部
            addToHead(node);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode* removed = removeTail();
                // 删除哈希表中对应的项
                cache.erase(removed->key);
                // 防止内存泄漏
                delete removed;
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



# [52. 排序链表](https://leetcode-cn.com/problems/sort-list/)

**法一：自顶向下归并排序**

1. 找到链表中点（这里可以使用快慢指针），将链表分为两个子链表
2. 对两个子链表分别排序
3. 将两个排序后的子链表合并，得到完整的链表

可以用递归实现上述过程，递归终止条件为链表为空或者链表只包含一个节点

```c++
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return sortList(head, nullptr);
    }

    ListNode* sortList(ListNode* head, ListNode* tail) {
        if (head == nullptr) {
            return head;
        }
        if (head->next == tail) {
            head->next = nullptr;
            return head;
        }
        ListNode* slow = head, *fast = head;
        while (fast != tail) {
            slow = slow->next;
            fast = fast->next;
            if (fast != tail) {
                fast = fast->next;
            }
        }
        ListNode* mid = slow;
        return merge(sortList(head, mid), sortList(mid, tail));
    }

    ListNode* merge(ListNode* head1, ListNode* head2) {
        ListNode* dummyHead = new ListNode(0);
        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;
        while (temp1 != nullptr && temp2 != nullptr) {
            if (temp1->val <= temp2->val) {
                temp->next = temp1;
                temp1 = temp1->next;
            } else {
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }
        if (temp1 != nullptr) {
            temp->next = temp1;
        } else if (temp2 != nullptr) {
            temp->next = temp2;
        }
        return dummyHead->next;
    }
};
```

时间复杂度是`O(nlogn)`

空间复杂度是`O(logn)`，主要是递归产生的栈空间调用

**法二：自底向上归并排序**

要实现`o(1)`的空间复杂度，就需要使用自底向上的归并排序，**用迭代取代递归**，首先求得链表的长度，然后将链表拆分成子链表进行合并。

每轮合并操作针对的子链表都是**固定长度**：

1. 第一轮合并时每个单位长度为**1**，合并完成后长度变为**2**
2. 第二轮合并时每个单位长度为**2**，合并完成后长度变为**4**

依次类推，若要采用迭代的方法，可以仅根据固定长度计算每个单元边界，并完成链表的合并操作

1. 当长度为1时，将链表第**1**和第**2**节点排序合并，第**3**和第**4**节点排序合并........
2. 当长度为2时，将链表第**1~2**和第**3~4**节点排序合并，第**5~6**和第**7~8**节点排序合并........

**代码：**

```c++
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr) {
            return head;
        }
        int length = 0;
        ListNode* node = head;
        while (node != nullptr) {
            length++;
            node = node->next;
        }
        ListNode* dummyHead = new ListNode(0, head);
        for (int subLength = 1; subLength < length; subLength <<= 1) {
            ListNode* prev = dummyHead, *curr = dummyHead->next;
            while (curr != nullptr) {
                ListNode* head1 = curr;
                for (int i = 1; i < subLength && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                ListNode* head2 = curr->next;
                curr->next = nullptr;
                curr = head2;
                for (int i = 1; i < subLength && curr != nullptr && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                ListNode* next = nullptr;
                if (curr != nullptr) {
                    next = curr->next;
                    curr->next = nullptr;
                }
                ListNode* merged = merge(head1, head2);
                prev->next = merged;
                while (prev->next != nullptr) {
                    prev = prev->next;
                }
                curr = next;
            }
        }
        return dummyHead->next;
    }

    ListNode* merge(ListNode* head1, ListNode* head2) {
        ListNode* dummyHead = new ListNode(0);
        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;
        while (temp1 != nullptr && temp2 != nullptr) {
            if (temp1->val <= temp2->val) {
                temp->next = temp1;
                temp1 = temp1->next;
            } else {
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }
        if (temp1 != nullptr) {
            temp->next = temp1;
        } else if (temp2 != nullptr) {
            temp->next = temp2;
        }
        return dummyHead->next;
    }
};
```



# [53. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

**数组中可能存在负数，因此存在一种可能，当遇到负数时，当前最大值变为了最小值，若之后再遇到一个负数，则最小值则又变为了最大值，因此求解该题过程中，既要维护一个最大值，还要维护一个最小值，遇到负数时，两者互相交换，但是也可能存在整个数组只存在一个负数的情况，因此连乘过程中还要实时维护结果**

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        if(!n) return 0;
        int mmax = 1;
        int mmin = 1;
        int res = nums[0];
        for(int i = 0; i < n; i++)
        {
            if(nums[i] < 0)
            {
                swap(mmax,mmin);
            }
            mmax = max(nums[i],mmax * nums[i]);
            mmin = min(nums[i],mmin * nums[i]);

            res = max(res,mmax);
        }
        return res;
    }
};
```



# [54. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```c++
class MinStack {
public:
    stack<pair<int,int>> sta;
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int val) {
        if(sta.empty())
        {
            sta.push({val,val});
        }else{
            sta.push({val,min(sta.top().second,val)});
        }    
    }
    
    void pop() {
        sta.pop();
    }
    
    int top() {
        return sta.top().first;
    }
    
    int getMin() {
        return sta.top().second;
    }
};
```



# [55. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA || !headB) return NULL;
        ListNode* cur1 = headA, *cur2 = headB;
        while(cur1 != cur2){
            cur1 = cur1 == nullptr ? headB : cur1->next;
            cur2 = cur2 == nullptr ? headA : cur2->next;
        }
        return cur1;
    }
};
```



# [56. 多数元素](https://leetcode-cn.com/problems/majority-element/)

**若某元素个数超过数组总元素个数的一半，则排序后，数组元素肯定为该元素**

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int n = nums.size();
        return nums[n/2];
    }
};
```



# [57. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

**动态规划：**

- `dp[j]`:前`j`个房屋能偷的最大金额
- 状态转移方程：因为相邻房屋不能偷，所以`dp[j] = max(dp[j-1], dp[j-2] + nums[j-1])`
- 边界条件：`dp[0] = 0`

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n+1,0);
        for(int i = 1; i <= n; i++){
            dp[i] = max(dp[i-1],nums[i-1]);
            if(i > 1) dp[i] = max(dp[i], dp[i-2] + nums[i-1]);
        }
        return dp[n];
    }
};
```



# [58. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

