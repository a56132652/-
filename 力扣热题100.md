# [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**哈希表**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash;
        vector<int> res;
        for(int i = 0; i < nums.size(); i++)
        {
            if(hash.find(target - nums[i]) != hash.end()){
                res.push_back(hash[target - nums[i]]);
                res.push_back(i);
                return res;
            }else{
                hash[nums[i]] = i;
            }
        }
        return res;
    }
};
```



# [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**模拟**

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = nullptr;
        ListNode* tail = nullptr;
        int carry = 0;
        while(l1 || l2){
            int n1 = l1 ? l1->val : 0;
            int n2 = l2 ? l2->val : 0;
            int number = n1 + n2 + carry;
            carry = number / 10;
            number %= 10;
            if(!head) head = tail = new ListNode(number);
            else{
                tail->next = new ListNode(number);
                tail = tail->next;
            }
            if(l1) l1 = l1->next;
            if(l2) l2 = l2->next;
        }
        if(carry){
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```



# [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

**典型的滑动窗口**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       unordered_set<int> hash;
       int left = 0, right = 0;
       int res = 0;
       while(right < s.size())
       {
           while(hash.find(s[right]) != hash.end()){
               hash.erase(s[left]);
               left++;
           }
           hash.insert(s[right]);
           res = max(res,right - left + 1);
           right++;
       } 
       return res;
    }
};
```



# [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

**可以直接用暴力法，将两个数组合并，然后输出合并后数组的中位数，该方法时间复杂度`O(m+n)`**

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();
        if(!n1 && !n2) return 0;
        vector<int> temp;
        int i = 0, j = 0;
        while(i < n1 && j < n2){
            if(nums1[i] < nums2[j])
                temp.push_back(nums1[i++]);
            else
                temp.push_back(nums2[j++]);
        }
        if(i < n1){
            for(;i < n1;i++){
                temp.push_back(nums1[i]);
            }
        }
        if(j < n2){
            for(;j < n2;j++){
                temp.push_back(nums2[j]);
            }
        }
        int length = n1 + n2;
        if(length % 2 != 0) return temp[length/2];
        double res = (double)(temp[length/2 - 1] + temp[length/2]) / 2;
        return res;
    }
};
```



**也可以使用二分法**

```c++
class Solution {
public:
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int n = nums1.size();
		int m = nums2.size();

		if (n > m)  //保证数组1一定最短
		{
			return findMedianSortedArrays(nums2, nums1);
		}

		// Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。
		int LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n;  //我们目前是虚拟加了'#'所以数组1是2*n长度

		while (lo <= hi)   //二分
		{
			c1 = (lo + hi) / 2;  //c1是二分的结果
			c2 = m + n - c1;

			LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];
			RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2];
			LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];
			RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2];

			if (LMax1 > RMin2)
				hi = c1 - 1;
			else if (LMax2 > RMin1)
				lo = c1 + 1;
			else
				break;
		}
		return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0;
	}
};
```



# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

**动态规划**

- `dp[i][j]`:字符串中第`i`到第`j`个字符组成的回文串的长度，若不是回文串，则长度为0
- 状态转移方程：
  - 若`s[i] == s[j]`
    - 如果`i == j`:则`dp[i][j] = 1`
    - 如果`i - j == 1`：则`dp[i][j] == 2`
    - 如果`dp[i+1][j-1] != 0`,则`dp[i][j] = dp[i+1][j-1] + 2`
  - 若`s[i] != s[j]`
    - `dp[i][j] == 0`
- 边界条件：
  - `dp[i][i] = 1`
- 最终答案即为`max(dp[i][j])`



**注意遍历顺序，首层循环必须从后往前遍历，即`for(int i = n-1; i >= 0; i--)`,因为在状态转移过程中，`dp[i][j]会利用到dp[i+1][j-1]`，所以必须先遍历`dp[i+1]`,然后遍历`dp[i]`**

**代码：**

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2) return s;
        string res = "";
        vector<vector<int>> dp(n,vector<int>(n,0));

        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j])
                {
                    if(i == j) dp[i][j] = 1;
                    else if(j - i == 1){
                        dp[i][j] = 2;
                    }
                    else if(dp[i + 1][j - 1]){
                        dp[i][j] = dp[i+1][j-1] + 2;
                    }
                }
                else{
                    dp[i][j] = 0;
                }
   
                if(dp[i][j] &&( res.size() < j - i + 1)){
                    res.clear();
                    res = s.substr(i,j - i + 1);
                }
            }
        }
        return res;
    }
};
```



# [6. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

## 1. 动态规划数组定义以及状态定义

- `dp[i][j]: 字符串s的前i个字符与模式串p的前j个字符的匹配情况`
- 若 `s[i-1] == p[j-1]`
  - `dp[i][j] = dp[i-1][j-1]`
- 若`s[i-1] != p[j-1]`
  - 若`p[j-1] == '.'`
    - `dp[i][j] == dp[i-1][j-1] `，该类情况可以合并到第一类中
  - 若`p[j-1] == '*'`
    - 则可以匹配0个`p[j-2]`或者匹配 1 个
      - 匹配 0 个时：`dp[i][j] = dp[i][j-2]`
      - 匹配 1 个时：`dp[i][j] = dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')`
  - 若`p[j-1]为小写字母`
    - 则`dp[i][j] = false`

**综上，一共可以分为两种情况，分别为`p[j-1] == '*' 或者 p[j-1] != '*'`**

## 2. DP数组初始化

- 当给定字符串以及模式串均为空是，两者当然是匹配的(空字符匹配空字符)

  - `dp[0][0] = true`

- 当模式字符串为空，而给定字符串不为空时，结果当然是false

  - `for(int i = 1; i <= ns; i++) dp[i][0] = false;`

- 当给定字符串为空，而模式字符串不为空时，只有当模式字符串的偶数位上为`*`时，两者才匹配

  - ```c++
    for(int i = 2; i <= np; i += 2){
               if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
           }
    ```



## 3. 代码

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int ns = s.size();
        int np = p.size();
        vector<vector<bool>> dp(ns+1,vector<bool>(np+1,false));
        dp[0][0] = true;
        for(int i = 1; i <= ns; i++) dp[i][0] = false;
        for(int i = 2; i <= np; i += 2){
            if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
        }

        for(int i = 1; i <= ns; i++)
        {
            for(int j = 1; j <= np; j++)
            {
                if(p[j-1] == '*'){
                    dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'));
                }else{
                    if(s[i-1] == p[j-1] || p[j-1] == '.')
                        dp[i][j] = dp[i-1][j-1];
                    else
                        dp[i][j] = false;
                }
            }
        }

        return dp[ns][np];
    }
};
```



# [7. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

![image-20211126155344279](C:\Users\Sakura\AppData\Roaming\Typora\typora-user-images\image-20211126155344279.png)

**可以看出容量大小取决于两端长度最短的那块板子**

- 利用双指针 `i j`分别指向数组两端
- 如果`heght[i] < height[j]` 则令左指针 `i`左移一位，否则，右指针`j`右移一位

## 双指针移动规律

- 双指针向内收缩时，容器底部长度肯定是减小的
  - 如果`heght[i] < height[j]`，此时若移动较大的指针，即`j--`，移动后的最小板子为`min(height[i],height[j-1])`，由于`height[j]`是较大的那个，因此移动后的容器体积肯定减小，不会增大
  - 如果`heght[i] < height[j]`，此时若移动较 小的指针，即`i++`，移动后的最小板子为`min(height[i-1],height[j])`，此时`height[i-1]`可能会增大，因此容器体积也有可能增大
- 因此每次移动较小的那个指针

## 正解：

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0, j = height.size() -1 ;
        int res = 0;
        while(i < j)
        {
              res = height[i] < height[j] ? 
                max(res, (j - i) * height[i++]): 
                 max(res, (j - i) * height[j--]); 
        }
        return res;
    }
};
```



# [8. 三数之和](https://leetcode-cn.com/problems/3sum/)

**排序+双指针**

为了保证不重复，可以先将数组排序，然后保证每重循环遍历的数字都不小于上一层循环，即保证`a <= b <= c`，并且对于每一层循环，相邻两次枚举的元素不可以重复

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int l = i + 1, r = nums.size() - 1;
            while(l < r){
                if(nums[i] + nums[l] + nums[r] == 0){
                    res.push_back(vector<int>{nums[i], nums[l++], nums[r--]});
                    while(l < r && nums[l] == nums[l-1]) l++;
                    while(l < r && nums[r] == nums[r+1]) r--;
                }else if(nums[i] + nums[l] + nums[r] > 0){
                    r--;
                }else{
                    l++;
                }
            }
        }
        return res;
    }
};
```



# [9. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

**回溯**

- 首先将数字与其代表的字符串映射
- 回溯三部曲
  - 确定递归参数及返回值
    - 递归函数传入输入的数字字符串，并且需要维护一个整型变量Index，表示遍历到了第几个数字
  - 确定递归终止条件——当前字符串长度等于给定字符串长度时，递归终止
  - 确定递归单层逻辑
    - 首先从给定字符串中分离出数字字符
    - 然后去映射数组中取出该数字对应的字符串
    - 遍历字符串，一一取出字符，并递归下一个数字

```c++
class Solution {
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    string s;
    void backtracking(const string& digits, int index) {
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';        // 将index指向的数字转为int
        string letters = letterMap[digit];      // 取数字对应的字符集
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);            // 处理
            backtracking(digits, index++);    // 递归，注意index+1，一下层要处理下一个数字了
            s.pop_back();                       // 回溯
        }
    }
    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if (digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
```

# [10. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

**典型双指针应用**

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head) return head;
        ListNode* dummy = new ListNode(-1,head);
        ListNode* fast = dummy;
        ListNode* slow = dummy;
        while(n--){
            fast = fast->next;
        }
        while(fast->next){
            slow = slow->next;
            fast = fast->next;
        }
        slow->next = slow->next->next;
        return dummy->next;
    }
};
```



# [11. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

**栈**

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> sta;
        for(auto x : s){
            if(sta.empty()){
                sta.push(x);
            }
            else if
              (x == ')' && sta.top() == '(' || 
               x == '}' && sta.top() == '{' || 
               x == ']' && sta.top() == '[')
            {
                sta.pop() ;
            }else{
                sta.push(x);
            }
        }
        return sta.empty();
    }
};
```

# [12. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(!list1) return list2;
        if(!list2) return list1;
        ListNode* dummy = new ListNode(-1);
        ListNode* cur = dummy;
        ListNode* prev = nullptr;
        while(list1 && list2){
            if(list1->val > list2->val){
                cur->next = list2;
                list2 = list2->next;
                prev = cur;
                cur = cur->next;
            }else{
                cur->next = list1;
                list1 = list1->next;
                prev = cur;
                cur = cur->next;
            }
        }
        if(list1) cur->next = list1;
        if(list2) cur->next = list2;

        return dummy->next;
    }
};
```

# [13. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

**回溯：**

- 添加括号的过程中，一定是优先添加左括号，然后添加右括号
- 递归终止条件——当前路径长度==2n
- 递归参数：
  - 用两个变量left和right用于记录当前左右括号的数量
- 递归逻辑
  - 如果左括号数量小于n,则添加一个左括号，递归下一层
  - 如果右括号数量小于n,且小于左括号数量，则添加一个右括号，递归下一层

**代码：**

```c++
class Solution {
public:
    vector<string> res;
    string path;
    void backTracking(int n, int left, int right)
    {
        if(path.size() == 2 * n){
            res.push_back(path);
            return;
        }
        
        if(left < n)
        {
            path += '(';
            left++;
            backTracking(n,left, right);
            left--;
            path.pop_back();
        }
        if(right < n && right < left)
        {
            path += ')';
            right++;
            backTracking(n,left,right);
            right--;
            path.pop_back();
        } 
    }
    vector<string> generateParenthesis(int n) {
        backTracking(n,0,0);
        return res;
    }
};
```

# [14. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

## 法一：根据合并双链表的方法，依次合并所有链表

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode *ans = nullptr;
        for (size_t i = 0; i < lists.size(); ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }
};
```

## 法二：分治合并

**作为法一的优化方法，对链表数组中的链表两两配对合并**

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* merge(vector <ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};

```

## 法三：优先队列

```c++
class Solution {
public:
    struct comp {
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };

    priority_queue<ListNode*, vector<ListNode*>, comp> q;

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        for (auto node: lists) {
            if (node) q.push(node);
        }
        ListNode* head = new ListNode();
        ListNode* tail = head;
        while (!q.empty()) {
            ListNode* node = q.top();
            q.pop();
            tail->next = node; 
            tail = tail->next;
            if (node->next) q.push(node->next);
        }
        return head->next;
    }
};
```



# [15. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        //从后往前遍历，找到第一个升序对(i,i+1)满足nums[i] < nums[i+1]
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        //从i+1至数组尾的所有元素一定满足降序排列
        //从后往前遍历，在i+1至数组尾元素中找到第一个大于nums[i]的元素
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            //交换两者
            swap(nums[i], nums[j]);
        }
        //交换后，nums[j]后的元素一定还是以降序排列，将其反转，使其变为升序排列
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

# [16. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

**动态规划**

-   `dp[i]:`以字符`s[i]`结尾的最长有小括号的长度
- **状态转移：**
  - 若`s[i] == '('`,显然此时`dp[i] = 0`,因为有小括号必然是以右括号结尾
  - 若`s[i] == ')'`
    - 若`s[i-1] == '('`，则两者组成一对括号，故`dp[i] = dp[i-2] + 2`
    - 若`s[i-1] == ')'`
      - 此时，若`s[i]`要组成有效括号对，则其之前的位置必须是有效括号对，即`dp[i-1]`必须是一个有效长度，则与`s[i]`配对的左括号的位置为           `s[i - dp[i-1] - 1]`,若`s[i - dp[i-1] - 1] == '('`，则`dp[i] = dp[i-1] + 2`
      - 还需要注意一点，以上情况是形如`((...))`，若`s[i]`组成的有效括号对形如`(...)((...))`,因此`dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        if(n == 0) return 0;
        vector<int> dp(n+1,0);
        int res = 0;
        for(int i = 1; i < n; i++)
        {
            if(s[i] == '(') dp[i] = 0;
            if(s[i] == ')')
            {
                if(s[i-1] == '('){
                    dp[i] = 2;
                    if(i >= 2) dp[i] += dp[i-2];
                }
                else if(s[i - 1] == ')')
                {
                    if(dp[i-1] > 0 && i - dp[i-1] - 1 >= 0 && s[i - dp[i-1] - 1] == '(')
                    {
                        dp[i] = dp[i-1] + 2;
                        if(i - dp[i-1] - 1 > 0)
                            dp[i] += dp[i - dp[i-1] -2];
                    }
                } 
            }
            res = max(res,dp[i]);
        }
        return res;
    }
};
```



# [17. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

- 原数组`A`为升序排列，经过旋转后分为两部分`A1与A2`
  - 两部分分别为升序数组，`A[0]`为`A1`最小值，`A[A.size()]`为`A2`最大值
  - 并且`A1`中所有值均大于`A2`
- 因此该题可以采用二分法
  - `若A[mid] >= A[0]`
    - `if (A[0] <= target && target < A[mid])`,则在A1中找
    - 否则，去A2寻找
  - `若A[mid] < A[0]`
    - ` if (A[mid] < target && target <= A[n - 1])`,则在A2中找
    - 否则，去A1寻找
  - `若target == A[0]`:则直接返回
- 代码：

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```



# [18. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

**二分法：**

- 假设目标值在有序数组中的下标范围为i ~ j;

  - 则其右边界r满足`nums[r] <= target`
  - 其左边界满足`nums[l] >= target`

- 二分：

- 与普通二分不同的是：

  - 普通二分：`if(nums[mid] == target) return mid`
  - 该题：
    - 查找左边界`if(nums[mid] == target) right = mid - 1;`
    - 查找右边界`if(nums[mid] == target) left = mid + 1`

  ```c++
  class Solution {
  public:
      vector<int> searchRange(vector<int>& nums, int target) {
          vector<int> res{-1,-1};
          if(nums.empty()) return res;
          int l = 0, r = nums.size() - 1;
          while(l <= r){
              int mid = (l + r)/2;
              if(nums[mid] >= target){
                  r = mid - 1;
              }else{
                  l = mid + 1;
              }
          }
          if(l >= nums.size() || nums[l] != target){
              return res;
          }
          else{
              res.clear();
              res.push_back(l);
              int i = 0, j = nums.size() - 1;
              while(i <= j){
                  int mid = i + j >> 1;
                  if(nums[mid] <= target){
                      i = mid + 1;
                  }else{
                      j = mid - 1;
                  }
              }
              res.push_back(j);
          }
          return res; 
      }
  };
  ```

  

  # [19. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

  **回溯三部曲**

  - 递归函数参数

    **此题为了避免重复情况，例如[2,2,3]和[3,2,2],需要设定一个startIndex，用于表示每次循环的起点，防止遍历已经遍历过的元素**

    ```c++
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
    ```

    

  - 递归终止条件

    当当前和等于给定值或者大于给定值时函数返回

    ```c++
      if(sum == target){
                res.push_back(path);
                return;
      }else if(sum > target) return;
    ```

    

  - 单层循环逻辑

    ```c++
    for(int i = startIndex; i < candidates.size(); i++){
          path.push_back(candidates[i]);
          sum += candidates[i];
        //与前面的组合问题不同，此处的startIndex不需要+1，表示可以重复选取元素
          backtracking(candidates,target,sum,i);
          sum -= candidates[i];
          path.pop_back();
    }
    ```

    

  **最终结果**

  ```c++
  class Solution {
  public:
      vector<vector<int>> res;
      vector<int> path;
      void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
      {
          if(sum == target){
              res.push_back(path);
              return;
          }else if(sum > target) return;
  
          for(int i = startIndex; i < candidates.size(); i++){
              path.push_back(candidates[i]);
              sum += candidates[i];
              backtracking(candidates,target,sum,i);
              sum -= candidates[i];
              path.pop_back();
          }
      }
      vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
          backtracking(candidates,target,0,0);
          return res;
      }
  };
  ```

  

  **剪枝优化**

  ```c++
  for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
  ```

  

# [19. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

**单调栈：**

- 采用递减栈，栈内存储下标，若当前元素大于栈顶元素，则需要弹出栈顶元素直至栈顶元素大于当前元素
  - 因为若当前元素大于栈顶元素，则表示当前元素与栈顶元素之间存在了凹槽，可以收集雨水
  - 栈顶元素为凹槽底部，栈顶第二个元素就是凹槽左边的柱子，当前元素就是凹槽右边的柱子
  - 如果遇到相同元素，就更新栈顶元素为新元素下标

**为了保证不遗漏，在给定数组尾部加入一个0，保证所有元素都被计算到，如果不加0，当给定数组是递增数组时，栈将不会推出元素**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        heights.push_back(0);
        stack<int> s;
        int res = 0;
        for(int i = 0; i < heights.size(); i++)
        {
            while(!s.empty() && heights[s.top()] > heights[i])
            {
                int mid = s.top();
                int h = heights[mid];
                int w = i;
                s.pop();
                if(!s.empty())
                {   
                    w = i - s.top() - 1;
                }
                res = max(res, h *  w);
            }
            s.push(i);
        }
        return res;
    }
};
```



# [20. 全排列](https://leetcode-cn.com/problems/permutations/)

**回溯**

该题给定数组不包含重复元素，因此只需要保证每次选取数字时不要选取之前已经选过的元素，因此可以使用一个数组来记录当前元素是否已经选取过

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int>& nums, vector<bool>& used){
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            if(used[i] == true) continue;
            path.push_back(nums[i]);
            used[i] = true;
            backTracking(nums, used);
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        backTracking(nums, used);
        return res;
    }
};
```



# [21. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

找规律：

`matrix1[col][n−row−1]=matrix[row][col]`

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        if(matrix.empty()) return ;
        int len = matrix.size();
        int i = 0;
        while(i < len / 2)
        {
            for(int j = i; j < len - i - 1 ; j++)
            {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[len-1-j][i];
                matrix[len-1-j][i] = matrix[len-1-i][len-1-j];
                matrix[len-1-i][len-1-j] = matrix[j][len-1-i];
                matrix[j][len-1-i] = temp;
            }
            i++;
        }
    }
};
```



# [22. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)



**哈希表运用**

将单词排序后的结果作为键值key，**字母异位词**排序后的结果应该是一样的，因此以字母异位词组合为value

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>>hash;
        for(auto str : strs){
            string key = str;
            sort(key.begin(),key.end());
            hash[key].push_back(str);
        }
        vector<vector<string>> res;
        for(auto x : hash){
            res.push_back(x.second);
        }
        return res;
    }
};
```



# [23. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

**动态规划：**

- `dp[i]:`以元素`nums[i]`结尾的连续子数组的最大和

- 转移方程：考虑`nums[i]`单独成为一段，还是加入`dp[i-1]`对应的那一段

  - ```c++
    dp[i] = max(dp[i-1] + nums[i], nums[i]);
    ```

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        int res = nums[0];
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] + dp[i-1] < 0 ) dp[i] = max(nums[i],nums[i] + dp[i-1]);
            else
                dp[i] = max(dp[i-1] + nums[i],nums[i]);

            if (dp[i] > res) res = dp[i];
        }
        return res;
    }
};
```



**也可以采用滚动数组**

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0, res = nums[0];
        for(const auto &x : nums){
            pre = max(x, pre + x);
            res = max(res, pre);
        }
        return res;
    }
};
```



# [24. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

**贪心：**

**遍历每一个元素，实时维护从当前位置可以到达的最远位置，如果最远位置超出了数组边界，则表示可以到达**

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.empty()) return false;
        int cover = 0;
        for(int i = 0; i <= cover; i++){
            cover = max(cover, nums[i] + i);
            if(cover >= nums.size() - 1)
                return true;
        }
        return false;
    }
};
```



# [25. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

**总体思路就是：先将数组元素按照首元素大小从小到大排序，然后逐个进行合并操作——前一个元素的末尾元素大于后一个元素的的首元素时，两者可以合并，特别注意一点，合并时并不是简单的分别取两个元素的首尾元素，而是还要再比较一下前一个元素的末尾元素与后一个元素的末尾元素，取其大者，之所以这样做，是考虑到两个数组可能存在包含关系**

**代码实现：**

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        if(intervals.empty()) return res;
        sort(intervals.begin(), intervals.end(),[&](vector<int> a, vector<int> b){
            return a[0] < b[0];
        });
        res.push_back(intervals[0]);
        for(int i = 1; i < intervals.size(); i++){
            if(intervals[i][0] <= res.back()[1]){
                //前一个元素的末尾元素与后一个元素的末尾元素，取其大者
                res.back()[1] = max(intervals[i][1],res.back()[1]);
            }else{
                res.push_back(intervals[i]);
            }
        }
        return res;
    }
};
```



# [26. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

动态规划：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n,0));
        dp[0][0] = 1;
        for(int i = 1; i < m; i++) dp[i][0] = 1;
        for(int i = 1; i < n; i++) dp[0][i] = 1;
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```



# [27. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

**动态规划：**

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = grid[0][0];
        for(int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int i = 1; i < n; i++) dp[0][i] = dp[0][i-1] + grid[0][i];

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
};
```



# [28. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

**动态规划**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```



# [29. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

**动态规划**

- `dp[i][j]：word1的前i个字符串转换成word2的前j个子字符串所使用的最少操作`
- 状态转移：
  - 若`word1[i-1] == word2[j-1]`，则`dp[i][j] = dp[i-1][j-1]`
  - 若`word1[i-1] != word2[j-1]`，此时可以使用增删改来改动字符串
    - 在`word1[i-12]`末尾添加字符：`dp[i][j] = dp[i-1][j] + 1`
    - 在`word2[j-2]`末尾添加字符：`dp[i][j] = dp[i][j-1] + 1`
    - 修改`word1[i-1]`或者修改`word2[j-1]`：`dp[i][j] = dp[i-1][j-1] + 1`

**代码：**

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size();
        int n2 = word2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
        for(int i = 0; i <= n1; i++) dp[i][0] = i;
        for(int i = 0; i <= n2; i++) dp[0][i] = i;
        for(int i = 1; i <= n1; i++){
            for(int j = 1; j <= n2; j++){
                if(word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = min(dp[i-1][j] + 1,min(dp[i][j-1] + 1, dp[i-1][j-1] + 1));
            }
        }
        return dp[n1][n2];
    }
};
```



# [30. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

**双指针**

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
       //双指针
        int n = nums.size();
        int p = 0, q = n - 1;
        for (int i = 0; i <= q; ++i) {
            if (nums[i] == 0) {
                nums[i] = nums[p];
                nums[p] = 0;
                ++p;
            }
            if (nums[i] == 2) {
                nums[i] = nums[q];
                nums[q] = 2;
                --q;
                if (nums[i] != 1) {
                    --i;
                }
            }
        }
        return;
    }
};
```



# [31. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

滑动窗口

**用一个哈希表`ht`记录字符串`t`的字符，用另一个哈希表`hs`记录当前窗口中的元素**

**代码：**

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        string res;
        unordered_map<char,int> hs;
        unordered_map<char,int> ht;
        for(auto x : t) ht[x]++;
        //用于记录,每在窗口中加入一个所需元素，该数加一，cnt == t.size()时表明窗口内是一个符合条件的最小子串
        int cnt = 0;
        //i , j 分别为窗口的左右两边界
        for(int i = 0, j = 0; j < s.size(); j++){
            //窗口向右移动
            hs[s[j]]++;
            //如果当前元素是t中的字符，
            if(hs[s[j]] <= ht[s[j]]) cnt++;
            //窗口左边界收缩
            while(hs[s[i] > ht[s[i]]]) hs[s[i++]]--;
            //找到一个符合条件的最小字串
            if(cnt == t.size()){
                if(res.empty() || res.size() > j - i + 1)
                    res = s.substr(i,j - i + 1);
            }
        }
        return res;
    }
};
```



# [32. 子集](https://leetcode-cn.com/problems/subsets/)

**回溯**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums,int startIndex)
    {
        res.push_back(path);
        if(startIndex > nums.size()) return;
        for(int i = startIndex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backtracking(nums,i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums,0);
        return res;
    }
};
```



# [33. 单词搜索](https://leetcode-cn.com/problems/word-search/)

**回溯**

