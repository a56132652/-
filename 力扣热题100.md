# [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**哈希表**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash;
        vector<int> res;
        for(int i = 0; i < nums.size(); i++)
        {
            if(hash.find(target - nums[i]) != hash.end()){
                res.push_back(hash[target - nums[i]]);
                res.push_back(i);
                return res;
            }else{
                hash[nums[i]] = i;
            }
        }
        return res;
    }
};
```



# [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**模拟**

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = nullptr;
        ListNode* tail = nullptr;
        int carry = 0;
        while(l1 || l2){
            int n1 = l1 ? l1->val : 0;
            int n2 = l2 ? l2->val : 0;
            int number = n1 + n2 + carry;
            carry = number / 10;
            number %= 10;
            if(!head) head = tail = new ListNode(number);
            else{
                tail->next = new ListNode(number);
                tail = tail->next;
            }
            if(l1) l1 = l1->next;
            if(l2) l2 = l2->next;
        }
        if(carry){
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```



# [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

**典型的滑动窗口**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       unordered_set<int> hash;
       int left = 0, right = 0;
       int res = 0;
       while(right < s.size())
       {
           while(hash.find(s[right]) != hash.end()){
               hash.erase(s[left]);
               left++;
           }
           hash.insert(s[right]);
           res = max(res,right - left + 1);
           right++;
       } 
       return res;
    }
};
```



# [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

**可以直接用暴力法，将两个数组合并，然后输出合并后数组的中位数，该方法时间复杂度`O(m+n)`**

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();
        if(!n1 && !n2) return 0;
        vector<int> temp;
        int i = 0, j = 0;
        while(i < n1 && j < n2){
            if(nums1[i] < nums2[j])
                temp.push_back(nums1[i++]);
            else
                temp.push_back(nums2[j++]);
        }
        if(i < n1){
            for(;i < n1;i++){
                temp.push_back(nums1[i]);
            }
        }
        if(j < n2){
            for(;j < n2;j++){
                temp.push_back(nums2[j]);
            }
        }
        int length = n1 + n2;
        if(length % 2 != 0) return temp[length/2];
        double res = (double)(temp[length/2 - 1] + temp[length/2]) / 2;
        return res;
    }
};
```



**也可以使用二分法**

```c++
class Solution {
public:
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int n = nums1.size();
		int m = nums2.size();

		if (n > m)  //保证数组1一定最短
		{
			return findMedianSortedArrays(nums2, nums1);
		}

		// Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。
		int LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n;  //我们目前是虚拟加了'#'所以数组1是2*n长度

		while (lo <= hi)   //二分
		{
			c1 = (lo + hi) / 2;  //c1是二分的结果
			c2 = m + n - c1;

			LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];
			RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2];
			LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];
			RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2];

			if (LMax1 > RMin2)
				hi = c1 - 1;
			else if (LMax2 > RMin1)
				lo = c1 + 1;
			else
				break;
		}
		return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0;
	}
};
```



# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

**动态规划**

- `dp[i][j]`:字符串中第`i`到第`j`个字符组成的回文串的长度，若不是回文串，则长度为0
- 状态转移方程：
  - 若`s[i] == s[j]`
    - 如果`i == j`:则`dp[i][j] = 1`
    - 如果`i - j == 1`：则`dp[i][j] == 2`
    - 如果`dp[i+1][j-1] != 0`,则`dp[i][j] = dp[i+1][j-1] + 2`
  - 若`s[i] != s[j]`
    - `dp[i][j] == 0`
- 边界条件：
  - `dp[i][i] = 1`
- 最终答案即为`max(dp[i][j])`



**注意遍历顺序，首层循环必须从后往前遍历，即`for(int i = n-1; i >= 0; i--)`,因为在状态转移过程中，`dp[i][j]会利用到dp[i+1][j-1]`，所以必须先遍历`dp[i+1]`,然后遍历`dp[i]`**

**代码：**

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2) return s;
        string res = "";
        vector<vector<int>> dp(n,vector<int>(n,0));

        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j])
                {
                    if(i == j) dp[i][j] = 1;
                    else if(j - i == 1){
                        dp[i][j] = 2;
                    }
                    else if(dp[i + 1][j - 1]){
                        dp[i][j] = dp[i+1][j-1] + 2;
                    }
                }
                else{
                    dp[i][j] = 0;
                }
   
                if(dp[i][j] &&( res.size() < j - i + 1)){
                    res.clear();
                    res = s.substr(i,j - i + 1);
                }
            }
        }
        return res;
    }
};
```



# [6. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

## 1. 动态规划数组定义以及状态定义

- `dp[i][j]: 字符串s的前i个字符与模式串p的前j个字符的匹配情况`
- 若 `s[i-1] == p[j-1]`
  - `dp[i][j] = dp[i-1][j-1]`
- 若`s[i-1] != p[j-1]`
  - 若`p[j-1] == '.'`
    - `dp[i][j] == dp[i-1][j-1] `，该类情况可以合并到第一类中
  - 若`p[j-1] == '*'`
    - 则可以匹配0个`p[j-2]`或者匹配 1 个
      - 匹配 0 个时：`dp[i][j] = dp[i][j-2]`
      - 匹配 1 个时：`dp[i][j] = dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')`
  - 若`p[j-1]为小写字母`
    - 则`dp[i][j] = false`

**综上，一共可以分为两种情况，分别为`p[j-1] == '*' 或者 p[j-1] != '*'`**

## 2. DP数组初始化

- 当给定字符串以及模式串均为空是，两者当然是匹配的(空字符匹配空字符)

  - `dp[0][0] = true`

- 当模式字符串为空，而给定字符串不为空时，结果当然是false

  - `for(int i = 1; i <= ns; i++) dp[i][0] = false;`

- 当给定字符串为空，而模式字符串不为空时，只有当模式字符串的偶数位上为`*`时，两者才匹配

  - ```c++
    for(int i = 2; i <= np; i += 2){
               if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
           }
    ```



## 3. 代码

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int ns = s.size();
        int np = p.size();
        vector<vector<bool>> dp(ns+1,vector<bool>(np+1,false));
        dp[0][0] = true;
        for(int i = 1; i <= ns; i++) dp[i][0] = false;
        for(int i = 2; i <= np; i += 2){
            if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
        }

        for(int i = 1; i <= ns; i++)
        {
            for(int j = 1; j <= np; j++)
            {
                if(p[j-1] == '*'){
                    dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'));
                }else{
                    if(s[i-1] == p[j-1] || p[j-1] == '.')
                        dp[i][j] = dp[i-1][j-1];
                    else
                        dp[i][j] = false;
                }
            }
        }

        return dp[ns][np];
    }
};
```



# [7. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

![image-20211126155344279](C:\Users\Sakura\AppData\Roaming\Typora\typora-user-images\image-20211126155344279.png)

**可以看出容量大小取决于两端长度最短的那块板子**

- 利用双指针 `i j`分别指向数组两端
- 如果`heght[i] < height[j]` 则令左指针 `i`左移一位，否则，右指针`j`右移一位

## 双指针移动规律

- 双指针向内收缩时，容器底部长度肯定是减小的
  - 如果`heght[i] < height[j]`，此时若移动较大的指针，即`j--`，移动后的最小板子为`min(height[i],height[j-1])`，由于`height[j]`是较大的那个，因此移动后的容器体积肯定减小，不会增大
  - 如果`heght[i] < height[j]`，此时若移动较 小的指针，即`i++`，移动后的最小板子为`min(height[i-1],height[j])`，此时`height[i-1]`可能会增大，因此容器体积也有可能增大
- 因此每次移动较小的那个指针

## 正解：

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0, j = height.size() -1 ;
        int res = 0;
        while(i < j)
        {
              res = height[i] < height[j] ? 
                max(res, (j - i) * height[i++]): 
                 max(res, (j - i) * height[j--]); 
        }
        return res;
    }
};
```



# [8. 三数之和](https://leetcode-cn.com/problems/3sum/)

**排序+双指针**

为了保证不重复，可以先将数组排序，然后保证每重循环遍历的数字都不小于上一层循环，即保证`a <= b <= c`，并且对于每一层循环，相邻两次枚举的元素不可以重复

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int l = i + 1, r = nums.size() - 1;
            while(l < r){
                if(nums[i] + nums[l] + nums[r] == 0){
                    res.push_back(vector<int>{nums[i], nums[l++], nums[r--]});
                    while(l < r && nums[l] == nums[l-1]) l++;
                    while(l < r && nums[r] == nums[r+1]) r--;
                }else if(nums[i] + nums[l] + nums[r] > 0){
                    r--;
                }else{
                    l++;
                }
            }
        }
        return res;
    }
};
```



# [9. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

**回溯**

- 首先将数字与其代表的字符串映射
- 回溯三部曲
  - 确定递归参数及返回值
    - 递归函数传入输入的数字字符串，并且需要维护一个整型变量Index，表示遍历到了第几个数字
  - 确定递归终止条件——当前字符串长度等于给定字符串长度时，递归终止
  - 确定递归单层逻辑
    - 首先从给定字符串中分离出数字字符
    - 然后去映射数组中取出该数字对应的字符串
    - 遍历字符串，一一取出字符，并递归下一个数字

```c++
class Solution {
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    string s;
    void backtracking(const string& digits, int index) {
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';        // 将index指向的数字转为int
        string letters = letterMap[digit];      // 取数字对应的字符集
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);            // 处理
            backtracking(digits, index++);    // 递归，注意index+1，一下层要处理下一个数字了
            s.pop_back();                       // 回溯
        }
    }
    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if (digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
```

# [10. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

**典型双指针应用**

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head) return head;
        ListNode* dummy = new ListNode(-1,head);
        ListNode* fast = dummy;
        ListNode* slow = dummy;
        while(n--){
            fast = fast->next;
        }
        while(fast->next){
            slow = slow->next;
            fast = fast->next;
        }
        slow->next = slow->next->next;
        return dummy->next;
    }
};
```



# [11. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

**栈**

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> sta;
        for(auto x : s){
            if(sta.empty()){
                sta.push(x);
            }
            else if
              (x == ')' && sta.top() == '(' || 
               x == '}' && sta.top() == '{' || 
               x == ']' && sta.top() == '[')
            {
                sta.pop() ;
            }else{
                sta.push(x);
            }
        }
        return sta.empty();
    }
};
```

# [12. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(!list1) return list2;
        if(!list2) return list1;
        ListNode* dummy = new ListNode(-1);
        ListNode* cur = dummy;
        ListNode* prev = nullptr;
        while(list1 && list2){
            if(list1->val > list2->val){
                cur->next = list2;
                list2 = list2->next;
                prev = cur;
                cur = cur->next;
            }else{
                cur->next = list1;
                list1 = list1->next;
                prev = cur;
                cur = cur->next;
            }
        }
        if(list1) cur->next = list1;
        if(list2) cur->next = list2;

        return dummy->next;
    }
};
```

# [13. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

**回溯：**

- 添加括号的过程中，一定是优先添加左括号，然后添加右括号
- 递归终止条件——当前路径长度==2n
- 递归参数：
  - 用两个变量left和right用于记录当前左右括号的数量
- 递归逻辑
  - 如果左括号数量小于n,则添加一个左括号，递归下一层
  - 如果右括号数量小于n,且小于左括号数量，则添加一个右括号，递归下一层

**代码：**

```c++
class Solution {
public:
    vector<string> res;
    string path;
    void backTracking(int n, int left, int right)
    {
        if(path.size() == 2 * n){
            res.push_back(path);
            return;
        }
        
        if(left < n)
        {
            path += '(';
            left++;
            backTracking(n,left, right);
            left--;
            path.pop_back();
        }
        if(right < n && right < left)
        {
            path += ')';
            right++;
            backTracking(n,left,right);
            right--;
            path.pop_back();
        } 
    }
    vector<string> generateParenthesis(int n) {
        backTracking(n,0,0);
        return res;
    }
};
```

# [14. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

## 法一：根据合并双链表的方法，依次合并所有链表

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode *ans = nullptr;
        for (size_t i = 0; i < lists.size(); ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }
};
```

## 法二：分治合并

**作为法一的优化方法，对链表数组中的链表两两配对合并**

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* merge(vector <ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};

```

## 法三：优先队列

```c++
class Solution {
public:
    struct comp {
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };

    priority_queue<ListNode*, vector<ListNode*>, comp> q;

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        for (auto node: lists) {
            if (node) q.push(node);
        }
        ListNode* head = new ListNode();
        ListNode* tail = head;
        while (!q.empty()) {
            ListNode* node = q.top();
            q.pop();
            tail->next = node; 
            tail = tail->next;
            if (node->next) q.push(node->next);
        }
        return head->next;
    }
};
```



# [15. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        //从后往前遍历，找到第一个升序对(i,i+1)满足nums[i] < nums[i+1]
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        //从i+1至数组尾的所有元素一定满足降序排列
        //从后往前遍历，在i+1至数组尾元素中找到第一个大于nums[i]的元素
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            //交换两者
            swap(nums[i], nums[j]);
        }
        //交换后，nums[j]后的元素一定还是以降序排列，将其反转，使其变为升序排列
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

# [16. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

**动态规划**

-   `dp[i]:`以字符`s[i]`结尾的最长有小括号的长度
- **状态转移：**
  - 若`s[i] == '('`,显然此时`dp[i] = 0`,因为有小括号必然是以右括号结尾
  - 若`s[i] == ')'`
    - 若`s[i-1] == '('`，则两者组成一对括号，故`dp[i] = dp[i-2] + 2`
    - 若`s[i-1] == ')'`
      - 此时，若`s[i]`要组成有效括号对，则其之前的位置必须是有效括号对，即`dp[i-1]`必须是一个有效长度，则与`s[i]`配对的左括号的位置为           `s[i - dp[i-1] - 1]`,若`s[i - dp[i-1] - 1] == '('`，则`dp[i] = dp[i-1] + 2`
      - 还需要注意一点，以上情况是形如`((...))`，若`s[i]`组成的有效括号对形如`(...)((...))`,因此`dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        if(n == 0) return 0;
        vector<int> dp(n+1,0);
        int res = 0;
        for(int i = 1; i < n; i++)
        {
            if(s[i] == '(') dp[i] = 0;
            if(s[i] == ')')
            {
                if(s[i-1] == '('){
                    dp[i] = 2;
                    if(i >= 2) dp[i] += dp[i-2];
                }
                else if(s[i - 1] == ')')
                {
                    if(dp[i-1] > 0 && i - dp[i-1] - 1 >= 0 && s[i - dp[i-1] - 1] == '(')
                    {
                        dp[i] = dp[i-1] + 2;
                        if(i - dp[i-1] - 1 > 0)
                            dp[i] += dp[i - dp[i-1] -2];
                    }
                } 
            }
            res = max(res,dp[i]);
        }
        return res;
    }
};
```



# [17. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
