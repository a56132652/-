# [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**哈希表**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash;
        vector<int> res;
        for(int i = 0; i < nums.size(); i++)
        {
            if(hash.find(target - nums[i]) != hash.end()){
                res.push_back(hash[target - nums[i]]);
                res.push_back(i);
                return res;
            }else{
                hash[nums[i]] = i;
            }
        }
        return res;
    }
};
```



# [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**模拟**

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = nullptr;
        ListNode* tail = nullptr;
        int carry = 0;
        while(l1 || l2){
            int n1 = l1 ? l1->val : 0;
            int n2 = l2 ? l2->val : 0;
            int number = n1 + n2 + carry;
            carry = number / 10;
            number %= 10;
            if(!head) head = tail = new ListNode(number);
            else{
                tail->next = new ListNode(number);
                tail = tail->next;
            }
            if(l1) l1 = l1->next;
            if(l2) l2 = l2->next;
        }
        if(carry){
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```



# [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

**典型的滑动窗口**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       unordered_set<int> hash;
       int left = 0, right = 0;
       int res = 0;
       while(right < s.size())
       {
           while(hash.find(s[right]) != hash.end()){
               hash.erase(s[left]);
               left++;
           }
           hash.insert(s[right]);
           res = max(res,right - left + 1);
           right++;
       } 
       return res;
    }
};
```



# [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

**可以直接用暴力法，将两个数组合并，然后输出合并后数组的中位数，该方法时间复杂度`O(m+n)`**

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();
        if(!n1 && !n2) return 0;
        vector<int> temp;
        int i = 0, j = 0;
        while(i < n1 && j < n2){
            if(nums1[i] < nums2[j])
                temp.push_back(nums1[i++]);
            else
                temp.push_back(nums2[j++]);
        }
        if(i < n1){
            for(;i < n1;i++){
                temp.push_back(nums1[i]);
            }
        }
        if(j < n2){
            for(;j < n2;j++){
                temp.push_back(nums2[j]);
            }
        }
        int length = n1 + n2;
        if(length % 2 != 0) return temp[length/2];
        double res = (double)(temp[length/2 - 1] + temp[length/2]) / 2;
        return res;
    }
};
```



**也可以使用二分法**

```c++
class Solution {
public:
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int n = nums1.size();
		int m = nums2.size();

		if (n > m)  //保证数组1一定最短
		{
			return findMedianSortedArrays(nums2, nums1);
		}

		// Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。
		int LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n;  //我们目前是虚拟加了'#'所以数组1是2*n长度

		while (lo <= hi)   //二分
		{
			c1 = (lo + hi) / 2;  //c1是二分的结果
			c2 = m + n - c1;

			LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];
			RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2];
			LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];
			RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2];

			if (LMax1 > RMin2)
				hi = c1 - 1;
			else if (LMax2 > RMin1)
				lo = c1 + 1;
			else
				break;
		}
		return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0;
	}
};
```



# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

**动态规划**

- `dp[i][j]`:字符串中第`i`到第`j`个字符组成的回文串的长度，若不是回文串，则长度为0
- 状态转移方程：
  - 若`s[i] == s[j]`
    - 如果`i == j`:则`dp[i][j] = 1`
    - 如果`i - j == 1`：则`dp[i][j] == 2`
    - 如果`dp[i+1][j-1] != 0`,则`dp[i][j] = dp[i+1][j-1] + 2`
  - 若`s[i] != s[j]`
    - `dp[i][j] == 0`
- 边界条件：
  - `dp[i][i] = 1`
- 最终答案即为`max(dp[i][j])`



**注意遍历顺序，首层循环必须从后往前遍历，即`for(int i = n-1; i >= 0; i--)`,因为在状态转移过程中，`dp[i][j]会利用到dp[i+1][j-1]`，所以必须先遍历`dp[i+1]`,然后遍历`dp[i]`**

**代码：**

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2) return s;
        string res = "";
        vector<vector<int>> dp(n,vector<int>(n,0));

        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j])
                {
                    if(i == j) dp[i][j] = 1;
                    else if(j - i == 1){
                        dp[i][j] = 2;
                    }
                    else if(dp[i + 1][j - 1]){
                        dp[i][j] = dp[i+1][j-1] + 2;
                    }
                }
                else{
                    dp[i][j] = 0;
                }
   
                if(dp[i][j] &&( res.size() < j - i + 1)){
                    res.clear();
                    res = s.substr(i,j - i + 1);
                }
            }
        }
        return res;
    }
};
```



# [6. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

## 1. 动态规划数组定义以及状态定义

- `dp[i][j]: 字符串s的前i个字符与模式串p的前j个字符的匹配情况`
- 若 `s[i-1] == p[j-1]`
  - `dp[i][j] = dp[i-1][j-1]`
- 若`s[i-1] != p[j-1]`
  - 若`p[j-1] == '.'`
    - `dp[i][j] == dp[i-1][j-1] `，该类情况可以合并到第一类中
  - 若`p[j-1] == '*'`
    - 则可以匹配0个`p[j-2]`或者匹配 1 个
      - 匹配 0 个时：`dp[i][j] = dp[i][j-2]`
      - 匹配 1 个时：`dp[i][j] = dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')`
  - 若`p[j-1]为小写字母`
    - 则`dp[i][j] = false`

**综上，一共可以分为两种情况，分别为`p[j-1] == '*' 或者 p[j-1] != '*'`**

## 2. DP数组初始化

- 当给定字符串以及模式串均为空是，两者当然是匹配的(空字符匹配空字符)

  - `dp[0][0] = true`

- 当模式字符串为空，而给定字符串不为空时，结果当然是false

  - `for(int i = 1; i <= ns; i++) dp[i][0] = false;`

- 当给定字符串为空，而模式字符串不为空时，只有当模式字符串的偶数位上为`*`时，两者才匹配

  - ```c++
    for(int i = 2; i <= np; i += 2){
               if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
           }
    ```



## 3. 代码

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int ns = s.size();
        int np = p.size();
        vector<vector<bool>> dp(ns+1,vector<bool>(np+1,false));
        dp[0][0] = true;
        for(int i = 1; i <= ns; i++) dp[i][0] = false;
        for(int i = 2; i <= np; i += 2){
            if(p[i - 1] == '*') dp[0][i] = dp[0][i-2];
        }

        for(int i = 1; i <= ns; i++)
        {
            for(int j = 1; j <= np; j++)
            {
                if(p[j-1] == '*'){
                    dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'));
                }else{
                    if(s[i-1] == p[j-1] || p[j-1] == '.')
                        dp[i][j] = dp[i-1][j-1];
                    else
                        dp[i][j] = false;
                }
            }
        }

        return dp[ns][np];
    }
};
```



# [7. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

![image-20211126155344279](C:\Users\Sakura\AppData\Roaming\Typora\typora-user-images\image-20211126155344279.png)

**可以看出容量大小取决于两端长度最短的那块板子**

- 利用双指针 `i j`分别指向数组两端
- 如果`heght[i] < height[j]` 则令左指针 `i`左移一位，否则，右指针`j`右移一位

## 双指针移动规律

- 双指针向内收缩时，容器底部长度肯定是减小的
  - 如果`heght[i] < height[j]`，此时若移动较大的指针，即`j--`，移动后的最小板子为`min(height[i],height[j-1])`，由于`height[j]`是较大的那个，因此移动后的容器体积肯定减小，不会增大
  - 如果`heght[i] < height[j]`，此时若移动较 小的指针，即`i++`，移动后的最小板子为`min(height[i-1],height[j])`，此时`height[i-1]`可能会增大，因此容器体积也有可能增大
- 因此每次移动较小的那个指针

## 正解：

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0, j = height.size() -1 ;
        int res = 0;
        while(i < j)
        {
              res = height[i] < height[j] ? 
                max(res, (j - i) * height[i++]): 
                 max(res, (j - i) * height[j--]); 
        }
        return res;
    }
};
```



# [8. 三数之和](https://leetcode-cn.com/problems/3sum/)

**排序+双指针**

为了保证不重复，可以先将数组排序，然后保证每重循环遍历的数字都不小于上一层循环，即保证`a <= b <= c`，并且对于每一层循环，相邻两次枚举的元素不可以重复

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int l = i + 1, r = nums.size() - 1;
            while(l < r){
                if(nums[i] + nums[l] + nums[r] == 0){
                    res.push_back(vector<int>{nums[i], nums[l++], nums[r--]});
                    while(l < r && nums[l] == nums[l-1]) l++;
                    while(l < r && nums[r] == nums[r+1]) r--;
                }else if(nums[i] + nums[l] + nums[r] > 0){
                    r--;
                }else{
                    l++;
                }
            }
        }
        return res;
    }
};
```



# [9. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

**回溯**
