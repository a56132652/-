# 1. 01背包问题

[AcWing 2. 01背包问题 - AcWing](https://www.acwing.com/activity/content/problem/content/997/)

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤10000<N,V≤1000
0<vi,wi≤10000<vi,wi≤1000

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```
8
```

##  1）二维数组dp

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;
int n, m;
int v[N],w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >>v[i] >> w[i];
    
    
    for(int i = 1; i <= n; i++){
        for(int j = 0 ; j <= m; j++){
            f[i][j] = f[i-1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j],f[i-1][j-v[i]] + w[i]);
        }
    }
    
    cout << f[n][m];
    return 0;
}
```

## 2）一维数组dp

对于01背包一维优化的一点理解：
二维转化为一维：
删掉了第一维：在前i个物品中取。
f[j]表示：拿了总体积不超过j的物品，最大总价值。

为何能转化为一维？
二维时的更新方式：

```c++
f[i][j]=max(f[i - 1][j] ,f[i - 1][j - v[i]] + w[i]);
```

1.我们发现，对于每次循环的下一组i，只会用到i-1来更新当前值，不会用到i-2及之前值。于是可以在这次更新的时候，将原来的更新掉，反正以后也用不到。
所以对于i的更新，只需用一个数组，直接覆盖就行了。
2.我们发现，对于每次j的更新，只需用到之前i-1时的j或者j-v[i]，不会用到后面的值。
所以为了防止串着改，我们采取从后往前更新的方式，用原来i-1的数组来更新i。
（如果从前往后更新的话，前面的更新过之后，会接着更新后面的值，这样就不能保证是用原来i-1的数组来更新i的了）

如何转化为一维呢？
只用一个数组，每次都覆盖前面的数组。

1.如果当前位置的东西不拿的话，和前一位置的信息（原来i-1数组的这个位置上的值）是相同的，所以不用改变。
2.如果当前位置的东西拿了的话，需要和前一位置的信息（原来i-1数组的这个位置上值）取max。
所以，更新方式就为：f[j]=max(f[j],f[j-v[i]]+w[i]);

整个更新方式就相当于：

每次i++，就从后往前覆盖一遍f数组，看每个位置上的值是否更新。

作者：yxc
链接：https://www.acwing.com/video/34/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 2. 完全背包问题

[3. 完全背包问题 - AcWing题库](https://www.acwing.com/problem/content/3/)

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤10000<N,V≤1000
0<vi,wi≤10000<vi,wi≤1000

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```
10
```

## 1）朴素解法：

由于物品数量无限，因此在遍历物品时，要增加一维遍历，用来遍历物品数量

```c++
//此层循环用于遍历第i个物品的数量
for(int k = 0; k * v[i] <= j; k++){
    //之所以是dp[i][j] 而不是 dp[i-1][j]， 是因为当 k = 0时，第二个式子就是dp[i-1][j]
	dp[i][j] = max(dp[i][j], dp[i-1][j - k * v[i]] + k * w[i]);
}
```

因此完整解法为：

```c++
#include<iostream>

using namespace std;

const int N = 1010;
int m, n;
int v[N],w[N];
int dp[N][N];

int main()
{
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >>v[i] >> w[i];
    
    for(int i = 1; i <= m; i++){
        for(int j = 0; j <= n; j++){
           for(int k = 0; k * v[i] <= j; k++)
               //之所以是dp[i][j] 而不是 dp[i-1][j]， 是因为当 k = 0时，第二个式子就是dp[i-1][j]
               	dp[i][j] = max(dp[i][j],dp[i-1][j - k * v[i]] + k * w[i]);
        }
    }
    cout << dp[m][n];
    
    return 0;
}
```

**最坏时间复杂度为 n * v^2 = 10 ^ 9，会超时**

## 2）优化解法：

观察状态转移方程：

```c++
dp[i][j] = dp[i-1][j - k * v[i]] + k * w[i])
    //对状态进行枚举
    dp[i][j] = Max(dp[i-1][j], dp[i-1][j-v]+w, dp[i-1][j-2v]+2w, dp[i-1][j-3v]+3w,.....)
    dp[i][j-v]= Max( 		   dp[i-1][j-v],   dp[i-1][j-2v]+w,  dp[i-1][j-3v]+2w,.....)
```

**因此可以发现，**

```c++
dp[i][j] = Max(dp[i-1][j],dp[i][j-v] + w)
```

该式子和01背包问题的状态转移方程**非常相似**，由此可以写出如下代码：

```c++
#include<iostream>

using namespace std;

const int N = 1010;
int m, n;
int v[N],w[N];
int dp[N][N];

int main()
{
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >>v[i] >> w[i];
    
    for(int i = 1; i <= m; i++){
        for(int j = 0; j <= n; j++){
            dp[i][j] = dp[i-1][j];
            if(j >= v[i])
       //01背包：dp[i][j] = max(dp[i][j],dp[i-1][j - v[i]] + w[i])
                dp[i][j] = max(dp[i][j],dp[i][j - v[i]] + w[i]);
        
        }
    }
    cout << dp[m][n];
    
    return 0;
}
```



# 3. 多重背包问题Ⅰ

[ACWing 多重背包问题](https://www.acwing.com/problem/content/4/)

有 N 种物品和一个容量是 V 的背包。

第 ii种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，N，，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤1000<N,V≤100
0<vi,wi,si≤1000<vi,wi,si≤100

**输入样例**

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```
10
```

## 1）朴素解法：

​	与完全背包问题的朴素解法思想一致，对物品数量进行分组，从0至Si遍历

```c++
#include<iostream>

using namespace std;

const int N = 1010;
int m, n;
int v[N],w[N],s[N];
int dp[N][N];

int main()
{
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >>v[i] >> w[i] >> s[i];
    
    for(int i = 1; i <= m; i++){
        for(int j = 0; j <= n; j++){
            //注意 k 值的限定条件
            for(int k = 0; k <= s[i] && k * v[i] <= j; k++){
               //之所以是dp[i][j] 而不是 dp[i-1][j]， 是因为当 k = 0时，第二个式子就是dp[i-1][j]
                dp[i][j] = max(dp[i][j],dp[i-1][j - k * v[i]] + k * w[i]);
            }
        }
    }
    cout << dp[m][n];
    
    return 0;
}
```



# 4. 多重背包问题Ⅱ

[5. 多重背包问题 II - AcWing题库](https://www.acwing.com/problem/content/5/)

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 NN 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N≤10000<N≤1000
0<V≤20000<V≤2000
0<vi,wi,si≤20000<vi,wi,si≤2000

**提示：**

本题考查多重背包的二进制优化方法。

**输入样例**

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```
10
```

该题与上一题比起来，每个物品的数量上升了一个数量级，利用与上一题相同的朴素解法会超时。

因此该题需要优化一下，首先，考虑与完全背包问题一样的优化思路

```c++
dp[i][j] = dp[i-1][j - k * v[i]] + k * w[i])
    //对状态进行枚举
dp[i][j] = Max(dp[i-1][j], dp[i-1][j-v]+w,dp[i-1][j-2v]+2w,..,dp[i-1][j-sv]+sw)
dp[i][j-v]= Max( 		   dp[i-1][j-v],  dp[i-1][j-2v]+w,...,dp[i-1][j-sv]+(s-1)w， dp[i-1][j-(s+1)v]+sw)
  
    /*
    	可以看出dp[i][j-v]多了一项dp[i-1][j-(s+1)v]+sw)，而我们无法求出除了最后一个数以外的最大值，因此无法用完全背包的优化方式来优化多重背包问题
    */
```

## 1）优化方式——二进制优化

```
假设第 i 个物品的最大数量Si = 1023
我们可以对该物品进行打包,打包数量按二进制方式划分，即
每一组的数量分别为
	1，2，4，8，...，512
一共分成了10组
	1+2+..+512 = 1023
根据二进制与十进制的转换规律，1，2，4,...,512(2^9),这些数可以表示1~2^10-1 即1 ~ 1023之间的任何数
因此我们可以根据这10组数量，拼凑出物品i所有的数量，因此将枚举数量从1023次降低到了10次。

优化之前时间复杂度为N*V*S
优化之后时间复杂度为N*V*logS
```

**优化之前时间复杂度为NVS**
**优化之后时间复杂度为NVlogS**

## 2）完整代码

上述优化方式代码实现：

```
第 i 个物品的最大数量为Si
	进行二进制划分：
		1，2，4，... ,2^k,c
	2^k要保证等比数列之和小于Si, c为 Si 减去等比数列之和的剩下的部分，c < 2^(k+1)
```



```c++
#include<iostream>

using namespace std;

const int N = 25000, M = 2010;
int n,m;
int v[N],w[N];
int f[N];

int main()
{
    cin >>n>>m;
    int cnt = 0;
    for(int i = 1; i <= n; i++){
        int a, b ,s;    //体积 价值 数量
        cin >> a >> b >> s;
        int k = 1;
        while(k <= s){
            cnt++;
            v[cnt] = k * a;
            w[cnt] = k * b;
            s -= k;
            k *= 2;
        }
        if(s > 0){
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    
    n = cnt;
    
    for(int i = 1;i <= n; i++)
        for(int j = m; j >= v[i]; j--)
            f[j] = max(f[j],f[j-v[i]] + w[i]);
            
    cout << f[m] << endl;
    
    return 0;
            
}
```



# 5. 分组背包问题

[9. 分组背包问题 - AcWing题库](https://www.acwing.com/problem/content/9/)

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

**输入格式**

第一行有两个整数 N，，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 NN 组数据：

- 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
- 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤1000<N,V≤100
0<Si≤1000<Si≤100
0<vij,wij≤1000<vij,wij≤100

**输入样例**

```
3 5
2
1 2
2 4
1
3 4
1
4 5
```

**输出样例：**

```
8
```

## 1）二维数组

```c++
#include<iostream>

using namespace std;

const int N = 1010;
//组数，容量
int n , m;
int v[N][N], w[N][N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    
    for(int i = 1; i <= n;i++){
        cin >> s[i];
        for(int j = 0; j < s[i]; j++)
            cin >> v[i][j] >> w[i][j];
    }
    
    for(int i = 1; i <= n; i++){
        for(int j = 0; j <= m; j++){
            f[i][j] = f[i-1][j];
            for(int k = 0; k < s[i]; k++){
                if(j >= v[i][k])
                    f[i][j] = max(f[i][j],f[i-1][j-v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[n][m]<<endl;
    return 0;
}

```

## 2）一维数组

```c++
#include<iostream>

using namespace std;

const int N = 1010;
//组数，容量
int n , m;
int v[N][N], w[N][N], s[N];
int f[N];

int main()
{
    cin >> n >> m;
    
    for(int i = 1; i <= n;i++){
        cin >> s[i];
        for(int j = 0; j < s[i]; j++)
            cin >> v[i][j] >> w[i][j];
    }
    
    for(int i = 1; i <= n; i++){
        for(int j = m; j >= 0; j--){
            for(int k = 0; k < s[i]; k++){
                if(j >= v[i][k])
                    f[j] = max(f[j],f[j-v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m]<<endl;
    return 0;
}
```

