# [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

**递减栈，找出下一个比自己大的元素**

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int size = temperatures.size();
        vector<int> res(size, 0);
        stack<int> s;
        for(int i = 0; i < size; i++)
        {
            while(!s.empty() && temperatures[i] > temperatures[s.top()]){
                res[s.top()] = i - s.top();
                s.pop();
            }
            s.push(i);
        }
        return res;
    }
};
```



# [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

**与上一题相同， 首先在`nums2中找到每个元素的下一个比它大元素并利用哈希表记录`，然后遍历`nums1`,如果当前元素存在于哈希表中，则当前元素的下一个比他大的元素就是哈希表中记录的元素，如果不存在，则说明该元素在`nums2`中没有下一个比它大的元素**

```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.empty() || nums2.empty()) return vector<int>{};
        vector<int> res;
        unordered_map<int,int> hash;
        stack<int> s;
        for(int i = 0; i < nums2.size(); i++)
        {
            while(!s.empty() && nums2[i] > nums2[s.top()]){
                hash[nums2[s.top()]] = nums2[i];
                s.pop();
            }
            s.push(i);
        }
        for(int i = 0; i < nums1.size(); i++)
        {
            if(hash.find(nums1[i]) != hash.end())
                res.push_back(hash[nums1[i]]);
            else
                res.push_back(-1);
        }
        return res;
    }
};
```



# [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

**循环数组，就是利用取余操作来模拟循环数组**

```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size();
        stack<int> sta;
        vector<int> res(n,-1);
        for(int i = 0; i < 2 * n; i++)
        {
            while(!sta.empty() && nums[i%n] > nums[sta.top()])
            {
                res[sta.top()] = nums[i%n];
                sta.pop(); 
            }
            sta.push(i%n);
        }
        return res;
    }
};
```



# [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

## 1.双指针法

**对于每一列，分别向两端搜索**

- 向左寻找最高的柱子
- 向右寻找最高的柱子

**取两者的最小值，计算雨水体积，注意还要减去当前列的柱子高度**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.empty()) return 0;
        int res = 0;
        for(int i = 0; i < height.size(); i++)
        {
            int lh = 0;
            int rh = 0;
            //
            for(int j = i - 1; j >= 0; j--)
            {
                lh = max(lh, height[j]);
            }

            for(int j = i + 1; j < height.size(); j++)
            {
                rh = max(rh, height[j]);
            }

            int h = min(lh, rh) - height[i];

            if(h > 0) res += h;
        }

        return res;
    }
};
```



## 2. 动态规划

**在双指针的基础上进行改进，利用两个数组分别记录左右两边的最大高度，由此避免重复遍历**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.size() <= 2) return 0;
        vector<int> maxLeft(height.size(), 0);
        vector<int> maxRight(height.size(), 0);
        int size = maxRight.size();

        // 记录每个柱子左边柱子最大高度
        maxLeft[0] = height[0];
        for (int i = 1; i < size; i++) {
            maxLeft[i] = max(height[i], maxLeft[i - 1]);
        }
        // 记录每个柱子右边柱子最大高度
        maxRight[size - 1] = height[size - 1];
        for (int i = size - 2; i >= 0; i--) {
            maxRight[i] = max(height[i], maxRight[i + 1]);
        }
        // 求和
        int sum = 0;
        for (int i = 0; i < size; i++) {
            int count = min(maxLeft[i], maxRight[i]) - height[i];
            if (count > 0) sum += count;
        }
        return sum;
    }
};
```



## 3. 单调栈

**以上两种方法都是按照 列 来计算，而单调栈法是按照 行 来计算**

**一定要记住，是按照 `行` 来计算**

- **栈中存储数组下标**

- 当前元素大于栈顶元素时，当前元素就是右边最大高度，栈顶元素此时就是凹槽部分，栈顶元素的下一个元素是左边高度，**注意不是左边最大高度**
- 雨水宽度：**凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度）**

```c++
class Solution {
public:
    //递减栈
    int trap(vector<int>& height) {
            if(height.empty()) return 0;
            stack<int> s;
            int res = 0;
            for(int i = 0; i < height.size(); i++)
            {
                while(!s.empty() && height[s.top()] <= height[i])
                {
                    int mid = height[s.top()];
                    s.pop();
                    int rh = height[i];
                    if(!s.empty())
                    {
                        int h = min(height[s.top()], rh) - mid;
                        int w = i - s.top() - 1;
                        res += h * w;
                    }
                    
                }
                s.push(i);
            }
            return res;
    }
};
```

### 二刷记录：

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> s;
        s.push(0);
        int res = 0;
        for(int i = 1; i < height.size(); i++){
            while(!s.empty() && height[i] > height[s.top()])
            {
                int bot = height[s.top()];
                s.pop();
                if(!s.empty()){
                    int left = height[s.top()];
                    int w = i - s.top() - 1;
                    s.pop();
                    int h = min(height[i],left) - bot;
                    res += h * w;
                }
            }
            s.push(i);
        }
        return res;
    }
};
```

**二刷时，在进行凹槽左边界的处理时，用完左边界后，我对左边界元素进行了出栈处理，从而导致了错误**

**例如：**

- 给定数组为`[4,2,0,3]`时
  - 首先`[2,0,3]`构成了一个凹槽，处理结束后，`[4,2,3]`又构成了一个凹槽
  - 两凹槽结果相加才为最终答案

# [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

## 1. 双指针(超时)

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int sum = 0;
        for (int i = 0; i < heights.size(); i++) {
            int left = i;
            int right = i;
            for (; left >= 0; left--) {
                if (heights[left] < heights[i]) break;
            }
            for (; right < heights.size(); right++) {
                if (heights[right] < heights[i]) break;
            }
            int w = right - left - 1;
            int h = heights[i];
            sum = max(sum, w * h);
        }
        return sum;
    }
};
```

## 2. 单调栈

**递增栈**

**找每个柱子左右两边第一个小于该柱子的柱子**

**栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度**

**为了保证不遗漏，在给定数组尾部加入一个0，保证所有元素都被计算到，如果不加0，当给定数组是递增数组时，栈将不会推出元素**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        heights.push_back(0);
        stack<int> s;
        int res = 0;
        for(int i = 0; i < heights.size(); i++)
        {
            while(!s.empty() && heights[s.top()] > heights[i])
            {
                int mid = s.top();
                int h = heights[mid];
                int w = i;
                s.pop();
                if(!s.empty())
                {   
                    w = i - s.top() - 1;
                }
                res = max(res, h *  w);
            }
            s.push(i);
        }
        return res;
    }
};
```



# [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

**利用上一题`84. 柱状图中最大的矩形`的函数，首先统计出每一行对应的举行柱状图，然后逐行求解**

```c++
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.empty() || matrix[0].empty()) return 0;
        int res = 0;
        vector<int> heights(matrix[0].size(),0);

        for(int i = 0; i < matrix.size(); i++)
        {
            for(int j = 0; j < matrix[0].size();j++)
            {
                if(matrix[i][j] == '1') heights[j] += 1;
                else heights[j] = 0;
            }
            res = max(res, largestRectangleArea(heights));
        }
        return res;

    }

    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        heights.push_back(0);
        stack<int> s;
        int res = 0;
        for(int i = 0; i < heights.size(); i++)
        {
            while(!s.empty() && heights[s.top()] > heights[i])
            {
                int mid = s.top();
                int h = heights[mid];
                int w = i;
                s.pop();
                if(!s.empty())
                {   
                    w = i - s.top() - 1;
                }
                res = max(res, h *  w);
            }
            s.push(i);
        }
        return res;
    }
};
```

