# 回溯算法

​		回溯算法与递归算法相辅相成，其实际上是一个暴力的算法，下面是回溯法的模板

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

回溯法可以看成是对一个多叉树的遍历，其中，for循环遍历多叉树的宽度，而递归则去遍历多叉树的深度。

- 回溯三部曲
  1. 确定递归函数的参数和返回值
  2. 确定递归的终止条件
  3. 确定单层搜索（递归）的逻辑

- 回溯算法主要用于解决如下几种问题：
  1. 组合问题：N个数里面按一定规则找出k个数的集合
  2. 切个问题：一个字符串按一定规则有几种切割方式
  3. 子集问题：一个N个数的集合里有多少符合条件的子集
  4. 排列问题：N个数按一定规则全排列，有几种排列方式
  5. 棋盘问题：N皇后，解数独等等



# 回溯算法之组合问题

​		组合问题不同于排序问题，组合问题对元素的前后顺序不做要求，其常见题型为：

**给定两数n、k，求出集合[1,n]中所有k个数的组合**

例如给定n = 4, k = 2,要从1，2，3，4中找出所有两个数的组合，按顺序寻找，应该为

- 1 2

- 1 3

- 1 4  ...

  找到1 2这个组合后，进行回溯，将2剔除，然后将3放入，以此类推，直到找出所有组合

[77.组合](https://leetcode-cn.com/problems/combinations/)

用最传统的暴力法去解决此类问题时，考虑用嵌套for循环去做，for循环的层数等于k，当k过大时，嵌套循环有点不切实际，于是可以考虑用递归去实现，一层递归就代表一层for循环。

```c++
class Solution{
private:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(int n, int k, int startIndex){
        //确定终止条件
        if(path.size() == k){
            res.push_back(path);
            return;
        }
        //确定单层递归逻辑
        for(int i = startIndex; i <= n; i++){
            path.push_back(i);
            backtracking(n , k , i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n ,k ,1);
        return res;
    }  
};
```

## 组合问题优化

​		当n = 4, k = 3时，从{1，2，3，4}中选择所有3个元素的组合，可以发现，当起始位置为3时便不可能满足条件了，因此可以引入剪枝的概念，提前终止循环。

- 集合中元素个数为path.size()
- 还需元素个数 k - path.size()
- 则最大起始位置为 ：n - (k - path.size()) + 1

```
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化的地方
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1);
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:

    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

## 组合总和Ⅲ

[216.组合总和Ⅲ](https://leetcode-cn.com/problems/combination-sum-iii/)

按照回溯三部曲，非常容易就能写出来

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(int k, int n, int cur_sum, int startIndex)
    {
        if (cur_sum > n) { // 剪枝操作
            return; // 如果path.size() == k 但sum != targetSum 直接返回
        }
        //终止条件
        if(cur_sum == n && path.size() == k){
            res.push_back(path);
            return ;
        }
		//确定单层递归逻辑
        for(int i = startIndex ; i <= 9; i++){
            path.push_back(i);
            cur_sum += i;
            backtracking(k ,n ,cur_sum, i + 1);
            path.pop_back();
            cur_sum -= i;
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(k , n , 0,1);
        return res;
    }
};
```



## 电话号码的字母组合

[17.电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![](C:\Users\Sakura\Desktop\17_telephone_keypad.png)

对输入的数字进行遍历，首先建立一个数组，将字母与数字进行映射

```c++
const string letterMap[10] = {
    "", // 0
    "", // 1
    "abc", // 2
    "def", // 3
    "ghi", // 4
    "jkl", // 5
    "mno", // 6
    "pqrs", // 7
    "tuv", // 8
    "wxyz", // 9
};
```

**回溯三部曲**

- 确定递归函数的参数和返回值

递归函数传入输入的数字字符串，并且需要维护一个整型变量Index，表示遍历到了第几个数字

```c++
vector<string> res;
string path;
void backtracking(const string& digits, int index)
```

- 确定递归的终止条件

当遍历到最后一个数字是终止递归，将当前组合加入结果数组中

```c++
if(index == digits.size()){
	res.push_back(path);
	return;
}
```

- 确定单层搜索（递归）的逻辑
  - 首先找到当前index对应的字符串映射
  - 然后遍历字符串每个字母
  - 继续递归下一个数字

  ```c++
  //首先找到当前index对应的字符串映射
  int digit = digits[index] - '0';
  string letters = letterMap[digit];
  //然后遍历字符串每个字母
  for(int i = 0; i < letters.size(); i++){
  	path.push_back(letters[i]);
  	backtracking(digits, index + 1);
  	path.pop_back();
  }
  ```

**最终结果**

```c++
class Solution {
public:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
};

    vector<string> res;
    string path;

    void backtracking(const string& digits, int index)
    {
        if(index == digits.size()){
            res.push_back(path);
            return;
        }
        int digit = digits[index] - '0';
        string letters = letterMap[digit];
        for(int i = 0; i < letters.size(); i++){
            path.push_back(letters[i]);
            backtracking(digits,index + 1);
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return vector<string>{ };
        backtracking(digits,0);
        return res;
    }
};
```



## 组合总和

[39.组合总和]([39. 组合总和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/combination-sum/))

**回溯三部曲**

- 递归函数参数

  **此题为了避免重复情况，例如[2,2,3]和[3,2,2],需要设定一个startIndex，用于表示每次循环的起点，防止遍历已经遍历过的元素**

  ```c++
  void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
  ```

  

- 递归终止条件

  当当前和等于给定值或者大于给定值时函数返回

  ```c++
    if(sum == target){
              res.push_back(path);
              return;
    }else if(sum > target) return;
  ```

  

- 单层循环逻辑

  ```c++
  for(int i = startIndex; i < candidates.size(); i++){
        path.push_back(candidates[i]);
        sum += candidates[i];
      //与前面的组合问题不同，此处的startIndex不需要+1，表示可以重复选取元素
        backtracking(candidates,target,sum,i);
        sum -= candidates[i];
        path.pop_back();
  }
  ```

  

**最终结果**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
    {
        if(sum == target){
            res.push_back(path);
            return;
        }else if(sum > target) return;

        for(int i = startIndex; i < candidates.size(); i++){
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(candidates,target,sum,i);
            sum -= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracking(candidates,target,0,0);
        return res;
    }
};
```



**剪枝优化**

```c++
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

## 组合总和Ⅱ

[组合总和Ⅱ](https://leetcode-cn.com/problems/combination-sum-ii/)

该题与上一题相比，区别在于该题每个数字只能用一次，并且此题数组有重复元素，而上题没有

我首次提交时，是基于上一题的代码，将递归代码中的 i 改成了 i+1，表示不可以使用重复元素

```c++
backtracking(candidates,target,sum,i) --->> backtracking(candidates,target,sum,i + 1)
```

按逻辑上来说，这么改应该是没有问题的，但是提交后却发现有重复的元素，

![image-20211006111509910](C:\Users\Sakura\AppData\Roaming\Typora\typora-user-images\image-20211006111509910.png)

究其原因，是因为输入数组中含有重复的元素1，若去掉重复元素，则结果无问题。

因此，该题在进行遍历，要进行去重。

回溯法遍历是个二维的遍历，横向遍历是for循环，竖向遍历是递归，该题去重是要在横向遍历上去重，即竖向上允许重复。例如，对于数组[1,1,3,4]，target = 7,首先取数字1，递归时继续取数字1，这是允许的，但在for循环中，当i = 0时，第一数字取1，当i = 1时，第一个数字也取1，这是不允许的,因为若允许，则会出现两个一样的结果[1,3,4]。

因此，设置一个vector<bool> used数组，当

```c++
if(i > 0 &&candidates[i] == candidates[i-1] && used[i - 1] == false){
   continue;
}
```

**完整代码**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex,vector<bool>& used)
    {
        if(sum == target){
            res.push_back(path);
            return;
        }else if(sum > target) return;

        for(int i = startIndex; i < candidates.size(); i++){
            if(i > 0 &&candidates[i] == candidates[i-1] && used[i - 1] == false){
                continue;
            }
            path.push_back(candidates[i]);
            used[i] = true;
            sum += candidates[i];
            backtracking(candidates,target,sum,i + 1,used);
            sum -= candidates[i];
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        vector<bool> used(candidates.size(),false);
        backtracking(candidates,target,0,0,used);
        return res;
    }
};
```



# 回溯算法之切割问题

[131.分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

切割问题类似于组合问题

组合问题是不停的将字符放入当前path，而切割问题则是在不同的位置放置分割线

回溯三部曲：

1. 确定递归函数的参数和返回值

   本题也要求不能重复分割，因此需要一个startIndex用于记录每次起始位置

2. 确定递归终止条件

   当起始位置超过字符串长度时，表示递归结束，将当前结果放入结果数组

3. 确定单层递归逻辑

   每进行一次分割，对当前结果进行一个回文串判断，若是回文串，则继续向下，若不是，则跳过

