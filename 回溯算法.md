# 回溯算法

​		回溯算法与递归算法相辅相成，其实际上是一个暴力的算法，下面是回溯法的模板

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

回溯法可以看成是对一个多叉树的遍历，其中，for循环遍历多叉树的宽度，而递归则去遍历多叉树的深度。

- 回溯三部曲
  1. 确定递归函数的参数和返回值
  2. 确定递归的终止条件
  3. 确定单层搜索（递归）的逻辑

## 回溯算法之组合问题

​		组合问题不同于排序问题，组合问题对元素的前后顺序不做要求，其常见题型为：

**给定两数n、k，求出集合[1,n]中所有k个数的组合**

例如给定n = 4, k = 2,要从1，2，3，4中找出所有两个数的组合，按顺序寻找，应该为

- 1 2

- 1 3

- 1 4  ...

  找到1 2这个组合后，进行回溯，将2剔除，然后将3放入，以此类推，直到找出所有组合

[77.组合](https://leetcode-cn.com/problems/combinations/)

用最传统的暴力法去解决此类问题时，考虑用嵌套for循环去做，for循环的层数等于k，当k过大时，嵌套循环有点不切实际，于是可以考虑用递归去实现，一层递归就代表一层for循环。

```c++
class Solution{
private:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(int n, int k, int startIndex){
        //确定终止条件
        if(path.size() == k){
            res.push_back(path);
            return;
        }
        //确定单层递归逻辑
        for(int i = startIndex; i <= n; i++){
            path.push_back(i);
            backtracking(n , k , i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n ,k ,1);
        return res;
    }  
};
```

## 组合问题优化

​		当n = 4, k = 3时，从{1，2，3，4}中选择所有3个元素的组合，可以发现，当起始位置为3时便不可能满足条件了，因此可以引入剪枝的概念，提前终止循环。

- 集合中元素个数为path.size()
- 还需元素个数 k - path.size()
- 则最大起始位置为 ：n - (k - path.size()) + 1

```
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化的地方
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1);
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:

    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

## 组合总和Ⅲ

[216.组合总和Ⅲ](https://leetcode-cn.com/problems/combination-sum-iii/)

按照回溯三部曲，非常容易就能写出来

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(int k, int n, int cur_sum, int startIndex)
    {
        if (cur_sum > n) { // 剪枝操作
            return; // 如果path.size() == k 但sum != targetSum 直接返回
        }
        //终止条件
        if(cur_sum == n && path.size() == k){
            res.push_back(path);
            return ;
        }
		//确定单层递归逻辑
        for(int i = startIndex ; i <= 9; i++){
            path.push_back(i);
            cur_sum += i;
            backtracking(k ,n ,cur_sum, i + 1);
            path.pop_back();
            cur_sum -= i;
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(k , n , 0,1);
        return res;
    }
};
```



## 电话号码的字母组合

[17.电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![](C:\Users\Sakura\Desktop\17_telephone_keypad.png)

对输入的数字进行遍历，首先建立一个数组，将字母与数字进行映射

```c++
const string letterMap[10] = {
    "", // 0
    "", // 1
    "abc", // 2
    "def", // 3
    "ghi", // 4
    "jkl", // 5
    "mno", // 6
    "pqrs", // 7
    "tuv", // 8
    "wxyz", // 9
};
```

**回溯三部曲**

- 确定递归函数的参数和返回值

递归函数传入输入的数字字符串，并且需要维护一个整型变量Index，表示遍历到了第几个数字

```c++
vector<string> res;
string path;
void backtracking(const string& digits, int index)
```

- 确定递归的终止条件

当遍历到最后一个数字是终止递归，将当前组合加入结果数组中

```c++
if(index == digits.size()){
	res.push_back(path);
	return;
}
```

- 确定单层搜索（递归）的逻辑
  - 首先找到当前index对应的字符串映射
  - 然后遍历字符串每个字母
  - 继续递归下一个数字

  ```c++
  //首先找到当前index对应的字符串映射
  int digit = digits[index] - '0';
  string letters = letterMap[digit];
  //然后遍历字符串每个字母
  for(int i = 0; i < letters.size(); i++){
  	path.push_back(letters[i]);
  	backtracking(digits, index + 1);
  	path.pop_back();
  }
  ```

**最终结果**

```c++
class Solution {
public:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
};

    vector<string> res;
    string path;

    void backtracking(const string& digits, int index)
    {
        if(index == digits.size()){
            res.push_back(path);
            return;
        }
        int digit = digits[index] - '0';
        string letters = letterMap[digit];
        for(int i = 0; i < letters.size(); i++){
            path.push_back(letters[i]);
            backtracking(digits,index + 1);
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return vector<string>{ };
        backtracking(digits,0);
        return res;
    }
};
```

