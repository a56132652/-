# 回溯算法

​		回溯算法与递归算法相辅相成，其实际上是一个暴力的算法，下面是回溯法的模板

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

回溯法可以看成是对一个多叉树的遍历，其中，for循环遍历多叉树的宽度，而递归则去遍历多叉树的深度。

- 回溯三部曲
  1. 确定递归函数的参数和返回值
  2. 确定递归的终止条件
  3. 确定单层搜索（递归）的逻辑

- 回溯算法主要用于解决如下几种问题：
  1. 组合问题：N个数里面按一定规则找出k个数的集合
  2. 切割问题：一个字符串按一定规则有几种切割方式
  3. 子集问题：一个N个数的集合里有多少符合条件的子集
  4. 排列问题：N个数按一定规则全排列，有几种排列方式
  5. 棋盘问题：N皇后，解数独等等



# 回溯算法之组合问题

​		组合问题不同于排序问题，组合问题对元素的前后顺序不做要求，其常见题型为：

**给定两数n、k，求出集合[1,n]中所有k个数的组合**

例如给定n = 4, k = 2,要从1，2，3，4中找出所有两个数的组合，按顺序寻找，应该为

- 1 2

- 1 3

- 1 4  ...

  找到1 2这个组合后，进行回溯，将2剔除，然后将3放入，以此类推，直到找出所有组合

[77.组合](https://leetcode-cn.com/problems/combinations/)

用最传统的暴力法去解决此类问题时，考虑用嵌套for循环去做，for循环的层数等于k，当k过大时，嵌套循环有点不切实际，于是可以考虑用递归去实现，一层递归就代表一层for循环。

```c++
class Solution{
private:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(int n, int k, int startIndex){
        //确定终止条件
        if(path.size() == k){
            res.push_back(path);
            return;
        }
        //确定单层递归逻辑
        for(int i = startIndex; i <= n; i++){
            path.push_back(i);
            backtracking(n , k , i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n ,k ,1);
        return res;
    }  
};
```

## 组合问题优化

​		当n = 4, k = 3时，从{1，2，3，4}中选择所有3个元素的组合，可以发现，当起始位置为3时便不可能满足条件了，因此可以引入剪枝的概念，提前终止循环。

- 集合中元素个数为path.size()
- 还需元素个数 k - path.size()
- 则最大起始位置为 ：n - (k - path.size()) + 1

```
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化的地方
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1);
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:

    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

## 组合总和Ⅲ

[216.组合总和Ⅲ](https://leetcode-cn.com/problems/combination-sum-iii/)

按照回溯三部曲，非常容易就能写出来

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(int k, int n, int cur_sum, int startIndex)
    {
        if (cur_sum > n) { // 剪枝操作
            return; // 如果path.size() == k 但sum != targetSum 直接返回
        }
        //终止条件
        if(cur_sum == n && path.size() == k){
            res.push_back(path);
            return ;
        }
		//确定单层递归逻辑
        for(int i = startIndex ; i <= 9; i++){
            path.push_back(i);
            cur_sum += i;
            backtracking(k ,n ,cur_sum, i + 1);
            path.pop_back();
            cur_sum -= i;
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(k , n , 0,1);
        return res;
    }
};
```



## 电话号码的字母组合

[17.电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![](C:\Users\Sakura\Desktop\17_telephone_keypad.png)

对输入的数字进行遍历，首先建立一个数组，将字母与数字进行映射

```c++
const string letterMap[10] = {
    "", // 0
    "", // 1
    "abc", // 2
    "def", // 3
    "ghi", // 4
    "jkl", // 5
    "mno", // 6
    "pqrs", // 7
    "tuv", // 8
    "wxyz", // 9
};
```

**回溯三部曲**

- 确定递归函数的参数和返回值

递归函数传入输入的数字字符串，并且需要维护一个整型变量Index，表示遍历到了第几个数字

```c++
vector<string> res;
string path;
void backtracking(const string& digits, int index)
```

- 确定递归的终止条件

当遍历到最后一个数字是终止递归，将当前组合加入结果数组中

```c++
if(index == digits.size()){
	res.push_back(path);
	return;
}
```

- 确定单层搜索（递归）的逻辑
  - 首先找到当前index对应的字符串映射
  - 然后遍历字符串每个字母
  - 继续递归下一个数字

  ```c++
  //首先找到当前index对应的字符串映射
  int digit = digits[index] - '0';
  string letters = letterMap[digit];
  //然后遍历字符串每个字母
  for(int i = 0; i < letters.size(); i++){
  	path.push_back(letters[i]);
  	backtracking(digits, index + 1);
  	path.pop_back();
  }
  ```

**最终结果**

```c++
class Solution {
public:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
};

    vector<string> res;
    string path;

    void backtracking(const string& digits, int index)
    {
        if(index == digits.size()){
            res.push_back(path);
            return;
        }
        int digit = digits[index] - '0';
        string letters = letterMap[digit];
        for(int i = 0; i < letters.size(); i++){
            path.push_back(letters[i]);
            backtracking(digits,index + 1);
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return vector<string>{ };
        backtracking(digits,0);
        return res;
    }
};
```



## 组合总和

[39.组合总和]([39. 组合总和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/combination-sum/))

**回溯三部曲**

- 递归函数参数

  **此题为了避免重复情况，例如[2,2,3]和[3,2,2],需要设定一个startIndex，用于表示每次循环的起点，防止遍历已经遍历过的元素**

  ```c++
  void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
  ```

  

- 递归终止条件

  当当前和等于给定值或者大于给定值时函数返回

  ```c++
    if(sum == target){
              res.push_back(path);
              return;
    }else if(sum > target) return;
  ```

  

- 单层循环逻辑

  ```c++
  for(int i = startIndex; i < candidates.size(); i++){
        path.push_back(candidates[i]);
        sum += candidates[i];
      //与前面的组合问题不同，此处的startIndex不需要+1，表示可以重复选取元素
        backtracking(candidates,target,sum,i);
        sum -= candidates[i];
        path.pop_back();
  }
  ```

  

**最终结果**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
    {
        if(sum == target){
            res.push_back(path);
            return;
        }else if(sum > target) return;

        for(int i = startIndex; i < candidates.size(); i++){
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(candidates,target,sum,i);
            sum -= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracking(candidates,target,0,0);
        return res;
    }
};
```



**剪枝优化**

```c++
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

## 组合总和Ⅱ

[组合总和Ⅱ](https://leetcode-cn.com/problems/combination-sum-ii/)

该题与上一题相比，区别在于该题每个数字只能用一次，并且此题数组有重复元素，而上题没有

我首次提交时，是基于上一题的代码，将递归代码中的 i 改成了 i+1，表示不可以使用重复元素

```c++
backtracking(candidates,target,sum,i) --->> backtracking(candidates,target,sum,i + 1)
```

按逻辑上来说，这么改应该是没有问题的，但是提交后却发现有重复的元素，

![image-20211006111509910](C:\Users\Sakura\AppData\Roaming\Typora\typora-user-images\image-20211006111509910.png)

究其原因，是因为输入数组中含有重复的元素1，若去掉重复元素，则结果无问题。

因此，该题在进行遍历，要进行去重。

回溯法遍历是个二维的遍历，横向遍历是for循环，竖向遍历是递归，该题去重是要在横向遍历上去重，即竖向上允许重复。例如，对于数组[1,1,3,4]，target = 7,首先取数字1，递归时继续取数字1，这是允许的，但在for循环中，当i = 0时，第一数字取1，当i = 1时，第一个数字也取1，这是不允许的,因为若允许，则会出现两个一样的结果[1,3,4]。

因此，设置一个vector<bool> used数组，当

```c++
if(i > 0 &&candidates[i] == candidates[i-1] && used[i - 1] == false){
   continue;
}
```

时，表示在同一层使用过了candidates[i]，因此直接跳过，而当

```c++
candidates[i] == candidates[i-1] && used[i - 1] == true
```

时，表示candidates[i]与candidates[i-1]在同一根树枝上，允许重复

**完整代码**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex,vector<bool>& used)
    {
        if(sum == target){
            res.push_back(path);
            return;
        }else if(sum > target) return;

        for(int i = startIndex; i < candidates.size(); i++){
            if(i > 0 &&candidates[i] == candidates[i-1] && used[i - 1] == false){
                continue;
            }
            path.push_back(candidates[i]);
            used[i] = true;
            sum += candidates[i];
            backtracking(candidates,target,sum,i + 1,used);
            sum -= candidates[i];
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        vector<bool> used(candidates.size(),false);
        backtracking(candidates,target,0,0,used);
        return res;
    }
};
```



# 回溯算法之切割问题

[131.分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

切割问题类似于组合问题

组合问题是不停的将字符放入当前path，而切割问题则是在不同的位置放置分割线

回溯三部曲：

1. 确定递归函数的参数和返回值

   本题也要求不能重复分割，因此需要一个startIndex用于记录每次起始位置

2. 确定递归终止条件

   当起始位置超过字符串长度时，表示递归结束，将当前结果放入结果数组

3. 确定单层递归逻辑

   每进行一次分割，对当前结果进行一个回文串判断，若是回文串，则继续向下，若不是，则跳过

**完整代码**

```c++
class Solution {
private:
    vector<vector<string>> result;
    vector<string> path; // 放已经回文的子串
    void backtracking (const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome(s, startIndex, i)) {   // 是回文子串
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {                                // 不是回文，跳过
                continue;
            }
            backtracking(s, i + 1); // 寻找i+1为起始位置的子串
            path.pop_back(); // 回溯过程，弹出本次已经填在的子串
        }
    }
    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
public:
    vector<vector<string>> partition(string s) {
        result.clear();
        path.clear();
        backtracking(s, 0);
        return result;
    }
};
```

## 复原IP地址

[93.复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

该题与上一题类似，也是一种切割问题，但是该题最多只能切割3次，即只能有三个 ‘ . ’ 符号，因此该题的递归终止条件变为

```c++
if (pointNum == 3) { // 逗点数量为3时，分隔结束
      // 判断第四段子字符串是否合法，如果合法就放进res中
      if (isValid(s, startIndex, s.size() - 1)) {
      	result.push_back(s);
      }
      return;
}
```

**递归三部曲**

1. 确定递归函数参数

   相比与上题，该题的递归函数需要多一个pointNum参数用于记录当前字符串中点的数量

   ```c++
   void backtracking(string& s, int pointNum, int startIndex)
   ```

   

2. 确定递归终止条件

   ```c++
   if (pointNum == 3) { // 逗点数量为3时，分隔结束
         // 判断第四段子字符串是否合法，如果合法就放进res中
         if (isValid(s, startIndex, s.size() - 1)) {
         	result.push_back(s);
         }
         return;
   }
   ```

   

3. 确定单层循环逻辑

   相比于上题，该题是在给定的字符串中直接进行插入操作

   ```c++
    for(int i = startIndex; i < s.size() ;i++)
           {
               if(isValid(s,startIndex,i)){
                   s.insert(s.begin() + i + 1,'.');
                   pointNum++;
                   backtracking(s,pointNum,i + 2);
                   pointNum--;
                   s.erase(s.begin() + i + 1);
               }else{
                   break;
               }
           }
   ```

   

**完整代码**

```c++
class Solution {
public:
    vector<string> res;

    bool isValid(const string& s, int start, int end)
    {
        if(start > end) return false;
        if(s[start] == '0' && start != end) return false;
        int num = 0;
        for(int i = start; i <= end; i++)
        {
            if(s[i] > '9' || s[i] <'0') return false;
            num = num * 10 + s[i] - '0';
            if(num > 255) return false;
        }
        return true;
    }
 
    void backtracking(string& s, int pointNum, int startIndex)
    {
        if(pointNum == 3){
            //判断最后一段字符是否满足条件
            if(isValid(s,startIndex,s.size() - 1)){
                res.push_back(s);
            }
            return ;
        }
        for(int i = startIndex; i < s.size() ;i++)
        {
            if(isValid(s,startIndex,i)){
                s.insert(s.begin() + i + 1,'.');
                pointNum++;
                backtracking(s,pointNum,i + 2);
                pointNum--;
                s.erase(s.begin() + i + 1);
            }else{
                break;
            }
        }
    }
    vector<string> restoreIpAddresses(string s) {
        backtracking(s,0,0);
        return res;
    }
};
```



# 回溯算法之子集问题

[78.子集](https://leetcode-cn.com/problems/subsets/)

子集问题比起之前的组合问题以及切割问题，前两个问题是收集多叉树的叶子节点，而子集问题是收集多叉树的每一个节点，因此，每遍历一个节点，都要将它加入结果集

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums,int startIndex)
    {
        //判断循环终止条件之前进行节点的加入
        res.push_back(path);
        if(startIndex > nums.size()) return;
        for(int i = startIndex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backtracking(nums,i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums,0);
        return res;
    }
};
```

## 子集Ⅱ

[90.子集Ⅱ](https://leetcode-cn.com/problems/subsets-ii/)

此题类似于组合Ⅱ，与子集Ⅰ比起来，子集Ⅱ给定的数组中含有重复元素，这就需要与组合Ⅱ问题一样，进行去重，我在这里采用与组合Ⅱ一样的去重思路，定义一个used数组

```c++
nums[i] == nums[i-1] && used[i - 1] == false
```

时，表示在同一层已经使用过nums[i]，跳过此层循环、

**完整代码**

```c++

class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;

    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己
        if (startIndex >= nums.size()) { // 终止条件可以不加
            return;
        }
        for (int i = startIndex; i < nums.size(); i++) {
            if(i > 0 && nums[i] == nums[i-1] && used[i-1] == false)
            {
                continue;
            }else{
                path.push_back(nums[i]);
                used[i] = true;
                backtracking(nums, i + 1, used);
                used[i] = false;
                path.pop_back();
            }
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(),false);
        sort(nums.begin(),nums.end());
        backtracking(nums, 0, used);
        return result;
    }
};
```



## 递增子序列

[491.递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

该题给定的数组中，可能含有重复元素，因此要考虑去重的问题，但是与之前的题目又不相同，因为不能将给定的数组事先排序

按照此想法，我写的代码如下：

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;

    void backtracking(vector<int>& nums,int startIndex,vector<bool> used)
    {
        if(path.size() >= 2){
            res.push_back(path);
        }
        if(startIndex > nums.size()){
            return;
        }
        for(int i = startIndex; i < nums.size(); i++){
            if(i > 0 && nums[i] == nums[i-1] && used[i-1] == false){
                continue;
            }else{
                if(path.empty() || nums[i] >= path.back()){
                    path.push_back(nums[i]);
                    used[i] = true;
                    backtracking(nums,i+1,used);
                    used[i] = false;
                    path.pop_back();
                }else{
                    continue;
                }
            }
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        vector<bool> used(nums.size(),false);
        backtracking(nums,0,used);
        return res;
    }
};
```

但是提交后却出现了问题，当给定输入[1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]，我的结果中出现了重复元素

![image-20211010153655272](C:\Users\Sakura\AppData\Roaming\Typora\typora-user-images\image-20211010153655272.png)

这些组合在以第一个1为第一个元素时，就已经加入了结果数组，遍历到后面的1时，进行了重复加入。

因此不能使用之前的去重逻辑

在该题中，使用一个哈希表用于记录每一层中是否重复使用了元素,在递归函数中定义该哈希表，新的一层哈希表都会重新定义。

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;

    void backtracking(vector<int>& nums,int startIndex)
    {
        //记录每个符合条件的节点
        if(path.size() >= 2){
            res.push_back(path);
        }
        if(startIndex > nums.size()){
            return;
        }
        unordered_set<int> uset; // 使用set对本层元素进行去重
        for(int i = startIndex; i < nums.size(); i++){
            if (uset.find(nums[i]) != uset.end()) {
                    continue;
            }else{
                if(path.empty() || nums[i] >= path.back()){
                    uset.insert(nums[i]);
                    path.push_back(nums[i]);
                    backtracking(nums,i+1);
                    path.pop_back();
                }
                else{
                    continue;
                }

            }
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {

        backtracking(nums,0);
        return res;
    }
};
```

**优化**

​	使用哈希表相对费时间，注意到题目中-100 <= nums[i] <= 100，因此可以用一个数组来记录。

```c++
int used[201] = {0}; // 这里使用数组来进行去重操作，题目说数值范围[-100, 100]
if ((!path.empty() && nums[i] < path.back())|| used[nums[i] + 100] == 1) {
    continue;
}
```

