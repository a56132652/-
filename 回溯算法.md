# 回溯算法

​		回溯算法与递归算法相辅相成，其实际上是一个暴力的算法，下面是回溯法的模板

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

回溯法可以看成是对一个多叉树的遍历，其中，for循环遍历多叉树的宽度，而递归则去遍历多叉树的深度。

- 回溯三部曲
  1. 确定递归函数的参数和返回值
  2. 确定递归的终止条件
  3. 确定单层搜索（递归）的逻辑

## 回溯算法之组合问题

​		组合问题不同于排序问题，组合问题对元素的前后顺序不做要求，其常见题型为：

**给定两数n、k，求出集合[1,n]中所有k个数的组合**

例如给定n = 4, k = 2,要从1，2，3，4中找出所有两个数的组合，按顺序寻找，应该为

- 1 2

- 1 3

- 1 4  ...

  找到1 2这个组合后，进行回溯，将2剔除，然后将3放入，以此类推，直到找出所有组合

[77.组合](https://leetcode-cn.com/problems/combinations/)

用最传统的暴力法去解决此类问题时，考虑用嵌套for循环去做，for循环的层数等于k，当k过大时，嵌套循环有点不切实际，于是可以考虑用递归去实现，一层递归就代表一层for循环。

```c++
class Solution{
private:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(int n, int k, int startIndex){
        //确定终止条件
        if(path.size() == k){
            res.push_back(path);
            return;
        }
        //确定单层递归逻辑
        for(int i = startIndex; i <= n; i++){
            path.push_back(i);
            backtracking(n , k , i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n ,k ,1);
        return res;
    }  
};
```

