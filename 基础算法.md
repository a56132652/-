# 一、快速排序

## 1. 快排模板

```c++
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}

作者：yxc
链接：https://www.acwing.com/blog/content/277/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```c++
#include <iostream>
using namespace std;

const int N = 1e6 + 10;

int n;
int q[N];

void quick_sort(int q[], int l, int r)
{
    if(l >= r) return;
    
    int x = q[l + r >> 1], i = l - 1, j = r + 1;
    while(i < j)
    {
        do i++; while(q[i] < x);
        do j--; while(q[j] > x);
        if(i < j) swap(q[i],q[j]);
    }
    
    quick_sort(q, l, j);
    quick_sort(q, j+1, r);
}

int main()
{
    scanf("%d",&n);
    for(int i = 0; i < n; i++) scanf("%d",&q[i]);
    
    quick_sort(q,0,n-1);
    
    for(int i = 0; i < n; i++) printf("%d ",q[i]);
    
    return 0;
} 
```

## 2. 第k个最小的数

[786. 第k个数](https://www.acwing.com/problem/content/788/)

```c++
#include <iostream>

using namespace std;

int n;
int k;
const int N = 1e6 + 10;

int q[N];

void quick_sort(int q[], int l, int r)
{
    if(l >= r) return;
    int i = l - 1, j = r + 1;
    int mid = q[(l + r)/2];
    while(i < j){
        do i++; while(q[i] < mid);
        do j--; while(q[j] > mid);
        if(i < j) swap(q[i],q[j]);
    }
    quick_sort(q,l,j);
    quick_sort(q,j+1,r);
}

int main()
{
    scanf("%d%d", &n, &k);
    for(int i = 0; i < n ;i++) scanf("%d", &q[i]);
    
    quick_sort(q,0,n-1);
    
    printf("%d", q[k-1]);
    
    return 0;
}
```

[剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

```c++
class Solution {
public:
    void quick_sort(vector<int>& arr , int l, int r)
    {
        if(l >= r) return;
        int i = l - 1, j = r + 1;
        int mid = arr[(l+r)/2];
        while(i < j){
            do i++; while(arr[i] < mid);
            do j--; while(arr[j] > mid);
            if(i < j) swap(arr[i],arr[j]);
        }
        quick_sort(arr,l,j);
        quick_sort(arr,j+1,r);
    }
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        quick_sort(arr,0,arr.size()-1);
        vector<int> res;
        res.assign(arr.begin(),arr.begin()+k);
        return res;
    }
};
```



# 二、归并排序

## 1. 归并模板

```c++
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}

作者：yxc
链接：https://www.acwing.com/blog/content/277/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

[787. 归并排序 - AcWing题库](https://www.acwing.com/problem/content/789/)

```c++
#include <iostream>
using namespace std;

const int N = 1e6 + 10;
int n;
int q[N] , tmp[N];


void merge_sort(int q[], int l, int r)
{
    if(l >= r) return;
    int mid = l + r >> 1;
    
    merge_sort(q,l,mid);
    merge_sort(q,mid+1,r);
    
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}

int main()
{
    scanf("%d",&n);
    for(int i = 0; i < n; i++){
        scanf("%d", &q[i]);
    }
    merge_sort(q,0,n-1);
    
    for(int i = 0; i < n; i++){
        printf("%d ",q[i]);
    }
    
    return 0;
}
```

## 2. 逆序对的个数

[788. 逆序对的数量 - AcWing题库](https://www.acwing.com/problem/content/790/)

```c++
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int a[N], tmp[N];

LL merge_sort(int q[], int l, int r)
{
    if (l >= r) return 0;

    int mid = l + r >> 1;

    LL res = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else
        {
            res += mid - i + 1;
            tmp[k ++ ] = q[j ++ ];
        }
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];

    return res;
}

int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

    cout << merge_sort(a, 0, n - 1) << endl;

    return 0;
}

```

[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

```c++
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        vector<int> temp(nums.size());
        return mergeSort(0,nums.size()-1,nums,temp);
    }

private:
    int mergeSort(int l ,int r, vector<int>& nums, vector<int>& temp)
    {
        if(l >= r) return 0;
        int mid = (l + r)/2;
        int res = mergeSort(l,mid,nums,temp) + mergeSort(mid+1,r,nums,temp);
        for(int k = l; k <= r; k++){
            temp[k] = nums[k];
        }
        int i = l, j = mid+1;
        for(int k = l; k <= r; k++){
            if(i == mid + 1 && j <= r)
                nums[k] = temp[j++];
            else if(j == r + 1 || temp[i] <= temp[j])
                nums[k] = temp[i++];
            else{
                nums[k] = temp[j++];
                res += mid -i + 1;
            }
        }
        return res;
    }
};
```



# 三、二分

## 1. 整数二分模板

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}

作者：yxc
链接：https://www.acwing.com/blog/content/277/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 2. 浮点数二分模板

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

