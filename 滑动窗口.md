# 1. 找到字符串中所有字母异位词

[438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。

## 思路：

### 	暴力法：

一开始我就想到了用滑动窗口，每次判断滑动窗口里面的词是不是字母异位词，但在判断这一步不知道用什么方法实现，一开始想着用一个哈希表存储p,然后遍历滑动窗口中的词，但转念一想，这不就跟暴力法一摸一样了嘛，然后自己写了个暴力法，果然超时了。

```c++
class Solution {
public:
    bool ifTrue(string s,int i, int j,unordered_map<char,int> hash)
    {
        if(j >= s.size()) return false;
        for(int left = i; left <= j; left++)
        {
            if(hash.find(s[left]) != hash.end()){
                hash[s[left]]--;
                if(hash[s[left]] == 0)
                    hash.erase(s[left]);
            }else
                return false;
        }
        return hash.empty();
    }
    vector<int> findAnagrams(string s, string p) {
        unordered_map<char,int> hash;
        vector<int> res;
        for(auto x : p) hash[x]++;
        for(int i = 0; i < s.size(); i++)
        {
            if(ifTrue(s,i,i+p.size()-1,hash))
                res.push_back(i);
        }
        return res;
    }
};
```

### 	滑动窗口：

然后看解析，**利用数组来存储窗口内每个字母出现的次数，然后比较两个数组是否相等**。

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int ns = s.size();
        int np = p.size();
        if(ns < np) return vector<int>{};
        vector<int> vs(26,0);
        vector<int> vp(26,0);
        vector<int> res;

        for(int i = 0; i < np; i++){
            vs[s[i] - 'a']++;
            vp[p[i] - 'a']++;
        }
        if(vs == vp) res.push_back(0);

        for(int i = 0; i < ns - np;i++)
        {
            vs[s[i] - 'a']--;
            vs[s[i + np] - 'a']++;
            if(vs == vp) res.push_back(i+1);
        }
        return res;
    }
};
```



